# 1. 서론
- 소프트웨어 아키텍트는 직업순위에서 최고 반열이지만 다른 직업에 비해 커리어패스가 분명하지 않음
    1. 명확한 정의가 아직도 없음
        - 규정지을 수 있는 사람들이 아님
        - 아키텍처는 중요한 것들에 관한 것이다 그게 무엇이든 말이다.
    2. 방대한 분야를 포괄하며, 업무 범위도 계속 넒어지고 있음
        - 예전에는 모듈성, 컴포넌트, 패턴 등 순수 기술적인 부분을 다룸
        - 폭넓은 능력을 활용하는 새로운 아키텍처 스타일의 등장으로 인해 역할과 범위가 확대됨
    3. 빠르게 발전하는 분야이고, 아키텍처는 끊임없이 변함
        - 커플링 등의 다른 관심사와 언제나 트레이드오프가 존재
        - 대부분의 소프트웨어 아키텍처는 이것을 정적인 문제로 취급
        - 소프트웨어 아키텍처는 그 정의를 포함한 본질 자체가 동적임
    4. 소프트웨어 아키텍처에 관한 자료는 대부분 역사적인 연관성을 강조
        - 과거 아키텍트들이 시도했으나 해로운 부수 효과만 식별하게 된 것들로 난잡하게 얽혀 있음
        - 그런 과정에서 얻은 많은 교훈들이 책에서 다루어짐
- 소프트웨어 아키텍처의 범위는 끊임없이 변화하는 개발 세상의 유일한 요소가 아님
- 지난 수십년간 달라진 것들을 나열하는 것 보다 달라지지 않은 것을 찾아보는게 더 쉬울 정도
- 소프트웨어 아키텍트는 끊임없이 변하는 생태계안에서 뭔가 결정을 내리는 사람들
- 아키텍처란 콘텍스트로서만 이해할 수 있음
    - 아키텍트가 내링 결정은 대부분 그들이 그렇게 결정한 당시 환경에 기인한 것

## 1.1 소프트웨어 아키텍처란?
- 시스템의 청사진
- 시스템 개발의 이정표
- 시스템을 '**분석**' 한다면 무엇을 '**분석**'한다는 말일까?
- 시스템 구조
    - 시스템이 구현된 아키텍처 스타일의 종류 (마이크로서비스, 레이어드, 마이크로커널 등)
    - 시스템 구조만으로 아키텍처 전체를 설명하기에는 부족함
- 시스템의 아키텍처를 완전히 이해하려면 알아야 하는 것
    - 아키텍처 특성
    - 아키텍처 결정
    - 설계 원칙
- 아키텍처 특성
    - 시스템의 기능과 직교하는 시스템 성공 기준을 결정
    - 시스템 기능에 관한 지식을 필요로 하는 것은 아니지만, 시스템이 올바르게 동작하기 위해서는 반드시 필요한 것들
- 아키텍처 결정
    - 시스템 구축에 필요한 규칙들을 정한 것
    - 시스템의 제약조건을 형성하며, 개발자가 해도 되는 것과 하지 말아야 할 것을 알려줌
    - 어떤 상황, 또는 다른 제약조건 탓에 시스템의 어느 한 부분에서 아키텍처 결정을 구현할 수 없다면, 그 결정은 변형을 통해 깨뜨릴 수 있음
    - 아키텍처 심사 위원회(Architecture Review Board)에서 사용하는 변형 모델을 갖고 있는 회사들이 많음
    - 어떤 표준이나 아키텍처 결정의 변형을 추구하는 프로세스를 규정함
    - 아키텍처 결정에 대한 예외는 ARB가 검토하여 타당한 근거와 트레이드오프를 고려한 뒤 승인/거부함
- 설계 원칙
    - 아키텍처 결정이 반드시 지켜야할 규칙이라면 설계 원칙은 가이드라인
   
## 1.2 아키텍트에 대한 기대치
- 역할, 직책, 직무에 상관없이 소프트웨어 아키텍트에게 바라는 핵심적인 여덟가지 요구사항
    - 아키텍처 결정을 내린다
    - 아키텍처를 지속적으로 분석한다
    - 최신 트렌드를 계속 유지한다
    - 아키텍처 결정의 컴플라이언스를 보장한다
    - 다양한 기술과 경험에 노출된다
    - 비즈니스 도메인 지식을 보유한다
    - 대인 관계 기술이 뛰어나다
    - 정치를 이해하고 처세를 잘한다
### 1.2.1 아키텍처 결정을 내린다
- 아키텍트는 아키텍처와 설계 원칙을 결정하고 팀, 부서뿐만 아니라 회사 전체의 기술 결정을 가이드하는 사람
- 아키텍트는 기술 선택을 가이드하는 사람, 정해주는 사람이 아님
- 아키텍처 결정과 설계 원칙을 통해 기술 선택을 가이드하는 일은 생각보다 어려움
- 아키텍트는 확장성, 성능, 가용성 등의 아키텍처 특성을 수호하기 위해 특정한 기술을 결정해야 할 때도 있는데, 그 기술을 지정한 행위 자체를 아키텍처 결정
### 1.2.2 아키텍처를 지속적으로 분석한다
- 아키텍트는 끊임없이 아키텍처와 현재 기술환경을 분석하고 이를 개선하기 위한 해결 방안을 제시
- 몇년전에 정의한 아키텍처가 지금도 얼마나 현실성 있는지 평가하는 아키텍처 역동성에 관한 요구사항
- 대부분의 아키텍처 구조는 쇠락하는 양상을 보임
- 성능, 가용성, 확장성 등의 필수 아키텍처 특성에 영향을 미치는 코드를 개발자가 작성하거나 설계를 변경 할 때 이런 증상이 보임
- 아키텍트는 테스팅과 릴리스 환경을 망각하기 쉬움
    - 민첩하게 코드를 수정할 수 있는 능력은 분명 큰 장점
    - 수정한 코드를 테스트하는 데 몇 주나 걸리고 릴리스까지 수 개월이 소요된다면 전체적인 아키텍처면에서 민첩하다 볼 수 없음
- 아키텍트는 기술 변화와 문제 영역을 종합적으로 분석하여 아키텍처의 건전성을 추구해야 함
- 애플리케이션을 계속 적절하게 유지할 수 있는 능력을 갖고 있어야 함
### 1.2.3 최신 트렌드를 계속 유지한다
- 아키텍트는 항상 최신의 기술과 업계 트렌드를 따라가야 함
- 개발자는 자신이 매일 사용하는 기술을 항상 갈고 닦아 최신 상태로 유지해야 계속 일을 할 수 있음
- 아키텍트는 최신 기술과 업계 트렌드를 따라가야하는, 한층 더 중요한 요구사항을 달성해야 함
- 아키텍트가 결정한 것들은 대개 오래 지속되고 바꾸기도 어려움
- 핵심 트렌드를 이해하고 계속 쫓아갈 수 있어야 미래를 대비하고 올바른 결정을 내릴 수 있음
### 1.2.4 아키텍처 결정의 컴플라이언스를 보장한다
- 아키텍트는 아키텍처 결정과 설계 원칙의 컴플라이언스를 보장해야 함
- 컴플라이언스 보장
    - 아키텍트가 정의하고 문서화하여 전달한 아키텍처 결정과 설계 원칙들을 개발팀이 제대로 준수하고 있는지 지속적으로 확인
    - 개발자가 아키텍처 결정을 준수하지 않도록 하지 않으면 위반 사례는 곳곳에서 발생
- 자동화 피트니스 함수화 자동화 도구를 이용해 컴플라이언스를 측정
### 1.2.5 다양한 기술과 경험에 노출된다
- 아키텍트는 다양한 기술, 프레임워크, 플랫폼, 환경에 노출되어야 함
- 아키텍트는 다양한 기술을 거리낌없이 쓸 줄은 알아야 함
- 최소한 시스템이나 서비스가 어떤 언어와 플랫폼, 기술로 개발되었든지 다양한 시스템과 서비스를 연동하는 방법은 알고 있어야 함
- 자신이 가장 익숙한 영역을 점점 넓혀나가는 것이 가장 좋음
- 한 가지 기술이나 플랫폼에만 올인하는 것은 안일한 태도
- 유능한 아키텍트는 여러 가지 언어, 플랫폼, 기술을 경험할 기회를 적극적으로 모색하면서 기술의 깊이보다는 폭에 초점을 둠
- 기술의 폭이란, 아주 제사히는 몰라도 본인이 잘 알고 있는 것과 연관지어 알고 있는 것들을 말함
### 1.2.6 비즈니스 도메인 지식을 보유한다
- 아키텍트는 어느 수준 이상의 비즈니스 도메인 전문가여야 함
- 비즈니스 도메인 지식이 없으면 비즈니스의 문제점, 목표, 요구사항을 이해하기 어려움
- 따라서, 비즈니스 요구사항을 수용할 만한 아키텍처를 설계하기 어려워짐
- 가장 성공적인 아키텍트는 폭넓은 실무 기술 지식과 더불어 특정 도메인에 깊이 있는 지식을 보유한 사람들
- 고위급 간부, 업무 담장자 등의 이해관계자들이 이해하는 도메인 지식과 언어를 사용해 효과적으로 소통할 수 있음
- 소프트웨어 아키텍트로서 자신이 무슨 일을 하고 있는지 분명히 알고 있고, 정확하고 효율적인 아키텍처를 구축할 능력을 지니고 있다는 강한 신뢰감을 느끼게 함
### 1.2.7 대인 관계 기술이 뛰어나다
- 아키텍트는 팀워크, 조정, 리더십을 포함한 대인 관계 기술이 뛰어나야 함
- 기술자는 천성이 기술적인 문제 해결을 좋아하지, 사람에 관한 문제에는 그리 관심이 없는 사람이라 먼 나라 이야기처럼 들림
- 제럴드 와인버그 : "**그들이 당신에게 뭐라고 말하든 항상 사람이 문제입니다.**"
- 아키텍트는 개발팀을 기술적으로 이끌기만 하는 사람이 아니라, 개발팀을 리드해서 아키텍처를 구현하는 사람
- 리더십 스킬은 소프트웨어 아키텍트로서 성공하기 위해 필수 요구사항의 절반 이상은 차지함
- 강력한 리더십과 대인 관계 스킬은 다른 아키텍트와 차별화하는 유리한 강점
### 1.2.8 정치를 이해하고 처세를 잘한다
- 아키텍트는 기업 내부의 정치적 분위기를 이해하고 적절하게 잘 처신할 줄 알아야함
- 협상 기술은 정말 중요하고 또 중요
- 아키텍트가 내린 거의 모든 결정은 사람들의 반발에 부딪히게 마련
- 아키텍처 결정을 실천하려면 시간과 비용을 들여야 함
- 제품 오너, 프로젝트 관리자, 비즈니스 이해 담당자들의 뭇매를 맞게 될 수 밖에 없음
- 자신의 방식이 더 낫다고 주장하는 개발자들의 공격도 피할 수 없음
- 대부분의 결정을 사람들이 수용하도록 기본적인 협상 기술을 발휘해야 함
- 협상 기술은 리더십만큼이나 중요하고 꼭 필요

## 1.3 아키텍처의 교차점 그리고...
- 소프트웨어 아키텍처의 범위는 지난 10년동안 점점 더 많은 책임과 관점을 아우르는 방향으로 확대됨
- 10년 전에는 아키텍처와 운영의 관계는 보통 공식적인 계약으로 한정됐고 번거로운 행정 절차가 뒤따름
- 자체 운영보다 서드파티 회사에 외주를 맡김
- 가동 시간, 확장성, 응답성 그 밖의 중요한 아키텍처 특성을 서비스 수준 협약으로 묶어 이행을 요구
- 지금의 마이크로서비스 같은 아키텍처에서는 예전에 순전히 운영 관심사였던 부분을 자유롭게 넘나들 수 있게 됨
- 과거에는 탄력적 확장 기능을 구현하려면 고통스러운 과정이 수반
- 마이크로서비스는 아키텍트와 데브옵스 간에 소통을 하면서 훨씬 수월하게 처리
### 1.3.1 엔지니어링 프랙티스
- 과거 소프트웨어 아키텍처는 스프트웨어 개발 프로세스와 분리
- 폭포수 모델, 애자일 등 소프트웨어를 구축하는 인기 방법론은 소프트웨어 아키텍처에 그리 큰 영향을 끼치지 못함
- 소프트웨어 개발 프로세스는 팀을 어떻게 구성하고 관리할지, 회의는 어떻게 하고 워크플로 조직은 어떻게 운영할지 등 사람을 조직하고 상호작용하는 총체적인 기법
- 소프트 엔지니어링 프랙티스는 프로세스와 무관하게 가시적이고 반복 가능한 혜택을 주는 실천론
- 지속적 통합은 특정 프로세스에 의존하지 않는 검증된 엔지니어링 프랙티스
- 엔지니어링 프랙티스에 집중하는 것은 중요함
    - 소프트웨어 개발 분야는 보다 성숙한 다른 엔지니어링 체계에 있는 많은 특성이 빠져 있음
        - ex : 토목 엔지니어는 소프트웨어 엔지니어보다 결과를 더 정확하게 예측할 수 있음
    - 소프트웨어 개발의 아킬레스 건 중 하나는 추정
        - 얼마나 오래 걸리고, 얼마나 많은 리소스가 필요하고, 얼마나 많은 비용이 들어갈 지 내다봐야 함
        - 알려지지 않은 미지의 것들 때문에 추정이 어려움
        - 모든 아키텍처는 알려지지 않은 미지의 것들 때문에 자꾸 되풀이되는데, 애자일은 단지 이것을 인지해서 더 빨리 수행하는 것이다
- 프로세스는 아키텍처와 거의 분리되어 있지만 소프트웨어 아키텍처의 속성상 반복적인 프로세스가 잘 맞음
- 아키텍트는 프로젝트 기술 리더를 겸하는 경우도 많기에 팀의 엔지니어링 프랙티스를 결정함
- 아키텍처 스타일과 엔지니어링 프랙티스가 공생 관계망을 형성하도록 해야 함
- 문제 영역마다 적합한 아키텍처 스타일이 있듯이 엔지니어링 프랙티스도 동일한 종류의 공생관계를 맺음
- 익스트림 프로그래밍에서 시작된 사고 방식은 지속적 전달까지 발전
- 근래에는 엔지니어링 프랙티스가 진보한 덕분에 아키텍처에서 새로운 능력을 펼칠 수 있게됨
- Building Evolutionary Architectures, Neal
    - 아키텍처 거버넌스의 자동화를 개선할 수 있는, 엔지니어링 프랙티스와 아키텍처의 교차점을 새로운 시각으로 바라봐야 된다고 강조
    - 시간이 지남에 따라 우아하게 변화하는 아키텍처를 구축하는 기법을 다룸
- 소트웨어 개발 세계에 정적인 건 하나도 없음
- 아키텍트는 어떤 기준에 맞게 시스템을 설계할 순 있지만, 그 설계는 구현과 소프트웨어 개발 생태개ㅖ의 어쩔 수 없는 변화를 모두 거치면서 살아남아야 함
- 우리가 필요한 것은 진화하는 아키텍처
- Building Evolutionary Architectures은 시간이 지나 변경이 일어나도 아키텍처 특성을 수호, 관장하기 위해 진화 연산에서 유래된 피트니스 함수라는 개념을 소개
- 개발자는 유전 알고리즘을 설계할 때 솔루션을 변경하여 새로운 솔루션으로 계속 진화시키는 다양한 기법들을 갖고 있음
- 이런 알고리즘을 특정한 용도로 설계할 때 개발자는 반드시 결과를 측정하여 최적해에 가까워졌는지, 멀어졌는지 확인해야하는데 그 측정 수단이 피트니스 함수
- Building Evolutionary Architectures은 이 아이디어를 차용한 아키텍처 피트니스 함수를 제시함
- 아키텍처 피트니스 함수는 어떤 아키텍처 특성의 객관적인 완전성을 평가하는 수단
    - 메트릭 (지표)
    - 단위 테스트
    - 모니터
    - 카오스 엔지니어링
    - 등의 다양한 매커니즘이 이 평가에 포함
- 이 책은 피트니스 함수의 모든 내용을 다루지는 않지만 적용 가능한 부분이 나오면 사용법을 예를 들어 설명함
- 피트니스 함수의 실행 빈도와 피트니스 함수가 제공하는 피드백 사이의 관계를 눈여겨 봐야함
- 지속적 통합, 자동화 머신 프로비저닝 등의 애자일 엔지니어링 프랙티스를 채택하고 탄력적인 아키텍처를 좀 더 쉽게 구축하는 유사한 프랙티스도 살펴보면서, 아키텍처가 엔지니어링 프랙티스와 서로 어떻게 연관되는지 이야기함
### 1.3.2 운영/데브옵스
- 데브옵스의 출현과 더불어 최근 두드러진 아키텍처와 유관 분야 간의 교차점은 아키텍처 공리를 다시 음미한 결과
- 오랫동안 많은 기업들이 개발과 운영은 별도 기능이라고 생각하여 비용 절감 차원에서 외주를 맡기는 경우가 많았음
- 대부분 아키텍트가 운영을 마음대로 할 수 없다는 전제하에 그러한 제약 위주로, 방어적으로 구축
- 구식 아키텍처는 탄력적으로 확장할 수 있도록 설계된 까닭에 아키텍처 프로세스가 극도로 복잡했음
- 마이크로서비스 아키텍처 스타일을 정립한 아키텍트들은 운영 관심사는 운영으로 처리해야 더 매끄럽다는 사실을 깨달음
- 아키텍처와 운영 간에 연결고리를 맺어 설계를 단순화하고, 운영자가 잘 처리할 수 있는 부분은 운영에 맡기게 됨
### 1.3.3 프로세스
- 소프트웨어 아키텍처는 소프트웨어 개발 프로세스에 거의 직교적이라는 공리가 있음
- 소프트웨어를 구축하는 방법(프로세스)은 사실 소프트웨어 아키텍처(구조)에 별다른 영항을 끼치지 않음
- 개발 프로세스가 소프트웨어 아키텍처에 일부 영향을 끼칠수는 있지만, 역사적으로 이 둘은 거의 별개라고 간주됨
- 개발팀의 프로세스는 소프트우어 아키텍처 여러 파트에 영향을 미침
- 애자일 프로젝트를 하는 아키텍트는 반복적인 개발을 통해 의사 결정에 필요한 피드백을 더 빨리 받아보리라 기대할 수 있고, 피드백에 의존하는 실험과 다른 지식에 더욱 적극적으로 참여 가능
- 모든 아키텍처는 단지 시간 문제일 뿐 반복적임
- 애자일 방법론을 기반으로 하되 반드시 예외를 도출할 것
- 재구성은 애자일 방법론의 진면목을 볼 수 있는 중요한 아키텍처 분야 중 하나
- 팀은 종종 아키텍처를 어떤 패턴에서 다른 패턴으로 바꾸어야 할 필요서을 깨달음
- 모놀리식 아키텍처 -> 현대적인 아키텍처로 이동
- 피드백 루프가 더 촘촘하고 스트랭글러 패턴, 기능 토글 등의 기법 덕분에 기획만 가득한 프로세스보다 이런 종류의 변경이 더 잘 지원됨
### 1.3.4 데이터
- 중요한 애플리케시연의 개발은 일반적으로 관계형 데이터베이스 형태의 외부 데이터 스토리지가 큰 비중을 차지
- 코드와 데이터는 공생 관계, 상대방이 없으면 무용지물
- 데이터베이스 관리자는 아키텍트와 협업하여 복잡한 시스템의 데이터 아키텍처를 구축하며
- 관계 및 재사용이 애플리케이션의 포트폴리오에 어떤 영향을 미치는지 분석
- 책에서 아키텍처 퀀텀과 아키텍처 운영 문제를 논할 때, 데이터베이스처럼 중요한 외부 관심사는 반드시 포함할 것

# 1.4 소프트웨어 아키텍처 법칙
- 소프트웨어 아키텍처의 범위는 거의 무한에 가까울 정도로 광활하지만 이 모든 것을 통합하는 요소 존재
- 소프트웨어 아키텍처 제 1법칙
    - "소프트웨어 아키텍처의 모든 것은 다 트레이드오프다"
        - 깔끔하게 떨어지는 것은 하나도 없음
        - 상충되는 팩터를 전부 고려해야 함
    - "아키텍트가 트레이드오프 아닌 뭔가를 발견했다고 생각했다면 그것은 그가 아직 트레이드 오프를 발견하지 못했다는 증거일 가능성이 높다"
- 제2법칙
    - "'어떻게'보다 '왜'가 더 중요하다"
    - 아키텍트는 자신이 전혀 모르는 기존 시스템을 들여다보면서 아키텍처의 구조적인 작동 원리는 알아낼 수 있지만, 왜 다른 것 대신 그런 선택을 하게 됐는지 설명하기 어려움
