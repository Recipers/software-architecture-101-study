# 17.1 역사

- 대부분의 아키텍처 스타일은 반복적으로 나타나는 패턴을 처음 발견한 아키텍트의 이름을 따서 명명한다.
  - 소프트웨어 개발 생태계가 변화하면서 많은 아키텍트들은 공통의 결정에 이르는 것이 일반적이다.
- 이런 점에서 MSA는 사뭇 다르다. 사용 초기부터 이름이 붙여졌고, 2014년 3월 마틴 파울러, 제임스 루이스가 쓴 Microservices라는 유명 블로그 게시글 덕분에 널리 퍼지게 되었다.
  - 두 사람은 비교적 새로운 이 아키텍처 스타일에서 많은 공통점을 찾아냈다.
- MSA는 DDD 사상의 영향을 많이 받았다. 특히 디커플링 스타일을 나타낸 바운디드 컨텍스트 개념은 MSA에 결정적인 영향을 미쳤다.
  - 개발자가 정의한 도메인에는 코드, 데이터베이스 스키마 같은 아티팩트에서 식별되는 수많은 엔티티와 행위가 포함된다.
  - 바운디드 컨텍스트 내부에서는 코드, 데이터베이스 스키마 같은 내부요소들이 함께 연결되어 작동되지만 경계 콘텍스트 외부에있는 것들(DB, 클래스 정의)은 전혀 커플링되자 않는다.
- 재사용은 유익하지만 커플링이 문제이다. 재사용을 선호하는 시스템을 설계하다 보면 결국 상속이나 조합을 이용하여 커플링이 맺어지게 된다.
- 고도의 디커플링이 아키텍트의 목표라면 재사용보다 중복을 우선할 것이다. MSA의 주요 목표는 바운디드 컨텍스트의 논리적 개념을 물리적으로 모델링하는 고도의 디커플링이다.

# 17.2 토폴로지

<img width="560" alt="스크린샷 2025-06-19 오후 1 35 02" src="https://github.com/user-attachments/assets/ffdfcfc4-83cf-493c-8b27-add8fc3b2b62" />

- 마이크로서비스는 단일 목적만 가지기 때문에 오케스트레이션 기반의 서비스 지향 아키텍처 같은 다른 분산 아키텍처보다 서비스 규모가 훨씬 작다.
  - 각 서비스에는 DB 및 기앝 정송적인 컴포넌트 등 서비스가 독립적으로 작동되는데 필요한 모든 것들이 준비되어 있다.

# 17.3 분산

- MSA는 분산 아키텍처를 형성한다.
  - 서비스는 자체 프로세스로 실행된다. 서비스를 이정도로 디커플링하면 애플리케이션을 호스트하는 육중한 멀티테넌트 인프라 아키텍처에서 자주 발생하는 문제들을 간단히 해결할 수 있다.
  - 예를 들어, 애플리케이션 서버를 이용해 다수의 애플리케이션을 관리할 때에도 네트워크 대역폭, 메모리, 디스크 공간등 여러가지 혜택을 운영 측면에서 재사용할 수 있다.
  - 지원해야할 애플리케이션이 계속 늘어나면 일부 리소스는 공유 인프라의 제약을 받을 수 밖에 없다. 또 공유 애플리케이션 간의 잘못된 분리도 문제가 되는 경우가 있다.
- 공유함으로써 불거지는 문제들은 각 서비스를 자체 프로세스로 분리하면 자연스럽게 해소된다.
- MSA의 분산 속성 탓에 성능은 다소 부정적이다.
  - 네트워크 호출은 메서드 호출보다 오래걸리고, 엔드포인트마다 보안 검증 정차를 거치면 그만큼 처리 시간이 소요된다.
  - 그러므로 서비스 세분도에 대해 심사숙고해야 한다.
- MSA는 분산 아키텍처의 일종이므로 개발자가 서비스 경계를 넘나드는 트랜잭션을 사용하지 않도록 권고해야 한다.
  - 이 아키텍처는 서비스를 얼마나 세분화할 것인가를 잘 결정하는 것이 성공의 관건이다.
 
# 17.4 경계 콘텍스트
- 서비스마다 도메인이나 워크플로를 모델링하는 개념이다.
  - 클래스, 기타 부속 컴포넌트, 데이터베이스 스키마 등 애플리케이션 작동에 필요한 모든 것들이 각 서비스에 들어간다.
  - 이런 사고방식은 아키텍트의 결정에 지대한 영향을 미친다.
  - 모놀리식 사고 방식으로는 공통 클래스를 다른 애플리케이션 파트의 개발자가 공유하는 것이 당연하지만 MSA에서는 커플링을 가급적 삼가므로 차라리 중복이 낫다고 생각한다.
- MSA 는 도메인 분할 아키텍처의 개념을 극도로 우려낸 결과물이다. 각각의 서비스는 어느 한 도메인이나 서브도메인을 나타낸다.
  - 여러 면에서 도메인 주도 설계의 논리적 개념을 물리적으로 구현한 것이다.
 
### 17.4.1 세분도
- 알맞은 세분도를 찾기 위해 고심하다가 종종 서비스를 너무 잘게 나누는 실수를 저지르곤한다.
  - 그래서 뭔가 유용한 작업을 하려면 서비스간 통신 링크를 다시 구축해야 하는 지경에 이른다.
- 마이크로서비스란 거대 서비스에 대비되는 용어로 사용됐다. 그러나 많은 개발자는 마이크로서비스라는 용어를 마치 지령처럼 받아들여 서비스를 지나치게 새분화하기 시작했다.
- 서비스 경계는 도메인이나 워크플로를 캡처하는 것이 목표이다.
  - 어느 애플리케이션에서 당연하게 여겨지는 경계가 다른 시스템 파트에서는 너무 큰 단위가 될 수 있다.
  - 어떤 비즈니스 프로세스는 다른 비즈니스 프로세스보다 더 단단히 커플링되어 있을지 모른다.
 
**목적**
- 가장 확실한 경계는 이 아키텍처 스타일의 본래 의도인 도메인이다. 각 서비스는 기능적으로 매우 응집되어 있고 전체 애플리케이션을 대표하여 하나의 핵심 기능을 제공하는 가장 이상적인 모습이다. 

**트랜잭션**
- 여러 엔티티가 개입하여 작동되는 트랜잭션을 좋은 서비스 경계 후보이다.분산 아키텍처에서 트랜잭션은 문제가 될 소지가 있으므로 그런 문제를 방지할 수 있도록 설계하는것이 바람직하다

**코레오그래피**
- 도메인 격리는 잘 되었지만, 서로 광범위한 통신을 해야 제대로 작동하는 서비스를 구축할 경우, 통신 오버헤드를 줄이기 위해 하나로 뭉치는 것을 고려해야 할 수도 있다.
- 좋은 서비스 설계안을 도출하는 유일한 방법은 이터레이션이다. 처음 한 번 시도로는 완벽한 것을 만들 수는 없다.

### 17.4.2 데이터 격리
- 경계 콘텍스트 개념에 따라 데이터를 격리해야 한다.
  - 대부분의 다른 아키텍처는 데이터를 단일 DB에 저장하지만 MSA는 통합 지점으로 사용되는 공유 스키마, 데이터베이스 등 모든 종류의 커플링을 없애려고 한다.
- 데이터 격리는 아키텍트가 서비스 세분도를 살필 때 반드시 고려해야 할 팩터이다. 엔티티 함정에 유의하여 서비스를 단순히 데이터베이스 엔티티와 비슷하게 모델링해서는 안된다.
- 아키텍트는 시스템 내부 값들을 RDBMS에 통합하여 단일 진실 공급원(SSOT)을 만드는 것에 익숙하다.
  - 그러나 MSA에서는 이렇게 하면 안되므로 어떻게 하면 아키텍처 전체에 데이터를 분산시킬 수 있을지 결정해야 한다.
  - 도메인을 어떤 팩트에 대한 진실 공급원으로 식별하여 그 값을 가져올 수 있게 잘 조정하든지, 데이터베이스 복제나 캐시 기술로 정보를 분산시키든지, 구체적인 방안이 필요하다.
- 이 정도 수준의 데이터 격리만으로도 골치가 아프지만 긍정적인 부분도 있다.
  - 여러 팀이 각 서비스마다 단가, 스토리지 종류, 그 밖의 여러 요소들을 저울질하며 가장 적합한 도구를 선택할 수 있다.
  - 고도로 분리된 시스템에서 다른 팀에 영향을 끼치지 않고 상황에 맞게 더 적합한 데이터베이스를 선택할 수 있다.

# 17.5 API 레이어
- 필수는 아니지만 여러 시스템 컨슈머 사이에 API 레이어(유저 인터페이스 또는 다른 시스템의 호출)가 있다.
  - API 레이어는 프록시를 경유하여 간접화하거나 네이밍 서비스 같은 운영 장치에 물려서 유용한 작업을 수행하기 좋은 위치에 있기 때문에 이 아키텍처에서 많이 쓰인다.
- API 레이어를 중재자나 오케스트레이션 도구로 사용하지 않아야 한다.
  - 모든 비즈니스 로직은 경계 콘텍스트 내부에서 일어나야 하며, 오케스트레이션 등의 다른 로직을 중재자에 넣는 것은 규칙 위반이다.

# 17.6 운영 재사용
- 마이크로서비스가 커플링보다 복제를 선호한다고 언급했다. 그러면 모니터링, 로깅, 회로차단기 등의 운영 관심사와 같이 커플링이 더 유리한 아키텍처 부분은 어떻게 처리하나?
- 여러 마이크로서비스를 구축한 이후에 살펴보면 각 서비스에 공통적인 요소가 있고, 그 유사성을 활용하면 더 유리한 부분이 있음을 알게된다.
  - 서비스 팀마다 자체 모니터링 체제를 구축하도록 허용하면 팀별로 알아서 잘하리라 장담할 수 없다.
  - 업그레이드 같은 문제도 있다.
- 이런 문제를 해결하는 방법이 바로 사이드카 패턴이다.

<img width="489" alt="스크린샷 2025-06-19 오후 2 03 15" src="https://github.com/user-attachments/assets/12972234-3f8b-40d6-bac2-6cab07ac642b" />

- 공통 운영 관심사를 각 서비스마다 별도의 컴포넌트에 두고, 해당 팀이나 공유 인프라 팀이 소유할 수 있도록 한다.
  - 사이드카 컴포넌트는 팀이 서로 커플링되면 더 유리한 모든 운영 관심사를 도맡아 처리한다.

 <img width="513" alt="스크린샷 2025-06-19 오후 2 05 54" src="https://github.com/user-attachments/assets/404086dc-1e2f-464d-adb9-03d4cfa80e49" />

- 각 서비스에는 공통 사이드카가 포함돼 있으므로 서비스 메시를 구축하면 로깅, 모니터링 등의 관심사를 아키텍처 전체적으로 일원화하여 제어할 수 있다.
  - 공통 사이드카 컴포넌트는 모든 마이크로서비스들에 대해 일관된 운영 인터페이스를 제공한다.
 
<img width="555" alt="스크린샷 2025-06-19 오후 2 07 21" src="https://github.com/user-attachments/assets/d3134d0b-1e69-45a2-99bf-168da39cfc43" />

- 서비스 메시 자체는 개발자가 서비스를 전체적으로 액세스할 수 있는 콘솔 역할을 한다.
- 전체 메시에서 각 서비스는 하나의 노드이다. 서비스 메시는 각 팀이 모니터링 레벨, 로깅, 그 밖의 공통 운영 관심사 등의 운영과 커플링된 부분을 글로벌하게 제어하는 콘솔이다.
- 탄력성을 부여하는 수단으로 서비스 디스커버리를 사용한다.
  - 어느 하나의 서비스를 직접 호출하는게 아니라, 모든 요청이 서비스 디스커버리 도구를 거치도록 하면 요청 수와 빈도를 모니터링할 수 있고 필요시 서비스 인스턴스를 늘려 확장성/탄력성을 줄 수 있다.
  - 보통 서비스 메시 안에 서비스 디스커버리를 포함시켜 모든 마이크로서비스의 일부로 만드는 경우가 많다.

# 17.7 프런트엔드
- 마이크로서비스는 디커플링을 선호한다. 유저 인터페이스와 백엔드 역시 분리되는 모습이 가장 좋다.
  - 그래서 마이크로서비스 아키텍처의 유저 인터페이스는 보통 두 가지 스타일로 나타난다.
 
<img width="555" alt="스크린샷 2025-06-19 오후 2 13 48" src="https://github.com/user-attachments/assets/11bb1601-ac5b-49ab-aab1-3fd4b0a3a049" />

- 유저 요청을 처리하기 위해 단일 유저 인터페이스가 API 레이러를 통해 호출하는 모놀리식 프런트엔드이다.

<img width="548" alt="스크린샷 2025-06-19 오후 2 14 31" src="https://github.com/user-attachments/assets/81066077-c83c-4b5d-a86e-e37c9cc9ddb2" />

- 마이크로프런트엔드는 유저 인터페이스 레벨의 컴포넌트를 백엔드 서비스로 활용하여 유저 인터페이스를 동기적인 수준으로 세분화하고 격리한다.
  - 각 서비스는 자기 서비스에 해당하는 유저 인터페이스를 내보내고, 프런트엔드는 내보내진 유저 인터페이스 컴포넌트를 조정한다.

# 17.8 통신
- 데이터 격리와 통신 모두에 영향을 미치는 적절한 세분도를 찾고자 씨름한다.
  - 올바른 통신 스타일을 발견하는 것 또한 팀이 서비스를 디커플링하면서 유용한 방향으로 조정하는데 도움이 된다.
- 동기로 할지, 비동기로 할지 근본적인 통신 방식을 결정해야 한다.
  - 일반적으로 MSA는 '프로토콜 인지 이종 간 상호 운용성'을 활용한다.
- **프로토콜 인지**
  - 운영 커플링을 방지하고자 중앙 통합 허브를 갖고 있지 않기 때문에 각 서비스는 다른 서비스를 호출하는 방법을 알고 있어야 한다.
  - 다른 서비스를 호출할 때 어떤 프로토콜을 사용할지 알아야한다.
- **이종**
  - 분산 아키텍처라서 각 서비스마다 구현 기술 스택이 상이할 수 있다.
- **상호 운용성**
  - 여러 서비스가 서로 호출한다는 뜻이다. 서비스는 네트워크를 통해 다른 서비스를 호출하여 정보를 주고받으면서 협력해야 한다.
- 비동기 통신은 이벤트와 메시지를 주로 사용하며 내부적으로 이벤트 기반 아키텍처를 활용한다.
  - 브로커 패턴과 중재자 패턴은 마이크로서비스에서 각각 코레오그래피 패턴과 오케스트레이션 패턴으로 나타난다.

### 17.8.1 코레오그래피와 오케스트레이션
- 코레오그래피는 브로커 이벤트 기반 아키텍처와 통신 스타일이 동일하다.
  - 중앙의 중재자가 따로 없고 경계 콘텍스트 철학에 충실하다.
- 도메인/아키텍처 동형성은 특정한 문제에 어떤 아키텍처 스타일이 얼마나 적합한지 평가할 때 보아야 될 핵심 특성이다.
  - 이 용어는 아키텍처의 형상이 특정 아키텍처 스타일에 어떻게 매핑되는지 기술한다.
- 예를 들어, 실리콘 샌드위치의 기술 분할된 아키텍처는 구조상 맞춤성을 지원하고, 마이크로커널 아키텍처 역시 동일한 일반적인 구조를 갖고 있다.
  - 그러므로 고도의 맞춤성이 필요한 문제는 마이크로커널 아키텍처로 구현하는게 더 간편하다.
- 이와 마찬가지로 MSA는 디커플리을 추구하므로 마이크로서비스의 형상은 브로커 이벤트 기반 아키텍처와 닮았고 이 두 패턴은 서로 공생 관계이다.

<img width="548" alt="스크린샷 2025-06-19 오후 2 27 20" src="https://github.com/user-attachments/assets/b9ee7f9c-cc3a-4b0f-a0e6-fd8d235250f3" />

- 코레오 그래피에서 각 서비스는 중앙 중재자 없이 자신의 필요에 따라 다른 서비스를 호출한다.

<img width="619" alt="스크린샷 2025-06-19 오후 2 30 55" src="https://github.com/user-attachments/assets/19952d98-a8a8-4acc-96b3-7efa63433a16" />

- 전역 중재자를 따로 두지 않으므로 여러 서비스를 조정해야 할 경우 스스로 로컬중재자를 만들 수 있다.
- 개발자는 주어진 고객의 전체 정보를 조회하는 호출을 조정하는, 이 일만 담당하는 서비스를 따로 만든다. 유저가 중재자를 호출하면 이 중재자는 다른 서비스를 호출한다.
- 디커플링한다는 철학을 고집함으로써 많은 이점을 이끌어내지만 에러 처리, 조정 같은 공통적인문제는 코레오그래피 환경에서 훨씬 더 복잡해진다.

<img width="586" alt="스크린샷 2025-06-19 오후 2 33 17" src="https://github.com/user-attachments/assets/584ca8c1-d82c-4a96-b389-791924268679" />

- 처음 호출된 서비스는 자신의 다른 도메인 책임과 더불어 여러 타 서비스를 전체적으로 조정하는 중재자 역할도 겸한다.
  - 이런 패턴을 프런트 컨트롤러 패턴이라고 한다.
  - 이 패턴은 서비스 복잡도가 증가하는 단점이 있다.

<img width="570" alt="스크린샷 2025-06-19 오후 2 34 44" src="https://github.com/user-attachments/assets/ec8bf29d-aa15-496f-b90c-290bfa10f428" />

- 비즈니스 워크플로에 필요한 복잡한 처리를 담당하면서 조정 역할도 수행하는 중재자를 두면 서비스간 커플링이 발생한다.
  - 어느 한 서비스가 조정 작업을 전담하면 다른 서비스는 거의 영향을 받지 않는다.
  - 도메인/워크플로는 내재적으로 커플링되는 경우가 많다.

### 17.8.2 트랜잭션과 사가
- 여러 서비스에 걸친 트랜잭션을 어떻게 조정하는 게 좋을 지 고심에 빠질 때가 많다.
  - 특히 분산 애플리케이션에서는 데이터베이스 역시 동일한 수준의 디커플링이 필요하므로 모놀리식 애플리케이션에서 별 문제가 아니였던 원자성 문제도 대두된다.
- 서비스 경계를 넘나드는 트랜잭션을 그 자체로 마이크로서비스 아키텍처의 핵심 디커플링 원칙에 위배된다.
  - 여러 서비스에 걸쳐 트랜잭션을 걸고 싶어하는 아키텍트가 있다면 "그러지 말라"라고 충고하고 싶다. 대신 컴포넌트 세분도를 바로잡아야 한다.
  - 마이크로서비스 아키텍처를 구축한 후 뭔가 트랜잭션으로 서비스를 엮어야 할 필요가 생겼다면 십중팔구 지나치게 세분화한 것이다.
  - 트랜잭션 경계는 서비스 세분도를 가늠할 수 있는 일반적인 지표 중 하나이다.
- 물론 항상 예외는 있다. 예를 들어, 두 서비스가 서로 완전히 다른 아키텍처 특성을 필요로 하고 서비스 경계는 분명히 구분되어 있지만 여전히 한 트랜잭션으로 묶어야 할 때도 있다.
  - 이런 경우라면 적지 않은 트레이드오프를 감수하고 트랜잭션 오케스트레이션을 처리하는 패턴이 있다.

<img width="528" alt="스크린샷 2025-06-19 오후 2 41 22" src="https://github.com/user-attachments/assets/3c4b83e0-43b6-4c23-9c94-04ea37afc77f" />

- 마이크로서비스에서 널리 사용되는 분산 트랜잭션 패턴은 사가 패턴이다.
- 서비스는 여러 서비스 호출에 대해 중재자 노릇을 하면서 트랜잭션을 조정한다.
  - 중재자는 트랜잭션을 구성하는 파트를 하나씩 호출하여 성공/실패 여부를 기록하고 그 결과에 따라 흐름을 조정한다.
  - 계획대로 흘러간다면 서비스의 모든 값과 해당 데이터베이스 레코드는 동기 업데이트 될 것이다.

<img width="528" alt="스크린샷 2025-06-19 오후 2 43 06" src="https://github.com/user-attachments/assets/55165706-c655-4e30-937a-72f08cab0522" />

- 어느 한 파트라도 실패하면 중재자는 전체 트랜잭션 파트가 모두 성공하지 못하게 해야 한다.
- 중재자는 지금까지 성공한 모든 트랜잭션 파트에게 과거에 처리했던 내용을 undo하라는 요청을 보낸다.
  - 이런 종류의 트랜잭션 조정을 보상 트랜잭션 프레임워크라고 한다.
  - 전체가 다 성공했다고 중재자가 알릴 때 까지 중재자로부터 받은 각 요청을 보류 상태로 두는 식으로 구현한다.
  - 하지만 여기에 비동기 요청이 끼어들고, 특히 보류된 트랜잭션 상태에 따라 새로운 요청이 등장하면서 설계가 무척 복잡해진다. 또한 네트워크 레벨에서도 조정 트래픽이 꽤 많이 발생한다.
- 트랜잭션 작업마다 do/undo 로직을 개발하는 식으로 보상 트랜잭션 프레임워크를 구현할 수도 있다.
  - 트랜잭션 수행 중 조정은 덜 필요하지만 undo 작업은 do 작업보다 엄청나게 복잡해져 설계, 구현, 디버깅 작업량 역시 2배 이상 증가할 것이다.
- 여러 서비스에 트랜잭션을 걸어주는 것이 기술적으로 불가능한 것은 아니지만, 그럴 거면 굳이 마이크로서비스 패턴을 선택할 이유가 없다.
  - 물론 그래도 예외는 있기 마련이니, 필요한 경우에는 사가 패턴을 조금씩 곁들여 사용할 것을 권고한다.
  - `여러 서비스에 트랜잭션을 걸어야 하는 경우도 있습니다. 하지만 아키텍처 전반적으로 트랜잭션이 남용된다면 뭔가 단단히 잘못된 것입니다!`

# 17.9 아키텍처 특성 등급

<img width="431" alt="스크린샷 2025-06-19 오후 2 48 27" src="https://github.com/user-attachments/assets/34bd46fc-83c3-4299-84d1-c2ac4757558c" />

- 자동화 배포, 시험성, 그 밖에 이 등급표에 없는 것들을 비롯한 현대 엔지니어링 프랙티스를 이 아키텍처가 매우 훌륭하게 지원한다는 사실이다.
- 분산 아키텍처라서 런타임에 여러 조각들이 연결되고 그로 인해 많은 결함에 시달린다.
  - 따라서 서비스간 통신을 과용하면 내고장성, 신뢰성이 위협을 받는다.
  - 등급표의 별점은 이 아키텍처의 일반적인 경향을 나타낼 뿐, 개발자는 서비스 디스커버리를 통한 확장 및 리던던시를 이용해 많은 문제를 해결한다.
  - 하지만 정상적인 상황에서 독립적인 단일 목적의 서비스는 내고장성이 높은 편이므로 마이크로서비스 아키텍처에서 별점을 많이 받게 되었다.
- 이 아키텍처의 주안점은 확장성, 탄력성, 진화성이다.
  - 지금까지 개발된 가장 확장성이 우수한 시스템 중에는 이 아키텍처 스타일을 활용해서 성공을 거둔 사례가 많다.
  - 자동화 및 운영과의 지능적인 통합에 많이 의존하므로 개발자가 아키텍처에 탄력성을 줄 수 있다.
  - 디커플링을 선호하기 때문에 아키텍처 레벨에서도 요즘처럼 점진적으로 변화하는 비즈니스 프랙티스를 훌륭하게 지원한다.
  - 현대 비즈니스는 급변한다. 고도로 분리된 아주 작은 배포 단위를 지닌 아키텍처를 구축함으로써 더 빠르게 변경되는 시스템도 지원할 수 있는 체제를 마련할 수 있다
- 성능 문제가 불거질 때가 많다.
  - 분산 아키텍처는 특성상 작업을 완료하기 위해 잦은 네트워크 호출을 해야하므로 성능 오버헤드가 높고, 엔드포인트마다 신원 및 접근 권한을 확인하는 보안 체크도 해야한다.
  - 과도한 네트워크 호출을 줄이고 성능을 개선하기 위해 데이터 캐시, 데이터 복제 등의 기술을 많이 사용한다.
  - 커플링이 적을 수록 통신 속도가 증가하고 병목이 줄기 때문에 오케스트레이션보다는 코레이그래피를 더 많이 사용하는 편이다.
- 도메인 중심적인 아키텍처로써 각 서비스의 경계와 도메인이 일치해야 한다.
  - 현대 아키텍처 중에서도 가장 독보적인 퀀텀을 갖고 있다. 여러 방면에서 퀀텀 측정이 의미하는 바를 가장 잘나타내는 사례이다.
  - 극도의 디커플링을 추구하는 이 아키텍처의 철학은 수 많은 이들의 두통을 유발하지만, 잘만 만들면 어마어마한 이점을 누릴 수 있다.
