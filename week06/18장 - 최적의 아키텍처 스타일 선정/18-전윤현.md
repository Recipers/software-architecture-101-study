- 최적의 아키텍처 스타일은 없다. 상황에 따라 다르다.
  - 조직 내부의 수많은 팩터들과 어떤 소프트웨어를 구축하는지에 따라 맥락이 달라진다.
  - 아키텍처 특성, 도메인 고려사항, 전략적 목표, 그 밖의 다양한 것들의 트레이드오프를 고려하고 분석한 마지막 결과로 아키텍처 스타일을 선택하는 것이다.
 
# 18.1 아키텍처 '유행'은 계속 변한다.

**과거를 돌아보다**
- 새로운 아키텍처 스타일은 과거의 경험과 쓰라린 상처를 되돌아보면서 시작된다.
  - 다들 미래의 시스템을 내다보는 현재의 사고에 영향을 미친 과거의 경험을 갖고 있다.
  - 새로운 아키텍처 설계는 과거 아키텍처 스타일에서 발견된 결함이 반영된 경우가 많다.
 
**생태계의 변화**
- 끊임없는 변화는 소프트웨어 개발 생태계의 바람직한 특성이다.
  - 수년 전만 해도 쿠버네티스가 무엇인지 거의 아무도 몰랐지만 지금은 전 세계 수천명 개발자가 참석하는 콘퍼런스도 여럿 개최되고 있다.
 
**새로운 기능**
- 새로운 기능이 출현하면 아키텍처는 단순히 어떤 도구를 다른 도구로 대체하는 정도가 아닌, 완전히 새로운 패러다임으로 전환될 수 있다.
  - 과거 아키텍트나 개발자는 도커 같은 컨테이너가 소프트웨어 개발 전반을 뒤흔들 줄은 상상도 못했을 것이다.
  - 컨테이너는 하나의 진화 단계였지만 아키텍트, 도구, 엔지니어링 프랙티스, 그 밖의 수많은 것들이 IT 업계에 돌풍을 일으켰다.
  - 생태계가 지속적으로 변화하면서 새로운 도구와 기능들 역시 수시로 등장한다.
  - 아키텍트는 새로운 도구는 물론 새로운 패러다임 역시 주시해야 한다.
  - 작은 변화라도 아키텍트의 목표와 정확히 부합하는 변경일 수도 있다.
 
**가속**
- 생태계는 끊임없이 변할 뿐만 아니라 그 변화의 속도도 계속 빨라지고 있다.

**도메인 변경**
- 비즈니스가 계속 진화하고 타 회사와 합병되면서 개발자가 소프트웨어를 개발하는 도메인 역시 도통 가만히 있는 법이 없다.

**기술 변화**
- 기술이 진화할수록 조직은 최소한 그 변화의 흐름의 일부라도 따라잡으려고 한다.

**외부 팩터**
- 소프트웨어 개발과 관련된 많은 부녕 요인들이 조직의 변화를 가져오는 경우도 있다.
  - 예를 들어, 아키텍트와 개발자 모두 완벽하게 만족하는 도구가 있는데 라이선스 비용이 너무 비싼 까닭에 어쩔 수 없이 다른 도구를 알아봐야 하는 경우
- 현재 유행하는 아키텍처 관점에서 조직이 어느 위치에 있든 아키텍트는 업계 동향을 잘 파악해서 유행을 따르고 예외를 두어야 하는 경우를 현명하게 잘 결정해야 한다.

# 18.2 결정 기준
- 아키텍트는 아키텍처 스타일을 선택할 때 도메인 설계 구조의 원인이 될 만한 모든 요소를 종합적으로 고려해야 한다.
  - 기본적으로 주어진 도메인, 그리고 시스템을 성공적으로 구축하는 데 필요한 다른 모든 구조적 요소들을 설계한다.

**도메인**
- 도메인에서 중요한 여러가지 양상, 특히 어느 부분이 운영 아키텍처 특성에 영향을 미치는지 파악해야 한다.
  - 꼭 해당 분야의 전문가일 필요는 없다. 하지만 도메인에서 중요한 파트에 대해서 최소한의 지식을 가지고 있어야 한다.

**구조에 영향을 미치는 아키텍처 특성**
- 도메인과 다른 외부 요소를 지원하는데 필요한 아키텍처 특성을 정확하게 밝혀내야 한다.

**데이터 아키텍처**
- 아키텍트와 DBA는 서로 머리를 맞대고 데이터베이스, 스키마 등 데이터에 관한 문제를 의논해야 한다.
  - 신규 시스템이 이전에 그리고 현재 사용 중인 데이터 아키텍처와 상호작용할 경우, 아키텍트는 반드시 데이터 설계가 아키텍처 설계에 미치는 영향도를 미리 파악해야 한다.

**조직 문제**
- 갖가지 외부 팩터들도 설계에 영향을 준다.
  - 예를 들어 특정 클라우드 벤더사의 이용료가 이상적인 설계를 가로막는 장애물이 되거나 등등

**프로세스, 팀, 운영 문제에 관한 지식**
- 소프트웨어 개발 프로세스, 운영 팀과의 소통(또는 그런 소통의 결핍), QA 프로세스 등 프로젝트와 관련된 다양한 팩터들도 아키텍처 설계에 영향을 끼친다.
  - 예를 들어 애자일 성숙도가 결여된 조직에서 애자일에 기반한 엔지니어링 프랙티스에 의존하는 아키텍처 스타일을 도입하면 시작부터 난관에 부딪힐 것이다.
 
**도메인/아키텍처 동형성**
- 아키텍처의 토폴로지와 잘 맞는 문제 영역이 있다.
  - 예를 들어, 마이크로커널 아키텍처 스타일은 아키텍처적으로 플러그인 형태의 커스터마이징이 가능하므로 맞춤성이 필요한 시스템과 완벽하게 잘 어울린다.
  - 무수히 많은 개별 연산이 필요한 게놈 분석 시스템은 무수히 많은 개별 프로세서를 제공하는 공간 기반 아키텍처에 잘 어울릴 것이다.
- 반대로 문제 영역과 아키텍처 스타일이 불협화음이 나는 경우도 있다.
  - 예를 들어 규모가 큰 모놀리스 구조로는 확장성이 우수한 시스템을 설계하기 어렵다. 코드베이스 커플링이 심한데 다수의 동시 유저를 지원하는 것은 무리다.
  - 의미적으로 커플링된 곳이 도처에 널려 있는 문제 영역도 분산 아키텍처와 맞지 않는다.
    - 가령 각 페이지가 이전에 페이지의 콘텍스트에 따라 작동하는 멀티페이지 형태의 보험 회사 웹 애플리케이션을 마이크로서비스로 모델링하기 어렵다.
    - 이렇게 커플링이 높은 문제 영역은 서비스 기반 아키텍처처럼 커플링 정도가 낮은 아키텍처가 적합하다. 잘 맞지도 않은 분산 아키텍처로 설계하면 갖가지 설계 난제에 맞닥뜨리게 될 것이다.
- 아키텍처는 지금까지 열거한 모든 사항을 종합하여 다음과 같은 결정을 내려야 한다.

**모놀리스냐 분산이냐**
- 아키텍처 퀀텀 개념을 이용하여 단일 아키텍처 특성만으로도 충분한지, 시스템 파트별로 상이한 아키텍처 특성이 필요한지 판단해야 된다.
  - 전자의 경우 (다른 팩터들 때문에 결국 분산 아키텍처로 결정될 수 있지만) 모놀리스가 적합하다는 뜻이고, 후자의 경우 분산 아키텍처가 정답에 더 가깝다.

**데이터를 어디에 둘 것인가?**
- 일반적으로 모놀리스 아키텍처는 하나 또는 소수의 관계형 데이터베이스를 전제로하지만, 분산 아키텍처에서는 아키텍트가 어느 서비스에 어떤 데이터를 저장할지 결정해야 한다.
  - 워크플로를 구축하기 전에 전체 아키텍처의 데이터 흐름에 대해 충분히 숙고해야 한다.
  - 구조와 행위를 모두 고려하여 최적의 조합을 찾아내기 위해 설계를 무한반복 하는 것도 두려워해서는 안된다.

**서비스 간 통신은 동기, 비동기 중 어떤 스타일로 할 것인가?**
- 데이터 분할을 결정한 다음에 서비스 간 통신 방식을 동기로 할지, 비동기로 할지 결정해야 한다.
  - 동기 통신은 대부분 더 간편하긴 하지만 확장성, 안정성 그 밖의 다른 아키텍처 특성에 부정적인 영향을 미칠 수 있다.
  - 비동기 통신은 성능, 확장성 측면에서 우월하나, 데이터 동기화, 데드락, 경합 조건, 디버깅 등 골칫거리가 많다.
- 가급적 설계, 구현, 디버깅 문제가 적은 동기 통신을 기본으로 하되, 필요한 경우에는 비동기 통신을 함께 사용하는 것이 좋다.
- 이러한 설계 과정을 거치고 난 후의 결과물은, 아키텍트가 선택한 아키텍처 스타일(및 하이브리드화)이 반영된 아키텍처 토폴로지, 아키텍트가 심혐을 기울인 설계 부문의 아키텍처 결정 기록, 중요한 원칙과 운영 아키텍처 특성을 지키기 위한 아키텍처 피트니스 함수로 나타난다.

# 18.3 모놀리스 사례 연구: 실리콘 샌드위치
- 이 시스템은 단일 퀀텀으로 구현해도 충분하다고 결정했다.
  - 게다가 적은 예산으로도 구축 가능한 단순 애플리케이션이므로 모놀리스의 단순함이 더 어울리는 것 같다.
- 하지만 도메인 분할된 컴포넌트와 기술 분할된 컴포넌트, 이렇게 두 가지 상이한 컴포넌트로 설계했다.

### 18.3.1 모듈러 모놀리스

<img width="630" alt="스크린샷 2025-06-20 오후 6 46 00" src="https://github.com/user-attachments/assets/efee52ff-66c4-40cb-b753-c75fcade09e3" />

- 모듈러 모놀리스는 단일 퀀텀으로 배포된 단일 데이터베이스 기반의 도메인 중심 시스템이다.
- 총 비용을 줄이기 위해 단일 웹 기반 유저 인터페이스로 구현한 단일 관계형 데이터베이스 기반의 모놀리스이다.
  - 앞서 식별한 각 도메인이 이 그림에서 컴포넌트로 표시되어 있다.
  - 시간과 리소스가 넉넉하다면 도메인 컴포넌트 단위로 테이블과 기타 데이터베이스 자산을 분리하고 나중에 요구사항이 발생하면 분산 아키텍처로 쉽게 마이그레이션할 수 있도록 설계해야 한다.

### 18.3.2 마이크로커널

<img width="505" alt="스크린샷 2025-06-20 오후 6 57 29" src="https://github.com/user-attachments/assets/efe466d4-1bc2-41e3-894b-cab757acec7a" />

- 실리콘 샌드위치에서 식별된 아키텍처 특성 중 하나가 맞춤성이였다. 아키텍트는 도메인/아키텍처 동형성을 검토 후 마이크로커널 형태로 구현할 수 있다.
- 코어 시스템은 도메인 컴포넌트와 단일 관계형 데이터베이스로 구성된다.
  - 도메인과 데이터를 신중하게 동기화하면 향후 분산 아키텍처로 코어를 마이그레이션할 수 있다.
  - 커스터마이징은 각각 하나의 플러그인, (해당 데이터베이스가 포함된) 단일 플러그인 세트 내부의 공통 플러그인 들, (제각기 자체 데이터를 보유한) 일련의 로컬 플러그인 형태로 나타난다.
  - 어느 플러그인도 다른 것들과 커플링 될 일은 없으므로 각 플러그인은 따로 떨어져 자신의 데이터를 유지할 수 있다.
- BFF(Backends for Frontend) 패턴을 응용해서 API 레이어를 마이크로커널 어댑터로 사용하는 독특한 설계 방법도 있다.
  - 일반적인 정보는 백엔드가 제공하고, BFF는 이 정보를 프런트엔드 장치에 적합한 포맷으로 바꾸는 것이다.
- 모듈러 모놀리스, 마이크로커널 어느 쪽이던 실리콘 샌드위치 아키텍처는 엄청난 성능이나 탄력성을 요하지 않고, 오래 걸릴 작업이 없으므로 통신 방식은 동기식으로도 충분하다.

# 18.4 분산 아키텍처 사례 연구: GGG

<img width="605" alt="스크린샷 2025-06-20 오후 7 09 24" src="https://github.com/user-attachments/assets/10a91206-2c8c-48a8-8757-3991a4088561" />

- 이 아키텍처는 아키텍처의 여러 부분마다 상이한 아키텍처 특성을 필요로한다.
- 또한 어느 정도 야심 찬 수준의 규모, 탄력성, 성능, 그 밖의 까다로운 운영 아키텍처 특성이 요구사항에 명시되어 있다.
  - 아키텍처 내부의 세부적인 수준까지 고도의 커스터마이징이 가능한 패턴을 선택해야 한다.
  - 대부분의 아키텍처 특성을 충족하는 후보 분산 아키텍처로는 저수준의 이벤트 기반 또는 MSA가 있는데, 이 중 마이크로서비스가 다양한 운영 아키텍처 특성을 보다 잘 지원한다.
- MSA에서 요구사항에 명시된 성능을 달성하기는 만만찮은 일이지만, 성능 요건을 수용하도록 설계함으로써 아키텍처 곳곳의 약점을 보완할 수 있다.
  - 예를 들어, MSA는 원래 높은 수준의 확장성을 제공하지만, 오케스트레이션을 너무 많이 사용하거나 과도하게 데이터를 분리하는 등 성능에 영향을 미치는 갖가지 문제들을 해결해야 한다.
- 다음은 GGG의 세 가지 고유한 유저 인터페이스이다.
  - 입찰자: 온라인 경매에 참가한 수 많은 입찰자
  - 경매인: 경매 당 한 사람
  - 스트리머: 입찰자에게 동영상 및 입찰 스트리밍을 담당하는 서비스, 읽기 전용 스트림이므로 업데이트가 필요한 경우 최적화는 사용할 수 없다.
- 등장하는 서비들은 다음과 같다.
  - BidCapture: 온라인 입찰자의 입찰을 캡처해서 BidTracker로 비동기 전송한다. 온라인 입찰의 관문 역할을 할 뿐 퍼시스턴스 로직은 없다.
  - BidStreamer: 온라인 입찰자에게 입찰 정보를 고성능 읽기 전용 스트림으로 스트리밍한다.
  - BidTracker: AuctioneerCapture, BidCapture 양쪽에서 입찰을 추적한다.
    - 서로 다른 두 정보 스트림을 하나로 합하여 가능한 한 실시간에 가깝에 입찰을 정렬하는 컴포넌트이다.
    - 이 서비스의 두 인바운드 커넥션은 모두 비동기라서 개발자는 메시지 큐를 버퍼로 사용해 완전히 다른 속도로 메시지 흐름을 처리할 수 있다.
  - AuctioneerCapture: 경매인을 위해 입찰을 캡처한다. 퀀텀 분석 결과 아키텍처 특성이 완전히 다르므로 BidCapture와 AuctioneerCapture로 분리했다.
  - AuctionSession: 각 경매의 워크플로를 관리한다.
  - Payment: AuctionSession이 경과하여 경매가 완료된 후 결제 정보를 처리하는 서드파티 결제 서비스이다.
  - VideoCapture: 라이브 경매의 비디오 스트림을 캡처한다.
  - Video Streamer: 경매 동영상을 온라인 입찰자에게 스트리밍한다.
- 동기 통신 스타일과 비동기 통신 스타일을 주의 깊게 식별했다.
  - 비동기 통신을 선택한 것은 서비스마다 상이한 운영 아키텍처 특성을 감안한 결과이다.
  - 예를 들어, 결제 서비스가 새 결제 정보를 500밀리초마다 하나씩 처리 가능하고, 아주 많은 경매가 동시에 종료되는 일이 흔한 상황에서 동기 통신을하면 타임아웃과 여러 가지 안전성 문제가 발생할 수 있다. 이럴 때는 메시지 큐를 사용하여 취약성이 드러난 아키텍처의 주요 파트에 안전성을 확보할 수 있다.
 
<img width="605" alt="스크린샷 2025-06-20 오후 7 15 21" src="https://github.com/user-attachments/assets/83d9823b-121e-4145-b162-396dd224acea" />

- 설계는 대략 각 서비스에 대응되는 Payment, Auctioneer, Bidder, Bidder Streams, BidTracker 퀀텀을 포함한다.
  - 여러 인스턴스가 컨테이너 스택으로 표시되어 있다. 컴포넌트 설계 단계부터 퀀텀 분석 기법을 활용하여 서비스, 데이터, 통신 경계를 보다 쉽게 식별할 수 있다.
- 이것이 GGG 설계의 정답도 아니고, 유일무이한 설계도 아니다.
  - 심지어 이게 최선의 설계라고 생각하지도 않는다.
  - 하지만 적어도 트레이드오프가 가장 나쁜 것 중에서 제일 나은 설계인 것 같다.
  - MSA를 도입하고 이벤트와 메시지를 영리하게 잘 이용하면 일반적인 아키텍처 패턴을 아키텍처에서 최대한 활용하면서 향후 개발과 확장이 용이한 기반을 다질 수 있다.
