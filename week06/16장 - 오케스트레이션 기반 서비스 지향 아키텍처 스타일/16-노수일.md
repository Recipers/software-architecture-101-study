## 16.1 역사와 철학
- 90년대 후반에 등장
    - 대기업과 중소 기업 합병, 성장 뒷받침을 위한 세련된 IT 필요성 증가
    - 당시에는 컴퓨팅 리소스가 넉넉치 않고, 분산 컴퓨팅이 이제 막 궤도에 오름
    - 가변적인 확장성 등 다른 유용한 특성을 요구
- 어쩔 수 없이 제약이 많은 분산 아키텍처 구축
- 시스템 단위로 라이선스 구매, 데이터베이스 라이선스 복잡
- 최대한 재사용하는 것을 목표
    - 모든 형태의 재사용은 이 아키텍처의 중심 철학
- 아키텍트가 기술 분할에 집착한 형태, 취지는 좋았으나 결과는 좋지 않음
## 16.2 토폴로지
- 아키텍처 내부에 텍소노미(분류체계)를 정립하여 레이어별로 책임을 지움
- 분산 아키텍처
    - 조직마다 다양하므로 정확한 경계선 표시 애매
## 16.3 택소노미
- 이 아키텍처의 중심 철학은 엔터프라이즈 레벨의 재사용
- 텍소노미의 각 레이어를 통해 실현
### 16.3.1 비즈니스 서비스
- 아키텍처 최상단에 위치, 진입점 역할을 함
- 코드는 전혀 없고, 입력, 출력, 스키마 정보만 갖고 있음
### 16.3.2 엔터프라이즈 서비스
- 세분화된 공유 구현체를 포함함
- 일반적으로 개발팀은 특정 비즈니스 도메인에 관한 원자적 행위를 구현하는 업무를 담당함
- 오케스트레이션 엔진을 통해 묶인 단위가 큰 비즈니스 서비스를 구성하는 요소
- 재사용 목표 때문에 책임을 분리
- 재사용 가능한 엔터프라이즈 서비스 형태로 재사용 가능한 자산을 구축할 수 있을거라 믿음
    - 현실은 워낙 들쭉날쭉하여 실패
### 16.3.3 애플리케이션 서비스
- 모든 서비스에서 엔터프라이즈 서비스와 동일한 레벨의 세분화 또는 재사용이 필요한 것은 아님
- 한 번만 사용 가능한 단일 구현체 서비스
### 16.3.4 인프라 서비스
- 모니터링, 로깅, 인증/인가 등의 운영 관심사를 지원
- 인프라 팀이 소유한 실질적인 구현체
### 16.3.5 오케스트레이션 엔진
- 이 분산 아키텍처의 요체
- 비즈니스 서비스 구현체를 서로 엮어주며 트랜잭션 조정과 메시지 변환 등의 기능 수행
- 일반적으로 단일 관계형 데이터베이스를 사용
- 트랜잭셔널 로직은 데이터베이스가 아닌 오케스트레이션 엔진에서 선언적으로 처리
- 비즈니스와 엔터프라이즈 서비스의 관계, 이 둘을 매핑하는 방법, 트랜잭션 경계는 어디까지인지 등을 정의
- 통합 허브 역할도 겸하므로 커스텀 코드를 패키지와 레거시 소프트웨어 시스템에 통합할 수 있음
- 콘웨이의 법칙에 따르면, 이 엔진을 담당한 팀이 정치 세력화 되고, 관료적인 병목이 됨
- 트랜잭션을 어느 레벨까지 세분화할지 알아내기는 더욱 더 어려워졌음
    - 3, 4개 서비스를 분산 트랜잭션으로 감싸 개발하는 것은 가능했음
    - 서비스 간의 적절한 트랜잭션 경계가 어디쯤인지 개발자가 직접 알아내야 했기 때문에 아키텍처가 한 층 복잡해짐
### 16.3.6 메시지 흐름
- 모든 요청은 오케스트레이션 엔진을 흘러감
- 모든 로직이 오케스트레이션 엔진에 있으므로 내부 호출을 할 때에도 메시지는 엔진을 경유함
- 서비스 버스는 아키텍처 내부의 모든 호출을 중계하면서 통합 허브와 오케스트레이션 엔진, 두 가지 역할을 함
## 16.4 재사용... 그리고 커플링
- 이 아키텍처의 주된 목표는 서비스 레밸의 재사용
- 시간이 지남에 따라 재사용 가능한 비즈니스 행위를 점진적으로 구축하는 능력
- 단점
    - 재사용 위주로 시스템을 구축하다 보니 컴포넌트 간의 커플링이 심하게 발생
        - 재사용 서비스를 함부로 변경하면 다른 모든 서비스에 영향이 있음
    - 로직을 한 곳에 통합하는 것은 또 다른 부작용을 일으킴
        - 재사용 서비스는 관심사가 아닌 세부 정보를 가지고 있어야 함
- 조그만 변경이 여러 티어에 있는 수십 개 서비스와 단일 데이터베이스의 스키마 변경을 유발할 수 있음
- 트랜잭션 세분도가 정확하게 정의되지 않은 경우, 개발자는 설계를 변경하거나, 거의 동일한 서비스를 새로 만들어 트랜잭셔널 로직을 바꾸어야 함
- 재사용을 하기 위해 해야할 일이 너무 많음
## 16.5 아키텍처 특성 등급
- 지금까지 시도된 아키텍처 중에서 가장 기술적으로 분할된 범용 아키텍처
- 이 구조의 단점에 대한 반발로 인해 마이크로서비스 아키텍처 같은 현대적인 아키텍처 탄생
- 분산 아키텍처이지만 퀀텀 수는 1개
    - 일반적으로 단일 데이터베이스 또는 두세 개 데이터베이스를 사용하여 다수의 상이한 관심사를 포괄하는 아키텍처 커플링 지점을 형성함
    - 오케스트레이션 엔진이 거대한 커플링 지점 역할을 함
        - 모든 동작을 조정하는 중재자와 상이한 특성을 가질 수 없음
        - 모놀리식과 분산 아키텍처 모두의 단점을 가지고 있음
- 배포성, 시험성 아주 낮음
- 탄력성, 확장성을 일부 지원하지만 구현하기는 까다로움
- 단순성과 비용성은 대부분의 아키텍트가 선호하는 바와 반비례