# 16.1 역사와 철학
- 서비스 지향 아키텍처는 1990년대 후반에 등장했다.
  - 세련된 IT가 필요했지만, 당시에는 컴퓨팅 리소스가 넉넉하지 못했고 그나마 사용 제품들 뿐이였다.
  - 분산 컴퓨팅은 막 궤도에 올라 수요가 늘기 시작했으나, 많은 기업들은 가변적인 확장성등 다른 유용한 특성을 요구했다.
- 이 시대의 아키텍트들은 다양한 외부 여건 탓에 어쩔 수 없이 제약이 많은 분산 아키텍처를 구축했다.
  - 상용 데이터베이스는 라이런스 체계가 복잡하기 짝이 없었고, 그러다보니 애플리케이션 서버 벤더와 데이터베이스 벤더가 경쟁하는 구도였다.
  - 그 결과, 아키텍트는 최대한 재사용하는 것을 목표로 삼았다. 실제로 모든 형태의 재사용은 이 아키텍처의 중심 철학이다.
- 아 아키텍처 스타일은 아키텍트가 기술 분할에 집착하면 어떻게 되는지 잘 보여주는 사례이다.

# 16.2 토폴로지

<img width="566" alt="스크린샷 2025-06-19 오후 12 48 52" src="https://github.com/user-attachments/assets/f39333ab-0543-4d78-8c5b-4cd6ba41de88" />

# 16.3 택소노미
- 이 아키텍처의 중심 철학은 엔터프라이즈 레벨의 재사용이다.
  - 소프트웨어를 뜯어고치는 일에 신물이 난 많은 대기업은 문제를 해결할 방법을 찾아나서기 시작했고, 톡소노미의 각 레이어를 통해 실현했다.

### 16.3.1 비즈니스 서비스
- 최상단에 위치한 비즈니스 서비스는 진입점 역할을 한다. 예를 들어 ExecuteTrade, PlaceOrder 등의 서비스는 도메인 행위를 나타낸다.
- 이 서비스 정의는 코드가 전혀 없고, 입출력 스키마 정보만 가지고 있다.

### 16.3.2 엔터프라이즈 서비스
- 엔터프라이즈 서비스는 세분화된 공유 구현체를 포함한다.
  - 일반적으로 개발팀은 특정 비즈니스 도메인에 관한 원자적 행위를 구현하는 업무를 담당한다.
  - 이런 서비스는 오케스트레이션 엔진을통해 묶인, 단위가 큰 비즈니스 서비스를 구성하는 요소이다.
- 재사용 목표 때문에 이렇게 책임을 분리한 것이다.
  - 정확한 세분도에 맞게 엔터프라이즈 서비스를 구축할 수 있다면 비즈니스 워크플로의 해당 파트를 재작성할 필요가 없다.
- 현실은 워낙 들쭉날쭉하기에 이런 시도는 실패했다.
  - 솔루션이 정착된 건축 자재와 비즈니스 컴포넌트는 본질부터 다르다.
  - 소프트웨어 세계는 시장, 기술 변화, 엔지니어링 프랙티스, 그 밖의 다양한 팩터 때문에 안전성을 추구해도 그렇게 잘 안된다.

### 16.3.3 애플리케이션 서비스
- 아키텍처의 모든 서비스에서 엔터프라이즈 서비스와 동일한 레벨의 세분화 또는 재사용이 필요한건 아니다.
  - 애플리케이션 서비스는 한 번만 사용 가능한 단일 구현체 서비스이다.

### 16.3.4 인프라 서비스
- 모니터링, 로깅, 인증/인가 등의 운영 관심사를 지원한다.

### 16.3.5 오케스트레이션 엔진
- 분산 아키텍처의 요체이다. 비즈니스 서비스 구현체를 서로 엮어주며 트랜잭션 조정과 메시지 변환등의 기능을 수행한다.
  - MSA처럼 서비스마다 DB가 있는건 아니다. 일반적으로 단일 RDBMS를 사용한다.
- 오케스트레이션 엔진은 비즈니스와 엔터프라이즈 서비스와의 관계, 이 둘을 매핑하는 방법, 트랜잭션 경계는 어디까지인지 등을 정의한다.
  - 이 엔진은 통합 허브 역할도 겸하므로 아키텍트가 커스텀 코드를 패키지와 레거시 소프트웨어 시스템에 통합할 수 있다.
- 이 메커니즘이야말로 이 아키텍처의 핵심이므로 콘웨이의 법칙에 따르면 이 엔진을 담당한 통합 아키텍트팀이 조직에서 정치 세력화되고 결국 스스로 관료적인 병목이 될 것이다.
- 실제로는 거의 재앙에 가까웠다. 트랜잭셔널 로직을 오케스트레이션 도구에 위임한다는 아이더는 그럴 듯했으나, 트랜잭션을 정확히 어느 레벨까지 세분화해야 할지 알아내기가 어려웠다.
  - 3~4개 서비스를 분산 트랜잭션으로 감싸 개발하는 것은 가능했지만 적절한 경계가 어디쯤인지 개발자가 직접 알아내야했기 때문에 아키텍처는 한층 복잡해졌다.

# 16.3.6 메시지 흐름

<img width="352" alt="스크린샷 2025-06-19 오후 1 06 10" src="https://github.com/user-attachments/assets/f9ae9596-2a95-4b1f-8802-3dea50068d2f" />

- 모든 요청은 오케스트레이션 엔진으로 흘러간다. 이 아키텍처는 모든 로직이 오케스트레이션 엔진에 있으므로 내부 호출을 할 때도 메시지는 엔진을 경유한다.

# 16.4 재사용... 그리고 커플링
- 이 아키텍처의 주된 목표는 서비스 레벨의 재사용, 시간이 지남에 따라 재사용 가능한 비즈니스 행위를 점진적으로 구축하는 능력이다.

<img width="547" alt="스크린샷 2025-06-19 오후 1 08 35" src="https://github.com/user-attachments/assets/b874f302-f262-49f2-a28e-0c00dde87ce0" />

- 아키텍트는 보험 회사의 모든 부서에 Customer 개념이 포함되어 있다는 사실을 알아낸다.
  - 서비스 지향 아키텍처 관점에서는 고객과 관련된 부분을 재사용 가능한 서비스로 빼내 원리 서비스가 표준 고객 서비스를 참조하도록 만드는게 최선의 전략이다.

<img width="547" alt="스크린샷 2025-06-19 오후 1 10 20" src="https://github.com/user-attachments/assets/38e878c1-7c5b-4c91-976a-fad0a88b15d7" />

- 이러한 설계의 어두운 그림자가 서서히 드러나기 시작한다.
  - 재사용 위주로 시스템을 구축하다보니 컴포넌트간의 커플링이 심하게 발생한다.
  - Customer 서비스에 고객에 관한 모든 상세 정보를 담아야 한다.
    - 따라서 Customer 서비스는 장애 보험팀에게는 전혀 관심사가 아닌 운전 면허증의 세부 정보까지 가지고 있어야 한다.
- 분리와 재사용 철학의 관점에서는 일리가 있어 보였지만 실제로는 악몽이였다.
  - 특정 도메인 개념은 이 아키텍처 전체적으로 너무 얇게 퍼져 사실상 먼지가 조금 쌓일 정도였다.
  - 간단한 작업조차 여러 티어에 있는 수십 개 서비스와 단일 데이터베이스의 스키마 변경을 유발할 수 있다.
  - 현재 엔터프라이즈 서비스의 트랜잭션 세분도가 정확하게 정의되지 않은 경우, 개발자는 자신의 설계를 변경하거나 거의 동일한 서비스를 새로 만들어 트랜잭셔널 로직을 바꾸어야 한다.

# 16.5 아키텍처 특성 등급

<img width="403" alt="스크린샷 2025-06-19 오후 1 18 35" src="https://github.com/user-attachments/assets/d0c19073-4152-47dc-8a92-cad636b05760" />

- 서비스 지향 아키텍처는 가장 기술적으로 분할된 범용 아키텍처일 것이다.
  - 이 구조의 단점에 대한 반발로 인해 MSA 같은 보다 현대적인 아키텍처가 탄생하게 되었다.
- 배포성, 시험성 같은 요즘의 엔지니어링 목표는 별점이 아주 낮다.
- 탄력성, 확장성 같은 특성을 일부 지원하지만 구현하기는 상당히 까다롭다.
- 모든 팩터를 종합해보면, 단순성과 비용은 대부분의 아키텍트가 선호하는 바와 반비례한다.
  - 이 아키텍처는 분산 트랜잭션이 실세계에서 얼마나 구현하기 어려운지, 기술 분할의 실제 한계가 무엇인지 가르쳐준 중요한 이정표였다.

