# 2. 아키텍처 사고
- 아키텍처 사고
    - 아키텍트는 개발자와 다른 관점에서 주변을 바라봄
    - '아키텍처를 생각하는 것' 정도로 단순하게 여기는 것 보단 심오함
- 아키텍트의 사고방식 네가지
    - 아키텍처와 설계의 차이를 이해하고 아키텍처 작업을 진행하려면 개발팀과 어떻게 협력해야 할지 아는 것
    - 어느 정도 기술 깊이를 유지하면서, 폭넓은 기술 지식을 확보하는 것
        - 다른 사람이 보지 못하는 해결책과 가능성을 떠올릴 수 있음
    - 다양한 솔루션과 기술 간의 트레이드오프를 이해하고, 분석하고, 조율하는 것
    - 비즈니스 동인의 중요성을 이해하고 그것을 아키텍처 관심사로 해석할 줄 아는 것
## 2.1 아키텍처 대 설계
- 아키텍처와 설계의 차이점은 모호한 경우가 많음
- 아키텍트 : 비즈니스와 기술 문제를 해결하기 위해 아키텍처와 설계의 차이점을 알고 이 둘을 긴밀하게 통합할 솔루션을 모색
- 전통적인 아키텍트와 개발자 책임 비교
    - 비즈니스 요구사항을 분석해서 아키텍처 특성을 도출/정의하고 어떤 아키텍처 패턴과 스타일이 해당 문제 영역에 가장 알맞는지 선택하여 각종 컴포넌트(시스템 구성요소)를 만듬
    - 이를 수행하여 아티팩트를 만들어 개발팀에 전달
    - 개발팀은 각 컴포넌트 클래스 다이어그램을 그린 뒤 UI 화면을 만들고 소스 코드를 개발/테스트
    - 문제점
        - 아키텍트와 개발자가 나누는 가상의 물리적 장벽을 통과하는 단방향 화살표 구조
        - 아키텍트가 내린 결정이 개발팀에 쓸모 없는 경우가 있는데도, 개발팀이 아키텍처를 변경하기로 한 결정이 아키텍트에게 전달될 수 없음
        - 아키텍트가 개발팀과 완전히 단절되어 있음
- 제대로 된 아키텍처를 만들려면 아키텍트와 개발자 두 팀이 양방향으로 소통하는 관계를 정립해야 함
- 아키텍트, 개발자 모두 활발히 소통하면서 아키텍트는 팀 내 개발를 멘토링/코치하는 역할도 수행할 수 있도록 가상의 동일한 팀에 소속되어야 함
- 폭포수 모델과 달리 요즘 시스템 아키텍트는 매 단계, 이터레이션마다 끊임없이 변화하고 발전하기 때문에 아키텍트와 개발팀이 똘똘 뭉쳐야 함
- 아키텍처와 설계의 경계는 따로 없음
- 아키텍처와 설계 모두 소프트웨어 프로젝트 생명주기의 일부로서 항상 서로 동기화되어야 성공할 수 있음
## 2.2 기술 폭
- 기술 세부의 범위 또한 개발자와 아키텍트가 다름
- 개발자 : 업부를 진행하기 위해 기술 깊이를 확보해야 함
- 아키텍트 : 사고하고 아키텍처 시각을 유지하기 위해 상당한 기술 폭을 갖춰야 함
- 지식의 종류
    - 내가 알고 있는 것
    - 내가 모른다는 사실을 아는 것
    - 내가 모른다는 사실조차 모르는 것
- 내가 알고 있는 것
    - 일상 업무 수행에 사용하는 기술, 도구, 프레임워크, 언어
- 내가 모른다는 사실을 아는 것
    - 한 번 들어 봤거나 얕은 지식은 갖고 있지만 경험은 전무한 기술
- 내가 모른다는 사실조차 모르는 것
    - 지식 피라미드에서 가장 많은 부분을 차지
    - 기술자가 해결하려는 문제에 완벽한 정답임에도 불구, 그 존재조차 알지 못하는 다수의 기술, 도구, 프레임워크, 언어
- 초심자 시절에는 이 피라미드 꼭대기를 점점 넓혀 경험과 전문성을 쌓는 데 주력
- 점점 중간 영역도 넓어지고 관련 기술과 아티팩트를 더 많이 접하면서, '내가 모른다는 사실을 아는 것'이 점점 늘어남
- '내가 알고 있는 것' == '내가 유지해야 할 것'
    - 시간을 들여 전문성을 유지해야 함
    - 꼭대기의 크기가 그 사람의 기술 깊이
- 아키텍트로 진로를 바꾸면 지식의 성격이 달라짐
- 아키텍트는 한 가지 문제만 해결 가능한 한 가지 전문 지식보다는, 문제를 해결할 수 있는 여러가지 솔루션을 알고 있는게 더 중요
- 아키텍트에게 중요한 영역은 꼭대기와 중간
- 아키텍트의 기술 폭은 중간 영역이 아래 영역을 얼마나 더 멀리 관통하는가
- 아키텍트에게는 깊이보다 폭이 더 중요
- 개발자가 아키텍트로 전환하려면 관점을 바꾸어야 하는데, 많은 사람들이 이것을 어려워하고, 두 가지 역효과가 일어남
    - 다양한 분야에서 전문성을 유지하려고 하나, 어느 하나도 성공하지 못한 채 그러는 도중 지쳐버림
    - 김빠진 전문성이 나타남, 자신의 낡은 정보가 아직도 첨단을 달리고 있는 것처럼 그릇된 인식에 사로잡히게 됨
- 깊이와 폭 사이에서 지식 포트폴리오의 균형을 맞추는 일은 모든 개발자 커리어 내내 고민해야 할 문제
## 2.3 트레이드오프 분석
- 아키텍트처럼 생각하는 것은 기술 여부와 상관없이 모든 솔루션의 트레이드오프를 분석하여 최선의 솔루션을 결정하는 것
- 아키텍처는 구글링해도 안되는 것이다
- 아키텍처는 모든 게 다 트레이드오프
- 배포환경, 비즈니스 동인, 회사 문화, 예산, 기간, 개발자 스킬 세트 등 여러 팩터들이 영향을 미침
- 저마다 다른 환경, 상황, 문제를 안고 있어서 어려움
    - 아키텍처는 정답도, 오답도 없다. 오직 트레이드오프만 있을 뿐
- ex : 토픽을 사용한 메시지 발행/구독 모델 vs 큐를 사용한 점대점 메시징 모델
    - 토픽을 사용한 메시지 발행/구독 모델
        - 아키텍처 신장성이 확실한 강점
        - producer 서비스가 한 토픽에 한 번만 연결하면 됨
        - 새로운 서비스가 도입되더라도 기존 서비스는 전혀 고칠 필요가 없는 구조
        - 커플링이 덜 되는 구조 (producer가 발행한 정보를 어떤 서비스가 사용하는지 모름)
    - 큐를 사용한 점대점 메시징 모델
        - producer 서비스가 세 큐에 접속해야 함
        - 새로운 서비스가 도입되려면 producer 서비스 변경 불가피
        - 커플링이 더 되는 구조 (producer가 발행한 정보를 어떤 서비스가 사용하는지 알아야 함)
- 메세지 발행/구독 모델에 따라 토픽을 사용하는 것이 최적의 선택으로 보임
    - 프로그래머는 장점은 잘 알지만 트레이드오프는 하나도 모른다. 아키텍트는 둘 다 잘 알아야 한다
    - 토픽을 사용한 메시지 발행/구독 모델
        - 누구나 입찰 데이터에 엑세스 할 수 있으므로 보안 문제가 불거질 수 있음
        - 데이터를 수신한 서비스는 모드 동일한 데이터 세트를 받아야 함
        - 메세지 개수를 모니터링할 수 없음
        - 자동확장 기능이 지원되지 않음
    - 큐를 사용한 점대점 메시징 모델
        - 지정된 컨슈머만 액세스 가능함
        - 필요한 데이터에만 받을 수 있음
        - 큐를 따로 모니터링 할 수 있음
        - 개별적으로 로드밸런싱 로직을 적용할 수 있기 때문에 상호 독립적인 자동 확장이 가능함
    - 트레이드오프를 분석했을 때 어느 쪽이 더 나은가는 경우에 따라 다름
- 소프트웨어는 만사가 트레이드오프를 갖고 있음
- 이를 분석하고, 여러 솔루션 중 택일하는 것은 언제나 비즈니스 동인, 환경 등 다양한 팩터에 좌우됨
## 2.4 비즈니스 동인의 이해
- 아키텍처 사고는 성공적인 시스템 구축에 필요한 비즈니스 동인을 이해하고 요구사항을 (확장성, 성능 가용성 등의) 아키텍처 특성으로 해석하는 것
- 아키텍트는 비즈니스 도메인 지식을 갖고서 비즈니스 핵심 인사들과 원만하고 협력적인 관계를 유지해야 함
## 2.5 아키텍처와 코딩 실무 간 균형 맞추기
- 코딩 실무와 소프트웨어 아키텍처의 균형을 맞추는 것도 아키텍트가 극복해야 할 어려운 일 중 하나
- 모든 아키텍트가 코딩을 하면서 어느 정도의 기술 깊이는 유지해야 함
- 코딩 실무와 아키텍처의 균형을 맞추는 팁, 병목 트랩에 빠지지 말라
    - 병목트랩은 아키텍트가 프로젝트의 크리티컬 패스(임계 경로, 최장 경로)에 있는 코드의 소유권을 가지고 있는 경우 발생
    - 아키텍트는 풀타임 개발자가 아니므로, 개발자 역할과 아키텍트 역할의 균형을 잘 맞춰야 함
    - 크리티컬 패스와 프레임워크 코드는 다른 개발팀 사람에게 넘기고
    - 비즈니스 기능을 코딩하는 작업에 집중해서 1~3회 이터레이션 수행
    - 세 가지 측면에서 긍적적 효과
        - 아키텍트는 더 이상 팀의 병목점이 되지 않고 프로덕션 코드를 실제로 작성하는 실무 경험
        - 크리티컬 패스와 프레임워크 코드를 개발팀에 분산시키고 소유권을 부여함으로써 시스템에서 가장 어려운 부분을 더 잘 이해
        - 아키텍트가 개발팀에서 작업중인 비즈니스 연관 코드를 직접 작성함으로써 개발자들이프로세스, 절차, 개발환경 어느 부분에서 가장 큰 고통을 겪고 있는지 몸소 체험 가능
- 아키텍트가 개발팀과 함께 코드를 개발할 수 없는 상황에서 코딩 실무 능력을 잃지 않고 일정 수준의 기술 깊이를 유지하는 방법
    - 개념증명(Proof Of Concept)을 자주 해보는 것
        - POC는 아키텍트가 소스코드를 직접 작성해보면서 구현 상세를 생각하게 되므로 아키텍처 결정을 검증하는데 유용
        - POC 작업을 할 때에는 가능한 한 프로덕션 수준의 고품질 코드를 작성하는 것이 좋음
            - 아키텍트가 쓰고 버리려고 작성한 POC 코드가 소스 코드 리포지터리에 커밋되면 외려 이것이 레퍼런스 아키텍처가 되거나 좋은 샘플이 되는 경우가 많음
            - 아키텍트는 프로덕션 품질의 POC 코드를 작성해보면서 나쁜 코딩 습관이 점점 더 손에 배기 전에 잘 짜인 양질의 코드를 작성하는 습관을 들이게 됨
    - 개발팀이 아주 중요한 유저 스토리 작업을 할 수 있도록 기술 부채 스토리나 아키텍처 스토리에 전념하는 것
        - 우선순위가 낮음
        - 이터레이션 성공에도 영향을 미치지 않음
    - 이터레이션을 하면서 버그를 잡는 일
        - 코드베이스 또는 더 나아가 아키텍처에 존재하는 이슈나 약점을 발견할 수 있음
    - 커맨드라인 도구나 분석기를 만들어 개발팀의 일상 업무를 간소화, 자동화 하는 것
        - 자동 소스 검증기
        - 다른 린트 검사
        - 자동 체크리스트
        - 반복적인 수동 코드 리팩터링
    - 아키텍처의 컴플라이언스 보장을 자동화하기 위해 피트니스 함수를 사용
    - 자주 코드리뷰를 하는 방법

        

