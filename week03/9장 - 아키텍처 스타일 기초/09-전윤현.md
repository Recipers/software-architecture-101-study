- 아키텍처 스타일은 각 명칭마다 상당히 많은 세부 내용이 함축되어 있다. 또 토폴로지와 기본 전제된 아키텍처 특성을 이로운 것과 해로운 것 모두 기술한다
# 9.1 기초 패턴
### 9.1.1 진흙 잡탕
- 뭐 하나 뚜렷한 아키텍처 구조가 전무한 상태를 표현한다.
- 실제 내부 구조라 할만한 것은 하나도 없는, 데이터베이스를 직접 호출하는 이벤트 핸들러를 가진 단순한 스크립팅 애플리케이션을 가리킨다.
- 무슨 수를 써서라도 이런 아키텍처를 피하려고 한다. 구조가 없으면 앞으로 뭔가 변경하기 점점 더 어려워지고 배포, 테스트, 확장, 성능 역시 고통스럽다.
- 이 안티패턴은 실제로 아주 흔히 발생한다. 많은 프로젝트가 코드 품질 및 구조에 관한 거버넌스가 결여된 탓에 본의아니게 그렇게 된다.
### 9.1.2 유니터리 아키텍처
- 소프트웨어 태동기에는 1대의 컴퓨터에서 모든 소프트웨어가 돌아갔다. 이후 다양한 진화 세대를 거치면서 점점 더 나뉘어졌다. 메인프레임 컴퓨터는 원래 단일 시스템이였지만 갈수록 고유한 시스템으로 분리되었다.
- 그러므로 유니터리(단일, 통일) 시스템은 임베디드 시스템과 매우 제약이 많은 극소수 환경을 제외하면 거의 쓰이지 않는다
### 9.1.3 클라이언트/서버
- 단일 시스템에서 여러 기능을 분리할 필요성이 대두되었다. 그 분리 방법은 많은 아키텍처 스타일의 기초가 되었다. 실제로 대부분의 아키텍처 스타일은 시스템에 있는 여러 부분을 효과적으로 분리하는 방법을 다룬다
- 프런트엔드와 백엔드를 기술적으로 기능을 분리한 2티어 또는 클라이언트/서버 아키텍처는 대표적인 기본 아키텍처 스타일이다.
- **데스크톱 + 데이터베이스 서버**
	- 초창기 PC 아키텍처는 윈도우 같은 UI를 기반으로 리치 데스크톱 애플리케이션을 개발하도록 지원했다.데이터는 별도의 서버로 분리했다.
	- 이 아키텍처는 표준 네트워크 프로토콜을 통해 접속 가능한 스탠드 얼론 DB 서버와 잘 맞았다.
	- 프레젠테이션 로직은 데스크톱에 두고 계산량이 많은 액션은 사양이 탄탄한 DB에서 실행했다.
- **브라우저 + 웹 서버**
	- 웹 브라우저가 웹 서버에 접속하는(그리고 웹 서버는 다시 데이터베이스 서버에 접속하는) 형태로 분리하는 것이 일반화됐다.
	- 클라이언트는 데스크톱보다 훨씬 가벼운 브라우저로 대체되었고 방화벽 모두 더 넓은 범위로 배포가 가능해졌다.
	- DB와 웹 서버는 분리되었지만 두 서버 모두 데이터센터 내부의 동급 머신에서 운용되고 UI는 브라우저에서 실행되고 있으므로 여전히 2티어로 바라보는 아키텍트들도 있다
- **3티어**
	- 고성능 DB를 사용하는 데이터베이스 티어, 애플리케이션 서버가 관리하는 애플리케이션 티어, 프런트엔드 티어, 이렇게 분리하는 아키텍처이다
# 9.2 모놀리식 대 분산 아키텍처
- 아키텍처 스타일은 크게 (전체 코드를 단일 단위로 배포하는) 모놀리식과 (원격 액세스 프로토콜을 통해 여러 단위로 배포하는) 분산형, 두 종류이다.
- **모놀리식**
	- 레이어드 아키텍처
	- 파이프라인 아키텍처
	- 마이크로커널 아키텍처
- **분산형**
	- 서비스 기반 아키텍처
	- 이벤트 기반 아키텍처
	- 공간 기반 아키텍처
	- 서비스 지향 아키텍처
	- 마이크로서비스 아키텍처
- 분산 아키텍처 스타일을 모놀리식 아키텍처 스타일에 비해 성능, 확장성, 가용성 측면에서 훨씬 강력하지만 무시할 수 없는 트레이드오프가 수반된다.
### 9.2.1 오류 #1: 네트워크는 믿을 수 있다
- 개발자, 아키텍트 모두 네트워크는 믿을 수 있다고 전제하지만 실제로는 전혀 그렇지 않다. 분산 아키텍처는 그 특성상 서비스간 이동하는 네트워크에 의존하므로 매우 중요한 문제이다.
	- 타임 아웃같은 장치를 마련하거나, 서비스 사이에 회로 차단기(서킷 브레이커)를 괜히 두는게 아니다.
	- 시스템이 네트워크에 더 의존할수록 시스템의 신뢰도는 잠재적으로 떨어질 가능성이 있다.
### 9.2.2 오류 #2: 레이턴시는 0이다
- 로컬 인메모리 메서드의 호출 오버헤드는 무시할 정도로 작지만, 네트워크로 인한 호출은 그렇지 않다.
- 어떤 분산 아키텍처를 구축하든지 간에 평균 레이턴시는 반드시 알아야한다. 특히 마이크로서비스는 서비스가 잘게 나뉘기 때문에 서비스간 통신량이 만만치 않다.
	- 평균 레이턴시도 중요하지만 95~99번째 백분위수를 이해하는 것이 더 중요하다. 평균 레이턴시가 60밀리초에 불과해도 95 백분위수는 400밀리초일 수 있다. 보통 이런 긴 꼬리 레이턴시가 분산 아키텍처의 성능을 저해하는 주범이 된다.
### 9.2.3 오류 #3: 대역폭은 무한하다
- 모놀리식은 비즈니스 요청을 처리하는 데 그리 큰 대역폭이 필요하지 않다. 하지만 마이크로서비스 분산 아키텍처처럼 시스템이 자잘한 배포 단위로 쪼개지면 서비스들 간에 주고받는 통신이 대역폭을 상당히 점유하여 네트워크가 느려지고, 결국 레이턴시와 신뢰성에도 영향을 미친다.
- 필요한 데이터는 극히 일부분인데, 전체 데이터를 전부 요청해야 되는 커플링(필요한 데이터는 200kb이지만 전체 응답 데이터는 500kb)을 스탬프 커플링이라고 한다.
	- 일반적인 해결 전략
		- 프라이빗 REST API 엔드포인트를 둔다
		- 계약에 필드 셀렉터를 사용한다
		- GraphQL로 계약을 분리한다
		- 컨슈머 주도 계약과 값 주도 계약을 병용한다
		- 내부 메시징 엔드포인트를 사용한다
	- 어떤 기법을 적용하던, 분산 아키텍처의 서비스 또는 시스템 간의 최소한의 데이터만 주고받도록 하는 것이 이 오류를 바로잡는 최선의 길이다.
### 9.2.4 오류 #4: 네트워크는 안전하다
- VPN, 신뢰할 수 있는 네트워크, 방화벽에 너무 익숙해진 나머지 네트워크가 안전하지 않다는 사실을 망각하는 경향이 있다.
- 보안은 분산 아키텍처에서 훨씬 더 어려운 문제이다. 분산 배포된 각 엔드포인트는 알려지지 않은, 또는 악의적인 요청이 해당 서비스로 유입되지 않게 철저한 보안 대책을 강구해야 된다
- 모놀리식에서 분산 아키텍처로 옮겨가면서 더 넓은 영역이 악의적인 외부인의 위협과 공격에 노출된다.
- 모든 엔드포인트에, 서비스 간 통신에도 보안이 적용돼야 하므로 고도로 분산된 동기 아키텍처에서(마이크로서비스, 서비스 기반 아키텍처)는 당연히 성능이 떨어질 수 밖에 없다
### 9.2.5 오류 #5: 토폴로지는 절대 안 바뀐다
- 네트워크를 구성하는 라우터, 허브, 스위치, 방화벽, 네트워크 어플라이언스 등 전체 네트워크 토폴리지는 불변이 아니다.
- 소소한 네트워크 업그레이드가 서비스에 자꾸 타임아웃을 일으키는 주범이 될 수 있다
- 아키텍트는 운영자, 네트워크 관리자와 항시 소통을 하면서 무엇이, 언제 변경되는지 알고있어야 한다. 그래야 당황스러운 사태가 발생해도 적절히 대응할 수 있다
### 9.2.6 오류 #6: 관리자는 한 사람뿐이다
- 대기업에서 일하는 네트워크 관리자는 보통 수십 명에 이른다. 그래서 분산 아키텍처는 복잡할 수 밖에 없고 모든 것을 정상 궤도에 올려놓으려면 상당히 많은 조율 과정이 불가피하다. 모놀리식 애플리케이션은 단일 단위로 배포하기 때문에 소통과 협력이 상대적으로 간편하다
### 9.2.7 오류 #7: 운송비는 0이다
- 운송비는 레이턴시가 아니라 '단순한 REST 호출'을 하는데 소요되는 진짜 비용(돈?)을 말한다.
	- 분산 아키텍처는 하드웨어, 서버, 게이트웨이, 방화벽, 신규 서브넷, 프록시 등 리소스가 더 많이 동원되므로 모놀리식 아키텍처보다 비용이 훨씬 더 든다
### 9.2.8 오류 #8: 네트워크는 균일하다
- 많은 회사의 인프라는 여러 업체의 네트워크 하드웨어 제품들이 얽히고 설켜있다.
- 대부분 그럭저럭 잘 작동되지 몰라도 다른 회사의 제품끼리 딱 맞물려 작동되지 않을 가능성이 있다.
	- 실제로 간혹 네트워크 패킷이 유실되는 사고도 심심찮게 일어난다. 네트워크 신뢰성, 레이턴시, 대역폭도 차례로 영항을 받는다. 이로인해 네트워크에 대한 끝없는 혼란과 당혹스러움을 시사한다.
### 9.2.9 다른 분산 아키텍처 고려사항
- **분산 로깅**
	- 분산 아키텍처는 애플리케이션과 시스템 로그가 분산되어 있으므로 어떤 데이터가 누락된 근본 원인을 밝혀내기가 대단히 어렵다. 반면 모놀리식 애플리케이션은 로그가 하나 밖에 없어서 비교적 수월하다
	- 스플렁크같은 로깅 통합 도구를 사용하면 비교적 수월해지지만 복잡하기 그지없는 분산 로그를 확인하기에는 역부족이다.
- **분산 트랜잭션**
	- 모놀리식 아키텍처는 직관적이고 관리가 편한 트랜잭션을 기반으로 한다. ACID 트랜잭션을 걸어 업데이트 시 일관성과 무결성을 강제한다.
	- 분산 아키텍처는 최종 일관성이라는 개념을 바탕으로 별도로 분리된 배포 단위에서 처리된 데이터를 미리 알 수 없는 어느 시점에 모두 일관된 상태로 동기화한다. 확장성, 성능, 가용성을 얻는 대가로 데이터 일관성과 무결성을 희생하는 트레이드오프이다.
	- 분산 트랜잭션을 관리하는 한 가지 방법으로 트랜잭셔널 사가가 있다. 보상을 위해 이벤트를 소싱하거나 트랜잭션 상태를 관리하기 위해 유한 상태 기계를 활용한다.
		- 사가 외에 BASE 트랜잭션도 사용한다. BASE는 (BA)sic availability (기본가용성), (S)oft state (소프트 상태), (E)ventually consistency (최종 일관성)의 약자이다. 
			- 소프트 상태는 소스 -> 타깃으로의 데이터 전달과 데이터 소스 간 비일관성을 말한다.
			- 시스템 또는 서비스의 기본 가용성에 따라 시스템은 아키텍처 패턴과 메시징을 사용하여 결국 언젠가 일관되게 맞춰질 것이다
- **계약 관리 및 버저닝**
	- 계약 생성, 유지보수, 버저닝 역시 분산 아키텍처에서 다소 까다롭다. 계약은 클라이언트와 서비스 모두 합의한 행위와 데이터이다. 분산 아키텍처에서는 분리된 서비스와 시스템을 제각기 다른 팀과 부서가 소유하기 때문에 계약 유지보수가 특히 어렵다. 버전 구식화(deprecation)에 필요한 통신 모델은 더 더욱 복잡하다
