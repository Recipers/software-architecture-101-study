- 3장에서 모듈을 연관된 코드의 묶음이라고 했지만, 아키텍트는 보통 모듈을 물리적으로 구현한 컴포넌트로 생각한다.
- 개발자는 자신의 개발 플랫폼에 따라 여러 가지 방법으로 모듈을 물리적으로 패키징한다. 이렇게 물리적으로 패키징한 것을 컴포넌트라고 하며, 자바 jar, 닷넷 dll, 루비 gem 파일처럼 대부분의 언어는 패키징을 지원한다.
# 8.1 컴포넌트 범위
- 컴포넌트는 아티팩트를 한데 묶어 필요시 중첩시켜 계층화하는, 언어에 특정한 메커니즘을 제공한다. 가장 단순한 컴포넌트는 클래스보다 한 단계 높은 수준의 모듈로 코드를 래핑한 것이다. 이 단순한 래퍼를 보통 라이브러리라고 한다. 라이브러리는 대개 호출부 코드와 동일한 메모리 주소에서 실행되며 해당 언어의 함수 호출 메커니즘을 이용해 통신한다. 그리고 일반적으로 컴파일 타임에 의존한다.
- 컴포넌트는 아키텍처에서 서브시스템이나 레이어 형태로도 나타나며 많은 이벤트 프로세서를 위한 배포 가능한 작업 단위이다. 서비스는 또 다른 종류의 컴포넌트로써 자신의 주소 공간에서 실행되며 TCP/IP 같은 저수준 네트워크 프로토콜이나, REST, 메시지 큐 같은 고수준 포맷을 통해 통신한다. 마이크로서비스 같은 아키텍처에서 서비스는 배포 가능한 독립적인 단위를 형성한다.
- 아키텍트가 반드시 컴포넌트를 사용해야 하는 것은 아니다. 컴포넌트는 언어가 제공하는 저수준이 아닌 더 높은 수준에서 모듈성을 가지는 것이 더 유용할 때가 많다. 마이크로서비스 아키텍처에서 단순성은 아키텍처 원칙 중 하나이므로 서비스는 컴포넌트가 될 정도의 충분한 코드로 구성하거나, 적은 양의 코드만 담도록 단순하게 설계하는 것이 좋다.
- 컴포넌트는 아키텍처의 근본적인 모듈성을 구성하는 요소로써 아키텍트에게 매우 중요한 고려사항이다.
# 8.2 아키텍트 역할
- 아키텍트는 아키텍처 내부의 컴포넌트를 정의, 개선, 관리, 통제하는 일을 한다. 또한 4장에서 열거한 아키텍처 특성과 소프트웨어 시스템의 요구사항을 종합하여 각 이해관계자들과 함께 소프트웨어 초기 설계를 한다.
- 이 책에서 다루는 아키텍처는 개발 프로세스의 영향을 받지 않는다. 첫 번째 예외는 애자일 프로세스 개발 방법론의 다양한 분야를 개척한 엔지니어링 프랙티스를 필요로 하는데, 특히 배포 및 자동화 거버넌스 분야가 그렇다. 하지만 소프트웨어 아키텍처는 일반적으로 개발 프로세스와 분리되어 있다.
- 일반적으로 컴포넌트는 아키텍트가 직접 맞닥뜨리는 최하위 소프트웨어 시스템지만 전체 코드베이스에 영향을 미치는 코드 품질 메트릭은 예외이다. 컴포넌트는 클래스나 함수로 구성되며 설계하는 업무는 기술 리더나 개발자가 담당한다. 아키텍트는 클래스 설계에 참여해서도 안되고 세세한 설계 결정에 관여해서도 안된다.
- 새 프로젝트를 시작한 아키텍트는 가장 먼저 컴포넌트를 식별해야 하나, 그 전에 아키텍처를 분할하는 방법을 반드시 이해해야 한다
### 8.2.1 아키텍처 분할
- 소프트웨어는 만사가 다 트레이드오프이다. 아키텍처에서 컴포넌트를 만드는 방법도 마찬가지이다. 레이어드 아키텍처와 모듈러 모놀리스가 있다고 생각할 때 이 두 가지 스타일은 서로 다른 방법으로 아키텍처를 최상위 분할한 결과이다. 각 최상위 컴포넌트 내부에는 다른 컴포넌트들이 내장되어 있다. 최상위 분할은 근본적인 아키텍처 스타일과 코드 분할 방법을 결정짓기 때문에 아키텍트에게 중요하다.
- 기술적 최상위 분할은 레이어드 아키텍처와 같이 기술적인 능력에 따라 아키텍처를 구성하는 것이다. 시스템 기능을 기술적인 능력, 즉 프레젠테이션, 비즈니스 규칙, 서비스, 퍼시스턴스등으로 분할했다. 이러한 개념은 개발자가 이해하기 쉬워서 수많은 조직에서 기본 아키텍처로 자리잡았다.
- 반면 도메인 관점으로 분할하는 방법도 있다. 복잡한 소프트웨어 시스템을 분리하는 모델링 기법을 다룬 에릭 에반스의 '도메인 주도 설계'에서 비롯됐다. DDD에서는 아키텍트는 서로 독립적으로 분리된 도메인 또는 워크플로를 식별한다. 이는 마이크로서비스 아키텍처 스타일의 근본 사상이기도 하다. 모듈러 모놀리스를 설계하는 아키텍트는 기술적 능력 대신 도메인이나 워크플로에 따라 아키텍처를 분할한다.
- 아키텍트가 초기에 어떻게 컴포넌트를 식별해야 할지 결정할 때에도(컴포넌트를 기술적으로 분할할 것인가, 도메인 단위로 분할할 것인가?)이 최상위 분할 유형이 매우 큰 영향을 미친다.
- 기술적으로 분할한다면 기술 관심사의 분리를 도입하여 유용한 수준의 디커플링을 만든다. 이런 방식으로 분할하면 의존하는 컴포넌트에 부수효과가 전파되지 않도록 할 수 있다.
- 기술적으로 분할한다면 코드베이스가 기능별로 구성되므로 코드베이스에서 특정 카테고리를 신속하게 찾을 수 있지만 현실적으로 대부분의 소프트웨어 시스템은 여러 기술/기능을 넘나드는 워크플로를 필요로 한다. 예를 들어 CatalogCheckout처럼 흔한 비즈니스 워크플로도 기술적인 레이어드 아키텍처에서 CatalogCheckout을 처리하는 코드는 모든 레이어에 흩어져 있다. 반면 도메인 분할 아키텍처에서는 워크플로 및(또는) 도메인 중심으로 최상위 컴포넌트를 구축한다. 도메인에 초첨을 두는 까닭에 프로젝트에서 가장 자주 발생하는 변경의 유형들이 더 확실하게 반영된다.
- 두 스타일 모두 어느 것이 낫다고 단정할 수 없다. 어쨌든 최상위 분할을 어떻게 할 것인지는 아키텍트가 가장 먼저 결정해야 할 문제 중 하나이다.
### 8.2.2 분할 사례 연구: 실리콘 샌드위치
- 컴포넌트 도출 시 아키텍트는 기본적으로 최상위 분할을 어떻게 할지 결정해야 한다 (기술적 분할 vs. 도메인 분할)
- 어떤 설계가 더 나은지는 당연히 경우에 따라 다르다. 각 방식마다 일장일단이 있다.
- **도메인 분할**
	- 장점
		- 세부 구현보다 비즈니스 기능에 더 가깝게 모델링된다
		- 역 콘웨이 전략을 활용하여 도메인별 다목적팀을 구성하기 쉽다
		- 모듈러 모놀리스와 마이크로서비스 아키텍처 스타일에 더 가깝게 맞출 수 있다
		- 메시지 흐름이 문제 영역과 일치한다
		- 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉽다
	- 단점
		- 유저 정의 코드가 여기저기 널려 있다.
- **기술 분할**
	- 최상위 컴포넌트를 개별 워크플로가 아닌, 기술적인 능력에 따라 분리하므로 MVC 또는 상황에 맞게 기술 분할된 레이어로 나타낼 수 있다
	- 장점
		- 커스텀 코드가 명화갛게 분리된다
		- 레이어드 아키텍처 패턴에 더 가깝게 맞출 수 있다
	- 단점
		- 전역 커플링이 더 높다. 따라서 공통 또는 로컬 컴포넌트 중 하나라도 변경되면 다른 모든 컴포넌트가 영향을 받을 가능성이 높다
		- 개발자가 공통 레이어, 로컬 레이어 양쪽에 도메인 개념을 복제해야 할 수도 있다
		- 일반적으로 데이터 레벨의 커플링이 높다. 이런 시스템은 대개 에플리케이션 아키텍트, 데이터 아키텍트가 서로 협력하여 단일 데이터베이스를 구성하고 여기에 각종 도메인을 포함시키기 때문에 나중에 아키텍트가 분산 시스템 아키텍처로 옮기려고 할 경우 데이터 관계를 파헤치는 작업이 어렵다
# 8.3 개발자 역할
- 개발자는 아키텍트와 공동 설계한 컴포넌트를 바탕으로 클래스, 함수, 서브컴포넌트로 더 잘게 나눈다
- 개발자는 아키텍트가 설계한 컴포넌트가 최종판이라고 생각하면 안된다. 설계는 이터레이션을 거쳐 다듬어진다
# 8.4 컴포넌트 식별 흐름
- 컴포넌트 식별은 후보를 도출하고 피드백을 통해 다듬어가는 과정을 반복하는 것이 가장 좋다
- 아키텍처는 주기를 반복하면서 구체화된다. 도메인에 따라서 주기에 단계가 추가되거나 전체적으로 변경되는 경우도 있다
### 8.4.1 초기 컴포넌트 식별
- 아키텍트는 소프트웨어 프로젝트의 소스 코드가 생기기 전에 적용할 최상위 분할의 유형에 따라 최상위 컴포넌트를 어디서부터 시작할지 결정해야 된다 그 밖에도 어느 기능을 어디에 둘지 도메인 기능을 매핑한다.
### 8.4.2 요구사항을 컴포넌트에 할당
- 초기 컴포넌트를 식별한 후 아키텍트는 컴포넌트에 요구사항(또는 유저스토리)을 대입하여 잘 맞느지 확인한다. 컴포넌트를 새로만들거나 기존 컴포넌트를 통합할 수도 있다. 매핑이 정확할 필요는 없다. 계속 보완할 수 있는 큼지막한 단위의 기반을 찾으려고 노력하면 된다
### 8.4.3 역할 및 책임 분석
- 컴포넌트에 스토리를 대입할 때 아키텍트는 요구사항을 파악하는 단계에서 밝혀진 역할과 책임도 살펴보고 세분도가(얼마나 잘게 나누었는가) 적합한지 확인한다. 지원할 역할과 기능 둘 다 고려해야 컴포넌트와 도메인의 세분도를 서로 맞출 수 있다. 아키텍트가 하는 가장 어려운 일 중 하나이므로 이터레이션 과정이 필요하다.
### 8.4.4 아키텍처 특성 분석
- 컴포넌트에 요구사항을 대입할 때 앞서 식별한 아키텍처 특성들이 컴포넌트 분할 및 세분도에 어떤 영향을 미치는지 살펴봐야 한다. 유저 입력을 처리하는 시스템 파트는 동시 접속 유저가 수백명에 달하는 파트와 소수의 유저만 접속하는 파트의 아키텍처 특성은 다를 수 밖에 없다.
### 8.4.5 컴포넌트 재구성
- 소프트웨어 설계에서 피드백은 항상 중요하다. 아키텍트는 개발자들과 함께 지속적으로 컴포넌트 설계를 반복해야 한다. 설계를 하다보면 온갖 종류의 난관에 봉착하기 때문이다. 따라서 컴포넌트 설계를 반복하는 접근 방식은 정말 중요하다.
	- 차후 재설계를 하게 만들지 모를 모든 발견과 특이 사례를 한 번에 고려하기란 불가능하다
	- 아키텍처와 개발자가 애플리케이션 구축에 점점 더 깊이 빠질수록 서로의 기능과 역할을 어떻게 조정하면 좋을지 서로 다른 시각으로 바라보게 된다
# 8.5 컴포넌트 세분도
- 컴포넌트에서 가장 적당한 세분도를 찾는 것은 아키텍트의 가장 어려운 작업 중 하나이다. 너무 잘게 나누면 컴포넌트간 통신이 너무 많아지고, 너무 크게 나누면 내부적으로 커플링이 증가해서 배포, 테스트가 어려워지고 모듈성에 부정적인 영향을 미친다
# 8.6 컴포넌트 설계
- 컴포넌트 설계에 있어 '왕도'는 없다. 다양한 기술과 트레이드오프가 있겠지만, 아키텍처를 설계하면서 요구사항을 접수하고 애플리케이션을 구성할 굵직굵직한 구성 요소를 그려봐야 한다.
### 8.6.1 컴포넌트 발견
- 개발자, 비즈니스 분석가, 도메인 전문가와 협력하여 시스템에 관한 일반적인 지식과 시스템을 어떻게 분할할지(기술 분할 vs. 도메인 분할) 결정하고, 그에 따라 초기 컴포넌트를 설계한다. 이 때의 목표는 여러 아키텍처 특성을 고려하여 문제 영역을 큼직한 덩이들로 나누는 것이다.
- **엔티티 함정**
	- 요구사항에서 식별된 각각의 엔티티를 바탕으로 관리자 컴포넌트를 만드는 설계는 아키텍처가 아니다. 프레임워크를 데이터베이스에 컴포넌트 관계형으로 매핑한 것에 불과하다. 단순 CRUD 기능만 필요한 시스템은 아키텍트가 프레임워크를 내려 받아 데이터베이스에서 직접 UI를 생성할 수 있다.
	- 아키텍트가 데이터베이스 관계를 애플리케이션의 워크플로로 오해할 때 벌어진다. 실제로 이렇게 단순하게 대응되는 경우가 없다. 이 안티패턴은 애플리케이션의 실제 워크플로에 관한 지식이 부족할 때 나타난다. 이렇게 설계된 컴포넌트는 너무 큼직하기 때문에 지침이 될 만한 것이 하나도 없다.
- **액터/액션 접근법**
	- 애플리케이션에서 뭔가 일을 하는 액터와 그들이 수행하는 액션을 식별하고 시스템의 대표적인 유저와 이들이 시스템에서 어떤 종류의 일을 하는지 찾아내는 기법이다. 선행 설계를 매우 선호하는 공식 프로세스와 맞물려 인기를 얻었다. 이 방법은 요구사항 측면에서 역할을 분명하고 액션의 종류가 확실한 경우에 잘 작동하고 아직도 많이 쓰인다.
- **이벤트 스토밍**
	- DDD에서 사용되는 컴포넌트 발견 기법이다. 역시 DDD의 영향을 많이 받은 마이크로서비스와 더불어 널리 보급되었다. 다양한 컴포넌트가 메시지나 이벤트를 이용해 서로 통신한다고 가정한다. 따라서 요구사항과 식별된 역할에 따라 시스템에서 어떤 이벤트가 일어나는지 파악하고 컴포넌트를 이벤트와 메시지 핸들러 중심으로 구축한다. 최종 일관성 시스템에서 사용할 메시지를 아키텍트가 정의하는 데 도움이 되므로 이벤트와 메시지를 사용하는 마이크로서비스 같은 분산 아키텍처에서 주효하다.
- **워크플로 접근법**
	- 이벤트 스토밍의 대안으로서 DDD나 메시징을 사용하지 않는 더 일반화된 방법이다. 이벤트 스토밍과 비슷하지만 메시지 기반 시스템을 구축하는 데 있어서 명시적인 제약조건은 없다. 핵심 역할을 식별하고 이 역할이 관여하는 워크플로 유형을 결정하며 그렇게 식별된 활동에 따라 따라 컴포넌트를 구축한다.
# 8.7 컴포넌트 발굴 사례 연구: GGG
- 특별한 제약이 없고 범용적인 컴포넌트 분할을 고려하고 있다면 액터/액션 접근법이 괜찮은 솔루션이므로 이 사례 연구에 적용한다.
- 초기 액션 세트
	- Bidder: 라이브 동영상 스트림과 라이브 입찰 스트림을 보고 입찰을 한다
	- Auctioneer: 라이브 입찰을 시스템에 입력하고 온라인 입찰을 수신하여, 아이템을 팔린 것으로 표시한다
	- System: 경매를 시작하고, 결제를 처리하고, 입찰자 활동을 추적한다
- 식별한 컴포넌트
	- VideoStreamer: 유저에게 라이브 경매를 스트리밍한다
	- BidStreamer: 입찰이 발생하면 즉시 유저에게 스트리밍한다. VideoStreamer와 BidStreamer는 입찰자에게 읽기 전용 경매 뷰를 제공한다
	- BidCapture: 경매인, 입찰자 양쪽에서 입찰을 캡처한다
	- BidTracker: 입찰을 추적하는 기록 시스템 역할을 한다
	- AuctionSession: 경매 세션을 시작/종료한다. 입찰자가 경매를 끝내면 결제를 처리하고 그 결과를 입찰자에게 알려주는 등 후속 조치를 한다
	- Payment: 신용카드 결제를 처리하는 서드파티 결제 프로세서
- 먼저 컴포넌트를 초기 식별한 다음 그 컴포넌트 때문에 설계를 바꾸어야할지 결정하기 위해 아키텍처 특성을 분석한다. 입찰 캡처에 관한 아키텍처 특성에서 경매인은 수천명 단위로 증가할지 모를 입찰자와 동일한 수준의 확장성, 탄력성이 필요없다. 동일하게 경매인에 관한 신뢰성과 가용성 같은 아키텍처 특성을 다른 시스템 파트보다 높게 보장해야 한다.
- 필요한 아키텍처 특성의 수준이 제각각이므로 BidCapture를 BidCapture, AuctioneerCapture 두 컴포넌트를 나누는 것이 더 낫다
- 이것은 문제를 해결하는 한 가지의 사례일 뿐이다. 정답은 어차피 하나만 있는 것이 아니다. 모든 설계는 서로 다른 트레이드오프 조합이 반드시 뒤따른다. 그러므로 아키텍트는 하나의 진짜 설계를 발견하느라 집착해서는 안된다. 트레이드 오프를 객관적으로 판단하고 나쁜 것 중에서 제일 나은 것을 선택하려고 노력해야 한다
# 8.8 아키텍처 퀀텀 딜레마: 모놀리식이냐, 분산 아키텍처냐
- 초기 컴포넌트 설계를 마친 아키텍트는 중요한 결정(모놀리식 vs. 분산 아키텍처)해야 할 순간에 직면한다
- 모놀리식 아키텍처는 배포 단위가 하나 밖에 없으므로 단일 DB에 접속하여 실행되는 모든 시스템 기능이 포함된다. 분산 아키텍처는 정반대로, 자신의 체계를 갖추고 네트워킹 프로토콜을 통해 서로 통신하는 여러 서비스로 구성된다.
- 아키텍처 스타일은 저마다 다양한 트레이드오프가 있다. 하지만 근본적인 결정은 식별된 아키텍처 퀀텀 수에 좌우된다. 만약 시스템이 단일 퀀텀(즉, 한 세트의 아키텍처 특성)만으로 가능하면 모놀리스 아키텍처가 장점이 더 많다. 반면에 컴포넌트마다 아키텍처 특성이 달라지는 경우 분산 아키텍처가 적합하다.
