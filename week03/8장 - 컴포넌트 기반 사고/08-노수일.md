# 8. 컴포넌트 기반 사고
- 아키텍트는 보통 모듈을 물리적으로 구현한 컴포넌트로 생각함
- 모듈을 물리적으로 패키징한 것을 컴포넌트
    - 자바 jav, 닷넷 dll, 루비 gem 파일처럼 대부분의 언어는 패키징을 지원
## 8.1 컴포넌트 범위
- 개발자는 컴포넌트 개념을 다양한 팩터에 세분화하는 것이 유용하다고 생각함
- 컴포넌트는 아티팩트를 한데 묶어 필요시 중첩시켜 계층화하는, 언어에 특정한 메커니즘을 제공함
- 가장 단순한 컴포넌트는 클래스(함수)보다 한 단계 높은 수준의 모듈로 코드를 래핑한 것
    - 이 단순한 래퍼를 라이브러리라고 함
    - 라이브러리는 대개 호출부 코드와 동일한 메모리 주소에서 실행되며 해당 언어의 함수 호출 메커니즘을 이용해 통신
    - 라이브러리는 컴파일 타임에 의존함 (동적 링크 라이브러리 DLL은 전형적인 제외)
- 컴포넌트는 아키텍처에서 서브시스템이나 레이어 형태로도 나타남, 많은 이벤트 프로세서를 위한 배포 가능한 작업 단위
- 서비스는 또 다른 종류의 컴포넌트
    - 자신의 주소 공간에서 실행됨
    - TCP/IP 같은 저수준 네트워크 프로토콜이나 REST, 메세지 큐 같은 고수준 포맷을 통해 통신
    - 마이크로서비스 같은 아키텍처에서 서비스는 배포 가능한 독립적인 단위를 형성
- 아키텍트가 반드시 컴포넌트를 사용해야 하는 것은 아님
- 컴포넌트는 언어가 제공하는 저수준이 아닌, 더 높은 수준에서 모듈성을 가지는 것이 더 유용할 때가 많음
- 컴포넌트는 아키텍처의 근본적인 모듈성을 구성하는 요소로서 아키텍트에게 아주 중요한 고려 사항
## 8.2 아키텍트 역할
- 아키텍트는 아키텍처 내부의 컴포넌트를 정의, 개선, 관리, 통제하는 일을 함
- 아키텍처 특성과 소프트웨어 시스템의 요구사항을 종합하여 비즈니스 분석가, 분야별 전문가, 개발자, QA 엔지니어, 운영자, 엔터프라이즈 아키텍트와 함께 소프트웨어 초기 설계를 함
- 아키텍처는 개발 프로세스의 영향을 받지 않음
- 예외
    - 애자일 소프트웨어 개발 방법론의 다양한 분야를 개척한 엔지니어링 프랙티스를 필요로 함
        - 배포 및 자동화 거버넌스 분야가 그러함
        - 정규 결합 응용 설계 (JAD) 프로세스, 장황한 폭포수형 분석/설계, 애자일 스토리 카드, 그 빡에 이런 것들을 결합한 변형 등 요구사항의 출처에 대해서는 관심이 없음
    - 컴포넌트는 아키텍트가 직접 맞닥뜨리는 최하위 소프트웨어 시스템이지만, 코드베이스에 영향을 미치는 코드 품질 메트릭은 예외
        - 컴포넌트는 클래스나 함수로 구성됨, 이를 설계하는 업무는 기술 리더나 개발자가 담당
        - 아키텍트는 클래스 설계에 참여해서도 안 되고 시스템의 세세한 설계 결정에 관여해서도 안됨
### 8.2.1 아키텍처 분할
- 주어진 아키텍처에서 컴포넌트를 만드는 방법도 트레이드오프임
- 컴포넌트는 일반적인 적재 매커니즘을 의미함
- 최상위 분할 (레이어드, 모듈러)
    - 레이어드 아키텍처
    - 모듈러 모놀리스
        - 사이먼 브라운이 널리 보급한 아키텍처 스타일
        - 기술적인 능력이 아닌 도메인에 따라 분할된 단일 배포 단위
    - 각 최상위 컴포넌트 내부에는 다른 컴포넌트들이 내장되어 있음
    - 최상위 분할은 근본적인 아키텍처 스타일과 코드 분할 방법을 결정짓기 때문에 아키텍트에게는 특별한 관심사
- 기술적 취상위 분할은 레이어드 아키텍처와 같이 기술적인 능력에 따라 아키텍처를 구성하는 것
    - 레이어드 아키텍처
        - 시스템 기능을 기술적인 능력(프레젠테이션, 비즈니스 규칙, 서비스, 퍼시스턴스 등)으로 분할
        - 관련 코드를 쉽게 찾을 수 있음
        - 모델-뷰-컨트롤러 설계 패턴과 궁합이 잘 맞고 개발자가 이해하기 쉬워서 수많은 조직에서 기본 아키텍처로 자리잡음
    - 도메인 분할
        - 에릭 에반스의 **도메인 주도 설계(DDD)**에서 비롯됨
        - 아키텍트는 서로 독립적으로 분리된 도메인 또는 워크플로를 식별함, 마이크로서비스 아키텍처 스타일의 근본 사상
        - 도메인이나 워크플로에 따라 아키텍처를 분할
        - 도메인 분할 아키텍처에서 컴포넌트는 서로 중첩될 때가 많기 때문에 각 컴포넌트는 퍼시스턴스 라이브러리를 사용하거나, 별도의 레이어에 비즈니스 규칙을 둘 수도 있음
        - 어쨋든 최상위 분할은 도메인을 중심으로 전개됨
- 서로 다른 아키텍처 패턴 간의 근본적인 차이점 중의 하나가 바로 각각의 개별 패턴을 다루는 최상위 분할의 유형
- 기술적인 분할을 택한 아키텍트
    - 시스템 컴포넌트를 프레젠테이션, 비즈니스 규칙, 퍼시스턴스 등의 기술적 능력에 따라 구성함
    - 구성 원칙 중 하나는 기술 관심사의 분리
    - 유용한 수준의 디커플링을 만들어냄
    - 의존하는 컴포넌트에 부수 효과가 전파되지 않도록 막음
    - 개발자가 코드 베이스의 특정 카테고리를 신속하게 찾을 수 있지만, 현실적으로 대부분의 소프트웨어 시스템은 여러 기술/기능을 넘나드는 워크플로를 필요로 함
    - 레이어드 아키텍처에서 특정 도메인을 처리하는 코드는 모든 레이어에 흩어져 있음
    - 도메인 분할 아키텍처에서는 도메인 중심으로 최상위 컴포넌트를 구축함
    - 도메인 분할의 각 컴포넌트는 레이어를 포함한 서브 컴포넌트를 가질 수 있지만, 최상위 분할은 도메인에 초점을 두는 까닭에 프로젝트에서 가장 자주 발생하는 변경의 유형들이 더 확실하게 반영됨
- 어떤 것이 더 낫다고 단정지을 수 없음
### 8.2.2 분할 사례 연구: 실리콘 샌드위치
- 컴포넌트 도출 시 아키텍트는 기본적으로 최상위 분할을 어떻게 할지 결정해야 함
#### 도메인 분할
- 최상위 컴포넌트를 워크플로 및 도메인에 따라 나눔
- 장점
    - 세부 구현보다 비즈니스 기능에 더 가깝게 모델링됨
    - 역 콘웨이 전략을 활용하여 도메인별 다목적팀을 구성하기 쉬움
    - 모듈러 모놀리스와 마이크로서비스 아키텍처 스타일에 더 가깝게 맞출 수 있음
    - 메시지 흐름이 문제 영역과 일치함
    - 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉬움
- 단점
    - 유저 정의 코드가 여기저기 널려 있음
#### 기술 분할
- 최상위 컴포넌트를 기술적인 능력에 따라 분리함
- 모델-뷰-컨트롤러 또는 상황에 맞게 기술 분할된 레이어로 나타낼 수 있음
- 장점
    - 커스텀 코드가 명확하게 분리됨
    - 레이어드 아키텍처 패턴에 더 가깝게 맞출 수 있음
- 단점
    - 전역 커플링이 더 높음, 공통 또는 로컬 컴포넌트 중 하나라도 변경되면 다른 컴포넌트가 영향을 받을 가능성이 높음
    - 개발자가 공통 레이어, 로컬 레이어 양쪽에 도메인 개념을 복제해야 할 수도 있음
    - 일반적으로 데이터 레벨의 커플링이 높음
        - 애플리케이션 아키텍트, 데이터 아키텍트가 서로 협력하여 단일 데이터 베이스를 구성
        - 각종 도메인을 포함시키기 때문에, 나중에 분산 시스템으로 아키텍처를 옮기려고 할 경우 데이터 관계를 파헤치는 작업이 어려움
## 8.3 개발자 역할
- 개발자는 아키텍트와 공동 설계한 컴포넌트를 바탕으로 클래스, 함수, 서브컴포넌트로 더 잘게 나눔
- 일반적으로 클래스, 함수 설계는 아키텍트, 기술 리더, 개발자의 공동 책임이지만 대부분 개발자가 담당함
- 아키텍트가 설계한 초기 설계는 일단 초안으로 보고 차후 구현을 하며 하나씩 개선
## 8.4 컴포넌트 식별 흐름
- 컴포넌트 식별은 후보를 도출하고 피드백을 통해 다듬어가는 과정을 반복하는 것이 가장 좋음
- 컴포넌트 식별 주기
    1. 초기 컴포넌트 식별
    2. 요구사항을 컴포넌트에 할당
    3. 역할 및 책임 분석
    4. 아키텍처 특성 분석
    5. 컴포넌트 재구성, 3번으로 다시 돌아감
### 8.4.1 초기 컴포넌트 식별
- 프로젝트의 소스 코드가 생기기 전에 적용할 최상위 분할의 유형에 따라 최상위 컴포넌트를 어디서부터 시작할 지 결정해야 함
- 컴포넌트를 자유롭게 구성하면서 어느 기능을 어디에 둘지 도메인 기능을 매핑함
- 초기 컴포넌트 설계는 제대로 될리 없으므로 이터레이션하면서 조금씩 개선
### 8.4.2 요구사항을 컴포넌트에 할당
- 컴포넌트에 요구사항(또는 유저 스토리)을 대입해서 잘 맞는지 확인
- 이 과정에서 컴포넌트를 새로 만들거나 기존 컴포넌트를 통합하고, 하는 일이 많은 컴포넌트는 분해할 수 있음
- 매핑이 정확할 필요는 없음
### 8.4.3 역할 및 책임 분석
- 컴포넌트에 스토리를 대입할 때 요구사항을 파악하는 단계에서 밝혀진 역할과 책임도 살펴보고 세분도가 적합한지 확인
- 애플리케이션이 지원해야 할 역할과 기능 둘 다 고려해야 컴포넌트와 도메인의 세분도를 서로 맞출 수 있음
- 컴포넌트의 세분도를 정확히 짚어내는 것이 어려운 일 중 하나
### 8.4.4 아키텍처 특성 분석
- 컴포넌트에 요구사항을 대입 할 때, 아키텍처 특성들이 컴포넌트 분할 및 세분도에 어떤 영향을 미치는지 살펴봐야 함
- 순수하게 기능적인 관점에서만 컴포넌트를 설계하면 유저 상호작용을 처리하는 단일 컴포넌트가 도출되지만, 아키텍처 특성들을 분석하면 더 하위 컴포넌트로 더 잘게 나눌 수 있음
### 8.4.5 컴포넌트 재구성
- 아키텍트는 개발자들과 함께 지속적으로 컴포넌트 설계를 반복해야 함
- 소프트웨어 설계를 하다 보면 온갖 종류의 난관에 봉착하고, 어떤 미지의 이슈가 튀어나올지 내다볼 수 없음
- 컴포넌트 설계를 반복하는 접근 방식이 정말 중요
    - 차후 재설계를 하게 만들지 모를 모든 발견과 특이 사례를 전부 고려하는 것은 사실상 불가능
    - 아키텍처와 개발자가 애플리케이션 구축에 더 깊이 빠질수록 서로의 기능과 역할을 조정하면 좋을지 서로 다른 시각으로 바라보게 됨
## 8.5 컴포넌트 세분도
- 컴포넌트를 너무 잘게 나누어 설계하면 컴포넌트간 통신이 너무 많아짐
- 너무 크게 나누면 내부적으로 커플링이 증가해서 배포, 테스트가 어려워지고 모듈성 관점에서도 부정적인 영향을 미침
## 8.6 컴포넌트 설계
- 컴포넌트 설계에 '왕도'는 없음
- 아키텍트는 아키텍처를 설계하면서 요구사항을 접수하고 애플리케이션을 구성한 굵직굵직한 구성 요소를 그려봐야 함
### 8.6.1 컴포넌트 발견
- 아키텍트는 개발자, 비즈니스 분석가, 도메인 전문가와 협력해서 시스템에 관한 일반적인 지식과 시스템을 어떻게 분할할지 결정하고 그에 따라 초기 컴포넌트를 설계함
- 초기 설계의 목표는 여러 아키텍처 특성을 고려하여 문제 영역을 큼지막한 덩이들로 나누는 것
#### 엔티티 함정
- 아키텍트가 요구사항에서 식별된 각각의 엔티티를 바탕으로 관리자 컴포넌트를 만들었는데, 이것은 아키텍처가 아님
    - 프레임워크를 데이터베이스에 컴포넌트 관계형으로 매핑한 것에 불과
- 엔티티 함정은 아키텍트가 데이터베이스 관계를 애플리케이션의 워크플로로 오해할 때 벌어짐
- 애플리케이션의 실제 워크플로에 관한 지식이 얼마나 부족한지 나타냄
#### 액터/액션 접근법
- 아키텍트가 요구사항을 컴포넌트에 매핑할 때 즐겨 쓰는 방법
- 래셔널 통합 프로세스(RUP)에 정의됨
- 아키텍트는 애플리케이션에서 뭔가 일을 하는 엑터와 그들이 수행하는 액션을 식별하고 시스템의 대표적인 유저와 이들이 시스템에서 어떤 종류의 일을 하는지 찾아내는 기법
- 특정 소프트웨어 개발 프로세스, 특히 선행 설계를 매우 선호하는 공식적인 프로세스와 맞물려 인기를 얻음
- 요구사항 측면에서 역할이 분명하고 그들이 수행하는 액션의 종류가 확실한 경우에 잘 작동하며 아직도 많이 쓰임
#### 이벤트 스토밍
- 도메인 주도 설계에서 사용되는 컴포넌트 발견 기법
- 다양한 컴포넌트가 메세지나 이벤트를 이용해 서로 통신한다고 가정함
- 요구사항과 식별된 역할에 따라 시스템에서 어떤 이벤트가 일어나는지 파악
- 컴포넌트를 이벤트와 메세지 핸들러 중심으로 구축함
- 최종 일관적인 시스템에서 사용할 메세지를 아키텍트가 정의하는 데 도움이 되므로 마이크로서비스 같은 분산 아키텍처에서 추효함
#### 워크플로 접근법
- 이벤트 스토밍의 대안으로서 DDD나 메세징을 사용하지 않는, 더 일반화한 방법
- 컴포넌트 모델링이 이벤트 스토밍과 비슷하지만 메세지 기반 시스템을 구축하는 데 있어서 명시적인 제약조건은 없음
- 핵심 역할을 식별하고 이 역할이 관여하는 워크플로 유형을 결정하며 그렇게 식별된 활동에 따라 컴포넌트를 구축함
## 8.7 컴포넌트 발굴 사례 연구: GGG
- 팀에 특별한 제약이 없고 범용적인 컴포넌트 분할을 고려하고 있다면 액터/액션 접근법이 일반적으로 괜찮은 솔루션임
- GGG에는 입찰자, 경매인, 시스템 역할이 있음
    - Bidder
        - 라이브 동영상 스트림과 라이브 입찰 스트림을 보고 입찰을 한다
    - Auctioneer
        - 라이브 입찰을 시스템에 입력하고, 온라인 입찰을 수신하며, 아이템을 팔린 것으로 표시한다
    - System
        - 경매를 시작하고, 결제를 처리하고, 입찰자 활동을 추적한다
- 솔루션에 맞게 식별한 컴포넌트들
    - VideoStreamer
        - 유저에게 라이브 경매를 스트리밍
    - BidStreamer
        - 입찰이 발생하면 즉시 유저에게 스트리밍한다
        - VideoStreamer와 BidStreamer는 입찰자에게 읽기 전용 경매 뷰를 제공한다
    - BidCapture
        - 경매인, 입찰자 양쪽에서 입찰을 캡처한다
    - BidTracker
        - 입찰을 추적하는 기록 시스템 역할
    - AuctionSession
        - 경매 세션을 시작/종료
        - 입찰자가 경매를 결제를 처리하고 그 결과를 입찰자에게 알려주는 등 후속 조치를 함
    - Payment
        - 신용카드 결제를 처리하는 서드파티 결제 프로세서
- 컴포넌트를 초기 식별한 다음, 설계를 바꾸어야 할지 결정하기 위해 아키텍처 특성을 분석
- 위에서 BidCapture는 필요한 아키텍처 특성의 수준이 제각각임
    - BidCapture, AuctioneerCapture 두 컴포넌트로 나누어 각각 다른 수준의 아키텍처 특성을 지원하는게 좋음
## 8.8 아키텍처 퀀텀 딜레마: 모놀리식이냐, 분산 아키텍처냐
- 초기 컴포넌트 설계를 마친 아키텍트는 중요한 결정(모놀리식 vs 분산)을 해야 할 순간에 직면함
- 모놀리식 아키텍처
    - 배포 단위가 하나밖에 없으므로 단일 데이터베이스에 접속하여 실행되는 모든 시스템 기능이 포함됨
- 분산 아키텍처
    - 자신의 체계를 갖추고 네트워킹 프로토콜을 통해 서로 통신하는 여러 서비스로 구성됨
    - 배포 단위가 잘게 나뉘어 있고, 서비스별로 개발팀과 우선순위를 정해 자체 릴리스 주기와 엔지니어링 프랙티스를 수립합
- 저마다 다양한 트레이드오프가 있음
- 근본적인 결정은 설계프로세스 중에 식별된 아키텍처 퀀텀 수에 좌우됨
    - 단일 퀀텀 만으로 가능하다면 모놀리스 아키텍처가 장점이 더 많음
    - 컴포넌트마다 아키텍처 특성이 달라지는 경우 이를 수용할 수 있는 분산 아키텍처가 필요함
- 아키텍처 퀀텀을 활용하면 초기 설계 단계에서 아키텍처의 근본적인 설게 특성을 결정할 수 있으므로 아키텍처 특성의 범위와 커플링을 분석하는 방법으로서 장점이 부각됨