# 6.1 아키텍처 특성 측정
아키텍처 특성을 정의할 때 흔히 다음과 같은 문제들이 발생한다.
- 물리학이 아니다
	- 아키텍처 특성은 대부분 의미가 모호하다. 예를 들어 민첩성이나 배포성을 위한 설계라는 것은 명확하게 정의하기 힘들다.
- 정의가 너무 다양하다
	- 성능 같은 중요한 특성에 대한 정의가 같은 조직에서도 부서마다 일치하지 않는다.
- 너무 복합적이다
	- 바람직한 아키텍처 특성은 대부분 더 작은 다른 여러 특성들로 분할할 수 있다. 예를 들어, 민첩성을 모듈성, 배포성 및 시험성등의 특성으로 세분화할 수 있다.
이 세 가지 문제는 아키텍처 특성을 객관적으로 정의하면 모두 해결된다. 그러므로 아키텍처 특성을 명확하게 정의하고, 조직 전체의 동의를 구하면 공통의 아키텍처 언어를 확립할 수 있다. 복합적인 특성은 더 잘게 나누어 분석해보면 객관적으로 정의할 수 있는, 측정 가능한 특성을 밝혀낼 수 있다
### 6.1.1 운영적 측정
- 아키텍처 특성은 성능, 확장성처럼 비교적 정확하게 측정할 수 있는 것도 많지만 팀 목표에 따라 미묘하게 갈릴 때가 많다. 특정 요청에 대한 평균 응답 시간을 측정할 경우, 어떤 경계 조건 때문에 1%의 요청이 다른 요청보다 처리 시간이 10배나 오래 걸리는 경우 찾아내기 매우 까다로울 수 있다. 이경우 최대 응답 시간도 함께 측정해야 특이점까지 잡아낼 수 있다.
- 달성하기 어려운 성능 수치를 정하는 대신, 통계 분석 결과로 얻은 나름대로의 정의에 기반해야 한다.
- 도구가 발전하고 이해도가 높아지면서 측정할 수 있는 아키텍처 특성은 빠르게 진화하고 있다. 요즘은 최초 콘텐츠 렌더링과 최초 CPU 유휴 같은 메트릭을 사용하여 모바일 기기로 접속한 유저의 성능 문제를 비중있게 다루는 경우도 많다.
### 6.1.2 구조적 측정
- 성능처럼 목표치가 확실하지 않은 메트릭도 있다. 모듈성처럼 내부 구조에 관한 특성이 그렇다. 아직 종합적인 메트릭은 없지만 다른 케트릭과 공통 도구를 이용하여 간접적으로 측정할 수 있다.
- 코드의 복잡도는 순환 복잡도 메트릭을 통해 명쾌하게 측정할 수 있다
- 너무 복잡한 코드는 곧 코드 스멜이다. 이러한 코드는 모듈성, 시험성, 배포성 등 거의 모든 바람직한 특성을 저해하는 요소이다. 복잡도가 점점 증가하는지 잘 관찰해야 된다.
### 6.1.3 프로세스 측정
- 개발 프로세스와 교차하는 아키텍처 특성도 있다. 예를 들어, 민첩성은 시험성, 배포성 등의 특성으로 나눌 수 있는 복합적인 아키텍처 특성이다.
- 시험성은 거의 모든 플랫폼에서 테스트의 완전성을 평가하는 코드 커버리지 도구로 측정할 수 있다. 하지만 사고(thinking)과 의도 (intent)를 대체할 수는 없다. 코드 커버리지가 100%로 나오지만 assertion이 형편없는 코드베이스도 있다. 하지만 시험성은 분명히 객관적으로 측정할 수 있는 특성이다.
- 배포성 역시 실패 대비 배포 성공률, 배포 소요 시간, 배포 시 발생한 이슈/버그 등 다양한 메트릭으로 측정될 수 있다.
- 민첩성과 이와 관련된 부분은 분명히 개발 프로세스와 연관이 있지만, 이 프로세스는 아키텍처 구조에도 영향을 미칠 수 있다. 예를 들어, 배포 용이성과 시험성이 최우선 항목이라면 아키텍처 수준에서 모듈성, 격리성을 높이는데 주력할 수 있다.
# 6.2 거버넌스와 피트니스 함수
### 6.2.1 아키텍처 특성 관리
- 아키텍처 거버넌스는 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄한다. 예를 들어 조직 내부에서 소프트웨어 품질 보장 업무는 아키텍처 범주 안에 속하므로 아키텍처 거버넌스 항목이다.
- 요즘은 좋은 솔루션이 많이 등장해서 아키텍트의 수고를 많이 덜 수 있게 되었다. 익스트림 프로그래밍으로부터 지속적 통합이 발전되었고 이제는 운영도 자동화하는 데브옵스 체계까지 이르렀으며 지금도 아키텍처 거버넌스를 통해 계속 발전하고 있다.
### 6.2.2 피트니스 함수
- 결과가 목표에 얼마나 근접했는지를 나타내는 목표 함수가 바로 피트니스 함수이다. 예를 들어 머신 러닝의 기초인 외판원 문제를 유전 알고리즘으로 풀면, 그냥 이동 경로의 거리를 계산해서 그 거리가 가장 짧은 최적 경로를 표시하는 피트니스 함수를 생각해볼 수 있다.
- **아키텍처 피트니스 함수**
	- 정의: 어떤 아키텍처 특성(또는 그런 특성들의 조합)의 객관적인 무결성을 평가하는 모든 메커니즘
	- 피트니스 함수는 아키텍트가 다운로드 받아 사용하는 새로운 프레임워크가 아니라, 수많은 기존 도구들을 바라보는 새로운 시각이다. 아키텍처 특성을 검증하는 기법은 매우 다양하다. 피트니스 함수는 사용하는 방법에 따라 메트릭, 모니터, 단위 테스트 라이브러리, 카오스 엔지니어링 등 기존의 많은 검증 메커니즘과 중첩되는 부분이 있다.
- **순환 의존성**
	- 모듈성은 중요한 아키텍처 특성이기 때문에 우선 순위를 높게 두어 관리할 수 밖에 없다.
	- 아키텍트가 좋은 의도를 갖고 있더라도 많은 플랫폼에서 그에 반하는 동작을 제공하는 경우가 있다. 예를 들어 자바나 닷넷 IDE에서는 임포트하지 않는 클래스를 참조하면 친절하게 자동 임포트 기능을 제공한다. 하지만 모듈성 관점에서 이와 같은 클래스나 컴포넌트를 마구 임포트하는 건 정말 좋지 않은 유해한 안티 패턴이다.
	- 컴포넌트의 참조 그래프가 복잡해질수록 어떤 컴포넌트를 재사용하기 위해 그에 딸린 다른 컴포넌트로 함께 가져와야 하기 때문에 모듈성이 매우 떨어진다. 또 컴포넌트 간에 커플링이 증가할수록 아키텍처는 점점 진흙잡탕 안티패턴에 빠져든다.
	- 이 문제는 피트니스 함수로 순환 참조 여부를 발견함으로써 해결할 수 있다. JDepend라는 메트릭 도구로 패키지 간 의존성을 체크한다. 이 도구는 자바 패키지 구조를 알고 있고 순환 참조가 하나라도 존재하면 테스트가 실패한다. 아키텍트는 이 테스트를 CI의 일부로 장치함으로써 개발자 때문에 순환 참조가 발생하지 않을까하는 염려를 덜 수 있다.
- **"메인 시퀀스로부터의 거리" 피트니스 함수**
	- "메인 시퀀스로부터의 거리" 메트릭도 피트니스 함수를 이용해서 확인할 수 있다. JDepend로 수용 가능한 임계치를 설정하고 클래스가 이 범위를 벗어나면 테스트를 실패 처리하도록 할 수 있다.
	- 최근 수년 간 피트니스 함수 도구는 점점 더 정교해졌고, 목적에 따라 특화된 것들도 있다. JUnit의 영향을 받아 탄생한 ArchUnit은 단위 테스트로 코드화한 사전 정의된 거버넌스 규칙을 풍성하게 제공하므로 아키텍트는 모듈성에 특화된 테스트를 작성할 수 있다.
	- 레이어드 모놀리스를 설계할 때 아키텍트는 정당한 사유(동기, 트레이드 오프)를 내세워 레이어를 정의했지만 이렇게 정의한 레이어를 개발자들이 잘 지켜서 개발하리라 확신할 수 없다. 이 문제는 ArchUnit으로 피트니스 함수를 이용해 해결할 수 있다.
- 넷플릭스의 카오스 몽키, 시미안 아미도 피트니스 함수의 응용 사례이다. 적합성, 보안, 문지기 몽키는 피트니스 함수의 접근 방식을 잘 나타낸다. 
	- 적합성 몽키를 이용하면 넷플릭스 아키텍트가 프로덕션에 강제한 거버넌스 규칙들을 정의할 수 있다. 예를 들어 모든 서비스가 모든 REST 동사에 유효한 응답을 해야한다고 결정했다면 적합성 멍키에 해당 체크 로직을 구축한다.
	- 보안 몽키 역시 열려있으면 안되는 포트가 있거나, 설정 오류 등 서비스에 잘 알려진 보안 취약점이 없는지 체크한다.
	- 문지기 멍키는 더 이상 다른 서비스에서 트래픽이 들어오지 않는 서비스 인스턴스를 찾는다.
	- 넷플릭스는 진화적 아키텍처를 구축한 덕분에 옛 서비스는 홀로 실행되도록 놔둔 상태로 언제든지 새 서비스로 이전할 수 있다.
- 항공기 조종사, 외과 의사 등의 전문직 종사자들 또한 체크리스트를 활용한다. 프로들이 아주 세부적인 일을 반복하면 간혹 빠뜨리고 지나치는 것들이 있기 때문이다. 간결한 체크리스트는 기억을 되살려주는 역할을 한다. 피트니스 함수도 마찬가지이다. 피트니스 함수는 무거운 거버넌스 메커니즘 보다는 아키텍트가 중요한 아키텍처 원칙을 표현하고 자동으로 검증할 수 있는 메커니즘을 제공한다.
