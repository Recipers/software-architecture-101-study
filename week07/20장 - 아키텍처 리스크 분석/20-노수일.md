# 20. 아키텍처 리스크 분석
- 모든 아키텍처는 리스크를 가지고 있음
- 아키텍처 리스크 분석은 아키텍트의 핵심 활동 중 하나, 리스크를 꾸준히 분석, 아키텍처의 내부 결함을 바로잡고 리스크를 줄이는 일
- 리스크 스토밍 활동을 통해 리스크를 도출, 평가, 식별하는 핵심 기술과 프랙티스를 소개
## 20.1 리스크 매트릭스
- 리스크를 낮음, 중간, 높음 정도로 분류할지 결정해야 함
    - 분류 과정에 개인의 주관이 많이 반영될 수 밖에 없음
    - 리스크 매트릭스를 활용하면 주관성을 낮추고 특정 아키텍처 영역에서 리스크를 찾아내는 데 도움이 됨
- 리스크 매트릭스 모습
    - 전체 리스크 영향도와 발생 가능성 두 가지 차원으로 리스크를 평가
    - ex : 애플리케이션 중앙 데이터베이스의 가용성의 문제
        - 리스크 영향도 차원 : 데이터베이스가 다운된다면? (중간3~높음9)
        - 가능성 : 고가용성 클러스터로 구성되어 전체 서버가 일시 다운되어 불용 상태가 될 가능성은 희박함 (중간3)
## 20.2 리스크 평가
- 리스크 매트릭스를 활용하면 리스크 평가를 작성할 수 있음
- 맥락에 따라 유의미한 평가 기준에 대해 전체 아키텍처 리스크를 요약한 리포트
- 일반적으로는 애플리케이션의 서비스나 도메인 영역에 기반한 평가 기준이 포함됨
- 리스크 매트릭스로 정량화한 리스크는 평가 기준별로, 서비스 또는 도메인 영역별로 누적치를 계산할 수 있음
- 상대적 수치를 비교하면 어떤 리스크 범주나 도메인 영역에서 리스크가 개선됐는지, 반대로 악화됐는지 파악 할 수 있음
- 모든 항목의 리스크 분석 결과를 담고 표현하는 경우는 거의 없음
    - 주어진 맥락에 맞게 전달하려는 메시지를 잘 표현하려면 필터링이 꼭 필요함
    - 필터링을 거쳐 리스크가 높은 영역만 표시하면 전체적인 신호 대 잡음비가 개선되고 시스템이 지금 좋은 상태인지, 나쁜 상태인지 명확하게 드러남
- 리스크 등급 옆에는 플러스, 마이너스 같은 보편적인 방향 기호를 사용함 (위,아래,왼쪽,오른쪽이 아님)
    - 마이너스 부호 : 점점 나빠지고 리스크가 높아지는 추세
    - 플러스 : 점차 개선되는 중
    - 아무 부호도 없음 : 안정적, 특별히 좋아지거나 나빠지는 상태가 아님
- 진행중인 방향의 등급 번호와 화살표를 병기하는 것도 좋은 방법
- 피트니스 함수를 지속적으로 측정해서 파악할 수도 있음
- 각 리스크 평가 기준을 객관적으로 분석하면 흐름이 보이고 방향성을 알 수 있음
## 20.3 리스크 스토밍
- 시스템의 모든 리스크를 아키텍트 혼자 결정할 수 없음
    - 아키텍트 한 사람이 리스크 영역을 하나도 빠짐없이 살펴볼 수 없음
    - 시스템의 전 부문을 완벽하게 알고 있는 아키텍트는 없기 때문에 리스크 스토밍을 하는 것이 좋음
- 리스크 스토밍
    - 특정 범위 내에 있는 아키텍처 리스크를 찾아내는 협력적인 활동
    - 일반적인 리스크 영역
        - 검증되지 않은 기술
        - 성능
        - 확장성
        - 가용성 (전이적 종속성 포함)
        - 데이터 소실
        - 단일 장애 지점
        - 보안
        - 등
    - 보통 여러 아키텍트가 참여하지만 선임 개발자와 기술 책임자도 동석하면 더 효과적
    - 개발자도 참석하면 구현 관점에서 아키텍처 리스크를 짚어볼 수 있고, 아키텍처를 더 선명하게 이해할 수 있음
- 리스크 스토밍의 수행 과정은 개별 파트와 협력 파트가 공존함
    - 개별 파트
        - 모든 참가자가 리스크 매트릭스를 이용하여 각자 아키텍처 영역에 리스크를 할당함
    - 협력 파트
        - 전체 참가자가 모여 리스크 영역에 대해 공감하고 어떻게하면 리스크를 줄일 수 있는지 논의
- 개별/협력 파트 모두 아키텍처 다이어그램을 사용
- 전체 리스크 평가는 종합척인 아키텍처 다이어그램을 사용
- 특정 영역에 관한 리스크 스토밍은 해당 아키텍처 다이어그램을 사용
- 리스크 스토밍은 크게 세 가지 활동으로 이루어짐
    - 식별
    - 합의
    - 완화
### 20.3.1 식별
- 각 참여자가 아키텍처 내부의 리스크 영역을 개인적으로 식별하는 활동
- 단계
    1. 리스크 스토밍을 주관하는 아키텍트가 협력 파트를 진행하기 하루, 이틀 전에 참가자 전원에게 초대장을 보냄
        - 초대장에는 아키텍처 다이어그램, 리스크 스토밍 부문, 날짜 및 장소가 있음
    2. 참가자는 리스크 매트릭스를 이용해 개별적으로 아키텍처를 분석하고 리스크를 낮음, 중간, 높음으로 분류
    3. 참가자는 작은 색상별 포스트잇 메모지에 리스크 번호를 각각 기재
- 리스크 스토밍은 보통 한 가지 특정 부분만 분석하지만 인력, 일정 등의 사정에 따라 한 번에 여러 부문을 분석하는 경우도 있음
- 세 사람이 리스크를 높음(6)으로 식별했지만, 한 사람은 가용성 리스크를 발견한 반면 나머지 두 사람은 성능 리스크를 발견했다면, 이 두가지 부문은 따로따로 논의되어야 함
### 20.3.2 합의
- 참가자 모두가 아키텍처 내부의 리스크에 대해 뜻을 함게한다는 목표를 생각해보면 매우 협력적인 활동
- 아키텍처 다이어그램을 벽에 걸어두거나 대형 스크린에 표시하면 아주 효과적
- 세션 참가자들은 각자 리스크를 발견한 영역의 아키텍처 다이어그램에 포스트잇을 붙이기 시작함
- 리스크 스토밍을 관장하는 아키텍트는 모든 참가자에게 리스크가 식별된 아키텍처 영역의 다이어그램에 리스크를 배치해달라고 요청
- 포스트잇을 다 붙인 후 리스크 스토밍의 협력 파트가 시작됨
- 리스크 스토밍의 목표는 사람들이 한 팀이 되어 리스크 영역을 분석하고 과연 그것이 리스크가 맞는지 합의를 이끌어내는 것
- 그림 20-7 요약
    1. 일래스틱 로드 밸런서의 리스크에 대해 두 참가자는 리스크 중간(3), 나머지 한 참가자는 리스크 높음(6)으로 식별
    2. 한 참가자가 푸시 확장 서버를 리스크 높음(9)으로 식별
    3. 세 참가자가 MySQL 데이터베이스를 리스크 중간(3)으로 식별함
    4. 한 참가자가 레디스 캐시를 리스크 높음(9)으로 식별함
    5. 세 참가자가 몽고DB 로깅을 리스크 낮음(2)로 식별함
    6. 다른 아키텍처 영역은 모두 리스크가 없는 것으로 보고 따로 포스트잇을 붙이지 않음
- 3, 5번은 리스크 레벨과 당위성에 동의했으니 논의 필요 없음
- 1번은 의견 차이
- 2, 4번은 한 명의 참가자만 리스크라고 생각하기 때문에 합의 활동 통의 필요
- 1번은 한명만 리스크 높음으로 식별
    - 그 사람한테 이유를 물음
    - 다른 사람들이 설득, 합의 활동을 하면서 한명이 리스크 레벨을 낮춤
    - 합의 활동을 하면서 중지를 모아야 함
- 2번은 푸시 확장 서버는 첫 번째 참가자만 리스크 높음으로 식별
    - 첫 번째 참가자가 이유를 설득
- 4번은 참가자가 레디스 캐시를 리스크 높음으로 식별, 다른 두 참가자는 아님
    - 레디스에 대해 알지 못해서 리스크가 높다 판별
    - 개발자가 리스크 스토밍 세션에 참여하는 것이 얼마나 도움이 되는지 나타낸 사례
### 20.3.3 완화
- 마지막으로 리스크 완화 활동을 함
- 아키텍처에서 리스크를 줄이려면 일반적으로 아키텍처의 특정 영역을 변경 또는 개선하는 작업이 필요함
- 식별된 리스크를 줄이거나 없앨 방법을 모색함
- 식별된 리스크를 따라 원래 아키텍처를 완전히 바꿔야 할 수 있지만, 간단한 아키텍처 리팩터링만으로 해소되는 경우도 있음
- 아키텍처를 어떻게 변경하든 모든 작업에는 추가 비용이 들어가므로 주요 이해관계자들은 리스크를 줄이기 위해 그 만한 비용을 부담할 가치가 있는지 결정함
- 전체 아키텍처는 물론, 아키텍트와 비즈니스 이해관계자들 간의 협상에도 리스크 스토밍은 상당한 영향을 미칠 수 있음
- 리스크 평과와 리스크 스토밍 기법을 적절히 혼용하면 리스크 식별 및 추적, 아키텍처 개선, 주요 이해관계자 간의 협상을 진행하는 과정에서 큰 도움이 됨
## 20.4 애자일 스토리 리스크 분석
- 리스크 스토밍은 아키텍처는 물론, 다른 소프트웨어 개발 분야에도 응용할 수 있음
- 리스크 매트릭스를 사용하면 유저 스토리의 리스크는 첫 번째 차원과 두 번째 차원으로 식별할 수 있음
    - 첫 번째 차원 : 해당 이터레이션에서 이 스토리가 완료되지 않을 경우의 전체 영향도
    - 두 번째 차원 : 스토리가 완료되지 않을 가능성
- 동일한 아키텍처 리스크 매트릭스를 스토리에 활용함으로써 리스크가 높은 스토리를 찾아내고 그런 스토리를 주의 깊게 추적해서 우선 순위를 두는 것
## 20.5 리스크 스토밍 예시
- 환자들의 다양한 건강 상태에 대해 간호사가 조언을 해주는 콜 센터 시스템
    - 요구사항
        - 질문을 받으면 간호사나 환자에게 의료 문제를 안내하는 서드파티 진단 엔진을 사용
        - 환자는 콜 센터에 전화를 걸어 간호사와 통화거나 간호사 없이 직접 진단 엔진에 엑세스하는 셀프 서비스 웹사이트를 이용
        - 전국적으로 250명의 간호사와 수십만 명의 달하는 셀프 서비스 환자를 동시에 지원할 수 있어야 한다
        - 간호사는 환자의 의무 기록을 열람할 수 있지만, 환자는 자신의 의무 기록을 볼 수 없다
        - 의무 기록에 관한 미국 의료 정보 보호법을 준수해야 한다. 즉, 간호사 이외의 그 누구도 의무 기록을 열람할 수 없다
        - 전염병과 독감이 유행하는 시즌에 데이터 요청이 급증해도 시스템이 이를 감당해야 한다
        - 간호사 프로필에 따라 통화가 연결되어야 한다
        - 서드파티 진단 엔진은 초당 약 500개의 요청을 처리할 수 있어야 한다
    - 3개의 웹 기반 유저 인터페이스
        - 셀프 서비스용 인터페이스
        - 전화를 받는 간호사용 인터페이스
        - 관리 직원이 간호사 프로필과 시스템 설정값을 추가하는 관리용 인터페이스
    - 콜 센터 부분은 걸려온 전화를 받는 토오하 접수가와 프로필을 보고 통화 가능한 다음 간호사에게 연결시켜주는 통화 라우터로 구성됨
    - 이 아키텍처의 핵심은 요청이 들어오면 보안 체크 후 적절한 백엔드 서비스로 보내주는 진단 시스템 API 게이트웨이
    - 주요 서비스
        - 사례 관리 서비스
        - 간호사 프로필 관리 서비스
        - 의무 기록 인터페이스
        - 외부 서드파티 진단 엔진
- 요구사항을 살펴보고 아키텍처 다이어그램을 재검토한 다음, 리스크를 줄일지 고민함
### 20.5.1 가용성
- 시스템이 성공하려면 가용성이 매우 중요
- 제시된 리스크 영역
    - 중앙 데이터베이스를 사용하는 아키텍처는 영향도가 높고(3) 가능성이 중간(2)이므로 리스크 높음(2)로 식별됨
    - 진단 엔진 가용성은 영향도가 높고(3) 가능성을 알 수 없으므로(2) 리스크 높음(9)로 식별됨
    - 의무 기록 가용성은 시스템 실행에 필수 컴포넌트가 아니므로 리스크 낮음(2)으로 식별됨
    - 각 서비스는 여러 인스턴스로 구성되어 있고 API 게이트웨이도 클러스터링되어 있으니 다른 시스템 파트는 가용성 측면에서 리스크로 보이지 않음
- 리스크 스토밍
    - 모든 참가자는 데이터베이스가 다운되면 간호사가 사례 기록을 수기로 작성할 수 있지만, 데이터베이스를 사용할 수 없으니 통화 라우터는 작동하지 않으리란 점에 동의
    - 하나의 물리적인 데이터베이스를 간호사 프로필 정보가 저장된 데이터베이스 클러스터, 단일 인스턴스 형태의 사례 기록용 데이터베이스로 분리하는게 낫다고 결론
    - 가용성 우려가 불식되고 사례 기록은 관리자만 볼 수 있어 보안성도 개선됨
    - 간호사 프로필 정보를 통화 라우터에 캐시하는 방법도 생각했지만, 통화 라우터의 구현 코드가 서드파티 제품일 가능성이 높아 데이터베이스 엑세스 방식 택함
- 외부 시스템은 마음대로 제어할 수 없기 때문에 가용성 관리가 훨씬 어려움
    - 시스템별로 SLA(서비스 수준 계약), SLO(서비스 수준 목표)가 명시된 문서를 확인해보는 것
    - SLA는 법적 구속력이 있는 공식 계약서, SLO는 아님
### 20.5.2 탄력성
- 유저 부하 급증에 따른 가변 확장성
- 간호사는 250명에 불과하지만 셀프 서비스 파트도 진단 엔진과 간호사 정보를 엑세스 할 수 있으므로 진단 인터페이스에 상당한 요청이 몰릴 수 있음
- 진단 엔진 인터페이스를 리스크 높음(9)으로 식별
    - 초당 500개의 요청을 처리하는 능력으로는 예상 처리량을 감당할 수 없다고 봄
- API 게이트웨이와 진단 엔진 인터페이스 간의 배압 지점에 비동기 큐를 두고 진단 엔진의 호출을 완충 지대로 활용하는 방법
    - 간호사가 진단 엔진의 응답을 너무 오래 대기하거나 타임아웃 발생할 가능성이 있음
- 앰뷸런스 패턴을 으용하여 셀프 서비스보다 간호사에게 더 높은 우선 순위를 부여하는 방법
    - 메시지 채널이 2개 필요
    - 리스크 완화에 약간은 도움이 되나, 대기시간 문제는 여전히 숙제
- 발병에 관한 특정 진단 질문을 캐시함으로써 진단 엔진 인터페이스에 도달하는 호출을 줄일 수 있다 판단
### 20.5.3 보안
- 의무 기록 열람은 간호사만 열람이 가능하도록 안전하게 관리해야 함
- API 게이트웨이의 보안 체크 문제는 아니지만, 다른 부분에서 보안 리스크를 찾아낼 수도 있음
- 진단 시스템 API 게이트웨이를 리스크 높음(6)으로 식별
    - 관리 직원이나 셀프 서비스 환자가 의무 기록을 열람할 때의 영향도(3)와 그럴 가능성이 중간(2)임을 감안한 결과
        - 리스크 발생 가능성은 API 호출에 대해 보아 체크를 하기 때문에 높지 않음
        - 모든 호출이 동일한 API 게이트웨이를 통과하므로 가능성은 중간이라고 본 것
    - 유저 유형별로 API 게이트웨이를 사용하면 관리자용 웹 유저 인터페이스, 셀프 서비스용 웹 유저 인터페이스의 호출이 의무 기록 시스템까지 도달하지 못하게 막을 수 있음
- 리스크 스토밍으로 아키텍처 가용성, 탄력성, 보안 문제를 해결할 수 있는 의미있는 전진이 이루어짐
- 리스크 스토밍은 1회성 프로세스가 아님
- 프로덕션에서 발생하기 전에 리스크 영역을 포착하고 미리 그 해결 방법을 찾는, 시스템이 살아있는 내내 반복하는 과정
