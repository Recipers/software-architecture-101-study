# 18.1 아키텍처 결정 안티패턴
- 안티패턴이란 처음에는 좋은 생각처럼 보이지만, 이내 곧 곤경에 빠뜨리는 애물단지라고 정의한다.

### 19.1.1 '네 패를 먼저 보여주지마' 안티패턴
- 잘못된 선택을 하는 것을 두려워한 나머지 아키텍처 결정을 회퓌하거나 미루는 현상을 말한다.
- 이 안티패턴은 두 가지 방법으로 극복할 수 있다.
  - 어떤 중요한 아키텍처 결정을 내리기 전, 마지막으로 책임질 수 있는 순간까지 기다리는 것
    - 자신의 결정을 정당화하고 검증하기 위해 충분한 정보를 수집할 때까지 기다리지만, 안티패턴에 빠질 정도로 오래기다리지 않아야 한다
  - 개발팀과 지속적으로 협력하면서 결정한 내용을 원래 의도한 대로 추진한다.
    - 세부적인 기술에 관한 모든 이슈를 아키텍트 혼자 전부 다 알수는 없기 때문에 개발팀과의 협력은 절대적으로 필요하다.

### 19.1.2 '무한반복 회의' 안티패턴
- 사람들이 어떤 결정을 왜 했는지 모르고 주구장창 회의만 계속하는 것
- 발생하는 이유는 아키텍트가 자신이 내린 결정을 정당화 하는데 실패했기 때문이다.
  - 아키텍처 결정을 정당화하려면 그 결정을 내리게된 기술적, 비즈니스적 근거를 제시하는 것이 중요하다.
- 어떤 아키텍처 결정이던 그것을 정당화할 때에는 비즈니스 가치를 제시하는 것이 중요하다.
  - 그렇게 해야 그 아키텍처 결정을 정말 다른 무엇보다 우선해야 하는지 한 번 더 돌아볼 수 있다.
- 가장 일반적인 비즈니스 정당화로는 비용, 출시 시기, 유저 만족도, 전략적 포지셔닝 등이 있다.

### 19.1.3 '이메일 기반 아키텍처' 안티패턴
- 사람들이 아키텍처 결정을 놓치거나 잊어버리고 심지어는 그렇게 결정됐다는 사실조차 알지 못해 아키텍처 결정을 구현하지 못하는 상태.
- 이 안티패턴을 방지하고 아키텍처 결정을 효과적으로 전달하는 방안
  - 이메일 본문에 아키텍처 결정을 포함시키지 않는다.
  - 아키텍처 결정에 정말 관심있는 사람들에게만 통지한다.
 
# 19.2 아키텍처적으로 중요한
- 아키텍트가 어떤 아키텍처 결정을 담당하는지 (즉, 아키텍처 결정이란 대관절 무엇인지) '아키텍처적으로 중요한'이라는 용어를 만들어 풀이하고자 했다.
  - 아키텍처적으로 중요한 결정이란 구조, 비기능 특성, 의존성, 인터페이스, 구현 기술에 영향을 미치는 결정
- 구조는 사용 중인 아키텍처의 패턴이나 스타일에 영향을 미치는 결정들이다.
- 비기능 특성은 개발 또는 유지보수 중인 애플리케이션이나 시스템에 중요한 아키텍처 특성(~성)들이다.
- 의존성은 전체 확장성, 모듈성, 민첩성, 시험성, 안정성 등에 영향을 미치는 시스템 내부의 컴포넌트와 서비스간의 커플링 지점을 가리킨다.
- 인터페이스는 게이트웨이, 통합 허브, 서비스 버스, API 프록시를 통해 서비스와 컴포넌트에 액세스하고 조정하는 수단을 말한다.

# 19.3 아키텍처 결정 레코드
- 아키텍처 결정을 가장 효과적으로 문서화하는 방법은 바로 아키텍처 결정 레코드(ADR)이다.

### 19.3.1 기본 구조

<img width="368" alt="스크린샷 2025-06-25 오후 2 45 10" src="https://github.com/user-attachments/assets/a2eebb8d-5e8c-4921-ba54-04c76e1bbe67" />

- ADR의 기본 구조는 제목, 상태, 콘텍스트, 결정, 결과 이렇게 주요 5개의 섹션으로 구성된다.
  - 여기에 컴플라이언스와 노트라는 추가 섹션을 덧붙인다.
- **제목**
  - 일련 번호와 함께 아키텍처 결정을 짤막한 문구로 표현한다.
    - 예를 들어, 주문 서비스와 결제 서비스가 서로 비동기 메시징을 사용하기로 결정했다면 '42. 주문 서비스와 결제 서비스 간의 비동기 메시지 사용'
- **상태**
  - ADR 상태는 Proposed(제안됨), Accepted(수락됨), Supeseded(대체됨)으로 표시한다.
    - 대체됨은 결정이 번복되어 다른 ADR에 의해 대체된 상태로, 이전 ADR 상태는 수락됨 상태여야 한다.
  - 대체됨 상태는 어떤 결정이 내려졌고, 당시 왜 그런 결정을 했는지, 새로운 결정은 무엇이고 어쩌다 변경을 하게 됐는지 등에 관한 이력을 보관하는 강력한 수단이다.
- **콘텍스트**
  - 불가항력적인 요소를 특정한다. '어떤 사정 때문에 그렇게 결정할 수 밖에 없었나?'이다.
    - 특수항 상황이나 문제점을 이야기하고 다른 대안에 대해 상술한다. 각 대안을 상세히 분석한 문서가 필요할 경우, 콘텍스트 섹션 대신 대안 섹션을 추가한다.
  - 아키텍처를 문서화하는 수단이기도 하다. 콘텍스트를 기술함으로써 곧 아키텍처를 기술하는 것이다. 이는 분명하고 간결하게 특정 아키텍처 영역을 문서화하는 효과적인 방법이다.
- **결정**
  - 아키텍처 결정과 그렇게 결정하게 된 사유를 전부 밝힌다.
  - 결정 섹션의 가장 큰 강점은 아키텍트가 방법보다 이유에 더 무게를 실을 수 있다는 것이다.
    - 왜 그런 결정을 내렸는지 이해하는 것이 그것이 어떻게 작동되는지 이해하는 것 보다 훨씬 더 중요하다.
    - 결정을 내린 이유와 그런 결정을 할 수 밖에 없었던 사연을 알고나면 문제의 맥락을 더 잘 이해하고 행여 다른 문제가 생기지 않도록 리팩터링을 통해 실수를 예방할 수 있다.
  - 예를 들어, 수년 전 구글은 두 서비스 간 통신 수간으로 gRPC를 사용하기로 초기 아키텍처 결정을 했다.
    - 왜 그런결정을 했는지 영문도 모른 채 수년이 지나 다른 아키텍트가 이 결정을 무시하고 메시징을 사용하기로 결정했다.
    - 이렇게 리팩터링을 하자 레이턴시가 급증하여 업스트림 시스템에서 타임아웃이 발생했다.
    - 애당초 레이턴시를 크게 줄이려고 gRPC를 사용하기로 결정했다는 사실을 인재했다면 처음부터 불필요한 리팩터링은 하지 않았을 것이다.
- **결과**
  - 아키텍처 결정의 전체적인 영향도를 기술한다. 어떤 결정을 하더라도 좋은 영향과 나쁜 영향은 공존하기 마련이다.
    - 아키텍처 결정이 어떤 영향을 미치는지 구체적으로 기술함으로써 아키텍트는 결정의 장점보다 그 영향이 더 중요한지 되돌아보게 된다.
  - 아키텍처 결정에 관한 트레이드오프는 물론, 분석 결과도 문서화할 수 있으므로 유용하다.
    - 트레이드오프는 비용 기반일 수도 있고, 다른 아키텍처 특성과의 트레이드오프일 수도 있다.
- **컴플라이언스**
  - 컴플라이언스 관점에서 아키텍트가 아키텍처 결정을 어떻게 측정/관리하는게 좋을지 생각하게 만든다.
    - 결정에 대한 컴플라이언스 체크를 수동으로 할지, 피트니스 함수로 자동화할지 결정해야 한다.
    - 피트니스 함수로 자동화할 수 있으면 피트니스 함수를 작성하는 방법, 컴플라이언스 측면에서 아키텍처 결정을 판단하기 위해 코드베이스에 다른 변경은 필요없는지 등의 내용을 이 섹션에 기재한다.

<img width="550" alt="스크린샷 2025-06-25 오후 3 07 28" src="https://github.com/user-attachments/assets/06bac7cd-4e91-45c8-ac4d-7f286f209fc1" />

- 예를 들어, 전통적인 n-티어 아키텍처에서 '비즈니스 레이어에서 비즈니스 객체가 사용하는 모든 공유 객체는 공유 서비스 레이어에 두고 공유 기능을 분리하여 구현한다'라고 아키텍처 결정을 했을 때
  - 이 아키텍처 결정은 자바 아크유닛이나 C# 넷아크테스트를 사용해서 측정/관리를 자동화할 수 있다.
  - 이 섹션에는 어떤 테스트를하고 그 테스트를 어디에서 찾을 수 있는지, 테스트는 언제 어떻게 실행되는지도 지정한다.
- **노트**
  - 이 섹션에는 다음과 같은 ADR에 관한 다양한 메타데이터가 포함된다.
  - ADR을 버전 관리 시스템에 저장할 때에도 저장소에서 지원되지 않는, 부가적인 메타 정보가 있으면 유리하므로 이 섹션은 추가하는 것이 좋다.
 
### 19.3.2 ADR 저장
- ADR은 어딘가에 저장해야 한다. 일부 아키텍트들은 ADR을 소스코드와 함께 깃 리포지토리에 보관하는 것을 선호한다.
  - 규모가 큰 조직에서는 몇 가지 주의할 점이 있다.
    - 아키텍처 결정을 확인해야 하는데 어떤 사람들은 깃 리포지토리에 액세스할 수 없는 경우가 있다.
    - 애플리케이션 깃 리포지토리를 벗어난 콘텍스트(예: 통합 아키텍처 결정, 엔터프라이즈 아키텍처 결정 등)가 있는 ADR을 깃에 저장하는 것을 적절하지 않다.
  - 그러므로 ADR은 위키 또는 다른 문서 렌더링 소프트웨어에서 쉽게 저장 가능한 공유 파일 서버의 공유 디렉터리에 저장하는 것이 좋다.

<img width="279" alt="스크린샷 2025-06-25 오후 3 13 48" src="https://github.com/user-attachments/assets/c4100ad2-7883-439c-8007-f38d1da42eb5" />

- application 디렉터리는 애플리케이션 콘텍스트에 관한 아키텍처 결정을 포함하며 다시 3개의 서브디렉터리로 분할된다.
  - common 서브디렉터리는 '프레임워크 관련 클래스는 모두 하부 프레임워크에 속하며 클래스를 식별하는 애너테이션이나 속성이 포함된다'처럼 모든 애플리케이션에 통용되는 아키텍처 결정을 포함한다.
  - 이 세 서브디렉터리는 특정 애플리케이션 또는 시스템 콘텍스트에 대응되며, 해당 애플리케이션이나 시스템(ATP, PSTD 애플리케이션)에 관한 아키텍처 결정을 포함한다.
- integration 디렉터리는 애플리케이션, 시스템, 서비스 간 통신에 관한 ADR을 포함한다.
- 엔터프라이즈 아키텍처 ADR은 enterprise 디렉터리에 두고 전체 시스템과 애플리케이션에 영향을 미치는 전사 아키텍처 결정을 내린다.
- 제시한 디렉터리는 어디까지나 권장 사항이다. 회사마다 상황에 맞게, 하지만 모든 팀에 대해일관된 명칭을 부여해야 한다.

### 19.3.3 ADR로 문서화
- 소프트웨어 아키텍처의 문서화는 언제나 어려운 주제이다. 또한 아직 이렇다 할 소프트웨어 아키텍처 문서화 표준은 없다.
- ADR은 소프트웨어 아키텍처를 효과적으로 문서화하는 수단으로 활용할 수 있다.
  - ADR 콘텍스트 섹션은 아키텍처 결정이 필요한 시스템의 특정 영역을 기술하는 더 없이 훌륭한 장소인데다 어떤 대안들이 있는지 기술하기에 적절한 곳이다.
  - 가장 중요한 섹션은 아키텍처 결정을 내린 사유가 기술된 결정 섹션이다. 이 섹션 하나만 봐도 ADR은 현존하는 최고의 아키텍처 문서화 포맷이다.
 
### 19.3.4 ADR 표준화
- 일반적으로 표준은 그것이 유용해서라기보다 사람들이 일하는 방식을 통제하는 용도로 더 많이 사용되는 것 같다.
- ADR을 표준화하면 이런 나쁜 관행이 바뀔 수도 있다.
  - 예를 들어 ADR 콘텍스트 섹션은 어떤 표준을 강제 적용할 수 밖에 없는 상황을 설명하고, 결정 섹션은 어떤 표준이 있는지, 그리고 그런 표준이 왜 존재해야 하는지 표현한다.
  - 이것은 어떤 표준을 다른 무엇보다 우선시해야 하는 논리를 효과적으로 검증하는 수단이 된다.
  - 결과 섹션은 어떤 표준이 타당하며 반드시 지켜져야 하는지를 스스로 검증하기에 적합한 기회이다.
 
### 19.3.5 예시
- 7.2.1절에는 많은 아키텍처 결정이 등장한다.
  - 이벤트기반 마이크로서비스 사용, 입찰자와 경매인 유저 인터페이스의 분할, 비디오 캡처를 위한 실시간 전송 프로토콜 사용, 단일 API 레이어 사용, 메시지 발행/구동 사용 등등
  - 이런 결정들은 사실 경매 시스템 구축에 필요한 수십가지 아키텍처 결정 중 일부에 지나지 않다. 어떤 시스템에서 확정한 아키텍처 결정들이 아무리 뻔하더라도 하나하나 그 사유를 밝히고 문서화해야 한다.

<img width="570" alt="스크린샷 2025-06-25 오후 3 30 45" src="https://github.com/user-attachments/assets/12cf5204-2b1f-4654-a501-68d6a49874ec" />
