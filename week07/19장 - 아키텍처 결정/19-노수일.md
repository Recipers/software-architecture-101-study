# 19. 아키텍처 결정
- 아키텍트에게 기대하는 핵심 가치 중 하나는 아키텍처 결정을 내리는 것
- 애플리케이션이나 시스템 구조, 기술 결정
- 충분한 정보를 수집하고 결정을 정당화, 문서화 한 다음 이해관계자들과 효과적으로 소통해야 함
## 19.1 아키텍처 결정 안티패턴
- 아키텍처를 결정하는 것도 기술, 안티패턴에 빠질 수 있음
- 아키텍처 결정에서 자주 발생하는 안티패턴
    - 네 패를 먼저 보여주지마
    - 무한 반복 회의
    - 이메일 기반 아키텍처
- 안티패턴은 보통 누적되어 발생됨
    - 네 패를 먼저 보여주지마 -> 해결 -> 무한 반복 회의 -> 해결 -> 이메일 기반 아키텍처
### 19.1.1 '네 패를 먼저 보여주지마' 안티패턴
- 아키텍트가 잘못된 선택을 하는 것을 두려워한 나머지 아키텍처 결정을 회피하거나 미루는 현상
- 두 가지 방법으로 극복
    - 어떤 중요한 아키텍처 결정을 내리기 전, 마지막으로 책임질 수 있는 순간까지 기다리는 것
        - 충분한 정보를 수집할 때까지 기다림
        - 개발팀을 마냥 붙잡거나 분석 마비 안티패턴에 빠질 정도로 오래 기다리지는 않음
    - 개발팀과 지속적으로 협력하면서 아키텍트가 결정한 내용을 원래 의도한대로 추진
        - 세부적인 기술에 관한 모든 이슈를 아키텍트 혼자 다 알수는 없음
        - 나중에 문제가 생겨도 아키텍처 결정 변경, 재빠르게 대응 가능
### 19.1.2 '무한반복 회의' 안티패턴
- '네 패를 먼저 보여주지마' 극복 후 '무한반복 회의' 안티패턴으로 이어짐
- 어떤 결정을 왜 했는지 모르고 주구장창 회의만 계속 하는 것
- 아키텍트가 자신이 내린 결정을 정당화하는 데 실패해서 발생
- 아키텍처 결정을 정당화하려면 그 결정을 내린 기술적, 비즈니스적 근거를 제시하는 것이 중요
- 어떤 아키텍처 결정이건 그것을 정당화할 때에는 비즈니스 가치를 제시하는 것이 중요
    - 비즈니스 가치가 없다면 좋은 아키텍처 결정이 아님, 재고해봐야 함
- 가장 일반적인 비즈니스 정당화로는 비용, 출시 시기, 유저 만족도, 전략적 포지셔닝 등이 있음
    - 네 가지 관점에서 비즈니스적으로 정당화할 때에는 무엇이 비즈니스 이해관계자에게 중요한지 숙고해야 함
### 19.1.3 '이메일 기반 아키텍처' 안티패턴
- 아키텍처 결정을 놓치거나 잊어버리고, 그렇게 결정되었다는 사실조자 알지 못해 아키텍처 결정을 구현하지 못하는 상태
- 아키텍처 결정을 효과적으로 전달하는 문제와 관련된 안티패턴
- 이메일은 훌륭한 소통 수단이지만, 문서 저장 체계로는 형편없음
- 아키텍처 결정을 효과적으로 전달하려면
    - 이메일 본문에 아키텍처 결정을 포함시키지 않을 것
        - 아키텍처 결정에 관한 여러 경로의 기록 체계가 파생되고, 중요한 세부 사항들이 누락되기 쉬움
        - 이메일 본문에는 아키텍처 결정의 본질과 맥락만 언급하고 세부 정보는 단일 기록 시스템에 보관해서 링크만 제공
    - 아키텍처 결정에 정말 관심있는 사람들에게만 통지
## 19.2 아키텍처적으로 중요한
- 아키텍처 결정에 기술적인 내용이 포함되어도 기술 결정이라고 단정지을 수 없음
- 아키텍처 특성을 지원하기 위해 선택한 기술이라면 아키텍처 결정이 맞음
- 아키텍처적으로 중요한 결정 (Release It, 마이클 나이가드)
    - 구조, 비기능 특성, 의존성, 인터페이스, 구현 기술에 영향을 미치는 결정
- 구조
    - 사용중인 아키텍처의 패턴이나 스타일에 영향을 미치는 결정
- 비기능 특성
    - 개발 또는 유지보수 중인 애플리케이션이나 시스템에 중요한 아키텍처 특성들
- 의존성
    - 전체 확장성, 모듈성, 민첩성, 시험성, 안정성 등에 영향을 미치는 시스템 내부의 컴포넌트와 서비스 간의 커플링 지점을 가리킴
- 인터페이스
    - 게이트웨이, 통합 허브, 서비스 버스, API 프록시를 통해 서비스와 컴포넌트에 엑세스하고 조정하는 수단
    - 계약 버저닝, 버전 구식화 전략 등 계약에 정의된 내용
- 구현 기술
    - 그 자체는 기술적인 것이지만, 아키텍처의 많은 부분에 영향을 미치는 플랫폼, 프레임워크, 도구, 프로세스에 관한 결정
## 19.3 아키텍처 결정 레코드
- 아키텍처 결정을 가장 효과적으로 문서화 하는 방법
- 아키텍처 결정이 작성된 짧은 텍스트 파일
    - 아스키독, 마크다운
- ADR을 관리하는 도구도 있음
    - 채번 스키마, 위치, 대체로직 등 ADR 관리에 필요한 CLI 제공
### 19.3.1 기본 구조
- ADR의 기본 구조
    - 제목
    - 상태
    - 콘텍스트
    - 결정
    - 결과
    - 컴플라이언스, 노트 추가
#### 제목
- 일련 번호와 함께 아키텍처 결정을 짤막한 문구로 표현
#### 상태
- 제안됨, 수락됨, 대체됨으로 표시
- 제안됨
    - 해당 결정이 상위 레벨의 의사 결정권자 또는 아키텍처 거버넌스 협의체의 승인을 득해야 하는 상태
- 수락됨
    - 결정이 승인되어 구현할 준비가 된 상태
- 대체됨
    - 결정이 번복되어 다른 ADR에 의해 대체된 상태
    - 이전 ADR 강태는 수락됨 상태여야 함
    - 어떤 결정이 내려졌고, 당시 그 결정을 왜 했는지, 새로운 결정은 무엇이고 어쩌다 변경을 하게 됐는지 등에 관한 이력을 보관하는 강력한 수단
- ADR 상태 섹션은 아키텍트 본인이 아키텍처 결정을 승인할 수 있는 기준, 상급 아키텍트의 승인이나 검토 위원회, 다른 아키텍처 관리 협의체의 승인을 받고 진행해야 하는지 문제를 두고 자신의 상사나 수석 아키텍트와 대화를 하도록 만들기 때문에 중요
- 비용, 전체 팀 영향도, 보안 이 세 가지 기준은 이런 대화를 시작하기에 좋은 주제임
#### 콘텍스트
- 불가항력적인 요소를 특정
    - '어떤 사정 때문에 그렇게 결정할 수밖에 없었나?'
- 이 섹션에서 특수한 상황이나 문제점을 이야기하고 다른 대안에 대해 상술함
- 각 대안을 상세히 분석한 문서가 필요한 경우, 콘텍스트 섹션 대신 ADR에 대안 섹션을 추가
#### 결정
- 아키텍처 결정과 그렇게 결정하게 된 사유를 전부 밝힘
- 수동적인 어조 대신, 긍정적이고 당당한 어조로 아키텍처 결정을 설명하는 방법을 강조함
- 아키텍트가 방법보다 이유에 무게를 실을 수 있다는 점이 가장 큰 강점
    - 왜 그런 결정을 내렸는지 이해하는 것이 어떻게 작동되는지 이해하는 것보다 훨씬 더 중요
    - 결정을 내린 이유와 그렇게 할 수밖에 없었던 사연을 알고 나면 사람들은 문제의 맥락을 더 잘 이해하고 행여 다른 문제가 생기지 않도록 리팩터링을 통해 실수를 예방할 수 있음
#### 결과
- 아키텍처 결정의 전체적인 영향도를 기술함
- 어떤 결정을 하더라도 좋은 영향과 나쁜 영향은 공종하기 마련
- 트레이드 오프, 분석 결과도 문서화할 수 있음
    - 트레이드오프는 비용 기반일 수도 있고 다른 아키텍처 특성과의 트레이드오프일 수도 있음
- 트레이드오프 분석 등 아키텍처 결정 콘텍스트에 대한 전체 그림을 그려볼 수 있어 이슈를 예방할 수 있음
#### 컴플라이언스
- 표준 섹션은 아니지만 권장됨
- 컴플라이언스 관점에서 아키텍트가 아키텍처 결정을 어떻게 측정/관리하는 게 좋을지 생각하게 만듬
- 본인의 결정에 대한 컴플라이언스 체크를 수동으로 할지, 아니면 피트니스 함수로 자동화할지 결정해야 함
    - 피트니스 함수로 자동화할 수 있으면 피트니스 함수를 작성하는 방법
    - 컴픞파이언스 측면에서 아키텍처 결정을 판단하기 위해 코드베이스에 다른 변경은 필요 없는지 등이 내용을 이 섹션에 기재함
#### 노트
- 표준 섹션은 아니지만 가급적 추가하는 게 좋음
- ADR에 관한 다양한 메타데이터가 포함됨
    - 원저자
    - 승인일
    - 승인자
    - 대체일
    - 최종 수정일
    - 수정자
    - 최종 수정 내역
### 19.3.2 ADR 저장
- ADR은 어딘가에 저장, 위키 페이지도 가지고 있어야 함
- 소스 코드와 함께 git repository에 보관하는 것을 선호
- 버전 관리 및 추적은 편하지만, 몇 가지 주의할 점이 있음
    - 아키텍처 결정을 확인해야 하는데 어떤 이들은 git repository에 엑세슬 할 수 없는 경우가 있음
    - 애플리케이션 git repository를 벗어난 콘텍스트가 있는 ADR을 git에 저장하는 것은 적절하지 않음
- 위키 또는 다른 문서 렌더링 소프트웨어에서 쉽게 접근 가능한 공유 파일 서버의 공유 디렉터리에 저장하는 것이 좋음
### 19.3.3 ADR로 문서화
- 일부 아키텍처 도식화 표준이 있긴 하지만, 아직 소프트웨어 아키텍처 문서화 표준은 없음
- ADR은 소프트웨어 아키텍처를 효과적으로 문서화하는 수단으로 활용할 수 있음
### 19.3.4 ADR로 표준화
- ADR을 표준화하면 나쁜 관행이 바뀔 수 있음
- 결과 섹션은 어떤 표준이 타당하며 반드시 지켜야 하는지를 아키텍트 스스로 검증하기에 적합한 기회
