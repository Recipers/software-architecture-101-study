- 레이어드 아키텍처는 가장 흔한 아키텍터 스타일 중 하나이고, 단순하고 대중적이면서 비용도 적게 들어 모든 애플리케이션의 사실상 표준 아키텍처이다.
- UI 개발자, 백엔드 개발자, 규칙 개발자, DBA는 어느 회사건 있고, 이런 조직 계층 구조가 전통적인 레이어드 아키텍처와 잘 맞아떨어진다.
- 묵시적 아키텍처 안티패턴, 우발적 아키텍처 안티패턴등의 몇몇 아키텍처 안티패턴의 범주에 속한다.
# 10. 1 토폴로지
- 레이어드 아키텍처에서 내부 컴포넌트는 논리적으로 수평한 레이어들로 구성되며, 각 레이어는 애플리케이션에서 (프레젠테이션, 비즈니스 로직등) 주어진 역할을 수행한다
	- 레이어의 개수과 유형은 제한이 없지만 일반적으로 프레젠테이션, 비즈니스, 퍼시스턴스, 데이터베이스의 4개 표준 레이어로 구성된다
	- 퍼시스턴스 로직이 비즈니스 레이어 컴포넌트에 내장된 경우에는 퍼시스턴스 레이어를 비즈니스 레이어에 병합
	- 규모가 작은 애플리케이션은 3개, 덩치가 크고 복잡한 비즈니스 애플리케이션은 5개 또는 그 이상의 레이어로 구성
- 배포 관점에서 다양한 토폴로지 변형(배포)이 존재한다.
	- 프레젠테이션, 비즈니스, 퍼시스턴스 레이어를 단일 배포 단위로 합하고 데이터베이스 레이어는 별도로 분리된 물리적인 데이터베이스
	- 프레젠테이션 레이어를 자체 배포 단위로 떼어내고, 비즈니스 레이어와 퍼시스턴스 레이어를 두 번째 배포 단위로 합한 것
	- 모든 레이어를 단일 배포 단위로 뭉뚱그린 것 등등
- 각 레이어는 아키텍처 내부에서 특정한 역할과 임무를 수행한다.
	- 프레젠테이션 레이어는 모든 UI와 브라우저 통신 로직을 담당
	- 비즈니스 레이어는 요정을 받아 알맞은 비즈니스 규칙을 실행
	- 각 레이어는주어진 비즈니스 요청을 충족하는 데 필요한 업무 위주로 추상화되어 있음
		- 프레젠테이션 레이어는 고객 데이터를 조회하는 방법은 알 필요가 없고, 그럴 이유도 없음.
		- 비즈니스 레이어는 고객 데이터를 어디서 가져올지, 화면에는 어떻게 보여줄지 전혀 관여하지 않음
- 관심사의 분리 덕분에 아키텍처 내부의 역할 및 책임 모델을 효과적으로 구성할 수 있음.
	- 특정 레이어에 소속된 컴포넌트는 역할 범위가 한정되며 그 레이어에 알맞은 로직만 처리하면 됨
	- 개발자 본인의 기술 역량을 도메인의 (프레젠테이션 로직, 퍼시스턴스 로직 드으이) 기술적인 부분에 집중할 수 있음
	- 이런 장점을 대가로 전체적인 민첩성이 떨어지는 트레이드오프가 있음
- 레이어드 아키텍처는 기술 분할된 아키텍처이다. 즉, 컴포넌트를 고객 같은 도메인 단위로 묶는게 아니라 아키텍처의 기술 역할에 따라 묶기 때문에 비즈니스 도메인이 각각 모든 아키텍처 레이어에 분산된다.
	- 고객 도메인은 프레젠테이션, 비즈니스, 규칙, 서비스, 데이터베이스 모든 레이어에 다 포함되므로 고객 도메인에 변경을 가하는 일은 쉽지 않다.
	- 이런 이유로 레이어드 아키텍처는 DDD와는 잘 맞지 않는다
# 10.2 레이어 격리
- 레이어드 아키텍처의 각 레이어는 폐쇄 또는 개발 상태이다.
	- 폐쇄 레이어: 요청이 상위 레이어에서 하위 레이어로 이동하므로 중간의 어떤 레이어도 건너뛸 수 없음
	- 개방 레이어: 폐쇄 레이어와 반대로 중간 레이어를 건너뛸 수 있음(??? 책에 설명이 명시적으로 안되어 있음)
- 단순 조회 요청이라면 불필요한 레이어를 건너뛰고 프레젠테이션 레이어가 데이터베이스를 직접 액세스하는 편이 더 간편하다.
	- 이렇게 요청이 다른 레이어를 건너 뛸 수 있으려면 비즈니스 레이어, 퍼시스턴스 레이어는 개방되어 있어야 함
	- 폐쇄 레이어, 개방 레이어 어느쪽이 더 나을까? 질문에 답하려면 레이어 격리 개념을 이해해야 된다
	- (CQRS를 고려해도 좋을듯?)
- 레이어 격리는 어느 아키텍처 레이어에서 변경이 일어나서 다른 레이어에 있는 컴포넌트에 아무런 영향을 끼치지 않기에 레이어간 계약은 불변임을 의미한다.
	- 각 레이어는 서로 독립적이기 때문에 다른 레이어의 내부 작동 로직은 거의/전혀 알지 못한다.
	- 레이어 격리를 지원하려면 요청의 메인 흐름에 관한 레이어가 반드시 폐쇄되어 있어야 한다. 프레젠테이션 레이어가 퍼시스턴스 레이어에 직접 액세스할 수 있으면 퍼시스턴스 레이어에서 변경이 발생할 경우 비즈니스 레이어, 프레젠테이션 레이어 둘 다 영향을 받게 된다.
- 레이어를 격리하려면 모든 레이어를 다른 레이어에 영향을 주지 않고 교체할 수 있다
# 10.3 레이어 추가
- 아키텍처 내부적으로 폐쇄 레이어를 이용해 변경을 격리할 수 있지만 어떤 레이어는 개방하는게 더 합리적일 수 있다.
	- 비즈니스 레이어에 (날짜, 문자열 유틸리티 클래스, 감사 클래스, 로깅 클래스 등) 공통 비즈니스 기능이 구현된 객체를 구현하여 공유하고 프레젠테이션 레이어에서는 이 공유 객체를 직접 사용할 수 없도록 아키텍처 결정을 했을 때
		- 이 시나리오는 프레젠테이션 레이어가 비즈니스 레이어를 액세스할 수 있고, 그 내부의 공유 객체를 갖다 쓸 수 있는 지배/통제하기 어려운 아키텍처 구조이다
	- 이런 제약조건을 강제하려면 공유 비즈니스 객체가 모두 포함된 새로운 서비스 레이어를 아키텍처에 추가하면 된다.
		- 이렇게 하면 비즈니스 레이어는 폐쇄되어 있으니 아키텍처 구조상 프레젠테이션 레이어가 공유 비즈니스 객체를 직접 액세스할 수 없다
		- 그러나 새로 추가된 서비스 레이어는 개방 레이어로 설계해야 비즈니스 레이어가 퍼시스턴스 레이어를 액세스할 때 서비스 레이어를 뚫고 갈 수 있다.
- 개방/폐쇄 레이어 개념을 잘 활용하면 아키텍처 레이어 간 관계와 요청 흐름을 정의할 때 유용하다.
# 10.4 기타 고려 사항
- 아직 아키텍처 스타일을 결정하지 못했다면 대부분 레이어드 아키텍처는 좋은 출발점이 될 것이다.
	- 하지만 재사용은 최소한으로, 객체 계층은 최대한 가볍게 맞추어 적절한 모듈성을 유지하는 것이 중요하다.
- 레이어드 아키텍처는 아키텍처 싱크홀 안티패턴을 조심해야 된다.
	- 요청이 레이어를 이동할 때 각 레이어가 아무 비즈니스 로직도 처리하지 않고 그냥 통과시키는 안티패턴이다.
	- 유저가 기본 고객 데이터를 조회하는 단순 요청을 하면 프레젠테이션 레이어가 응답하는 아키텍처를 생각할 때 비즈니스 레이어 -> 규칙 레이어 -> 퍼시스턴스 레이어 -> 데이터베이스 레이어(단순 조회 SQL)을 실행한 이후 취합, 계산, 규칙 적용, 데이터 변환 등 일체의 로직 없이 다시 왔던 길을 거꾸로 돌아간다
	- 이런 흐름은 불필요한 객체 초기화 및 처리를 빈번하게 유발하고쓸데없이 메모리를 소모하여 성능에도 부정적인 영향을 끼친다
		- (이게 언급할 만한 성능 저하인가???)
		- (위에서 언급했듯이 CQRS를 고려해봐도 좋을듯)
- 전체 요청의 80%가 싱크홀이라면 레이어드 아키텍처는 적합한 아키텍처 스타일이 아니라는 증거이다.
	- 해결하는 또다른 방법은 모든 레이어를 개방하는 것이다.
# 10.5 왜 이 아키텍처 스타일을 사용하는가
- 레이어드 아키텍처는 작고 단순한 애플리케이션이나 웹사이트에 알맞은 아키텍처 스타일
- 레이어드 아키텍처 기반의 애플리케이션은 규모가 커질수록 유지 보수성, 민첩성, 시험성, 배포성 같은 아키텍처 특성이 점점 나빠짐
	- 따라서 대규모 애플리케이션이나 시스템은 다른 더 모듈러한 아키텍처 스타일이 더 적합
# 10.6 아키텍처 특성 등급

| 아키텍처 특성 | 별점    |
| ------- | ----- |
| 분할 유형   | 기술    |
| 퀀텀 수    | 1     |
| 배포성     | ⭐     |
| 탄력성     | ⭐     |
| 진화성     | ⭐     |
| 내고장성    | ⭐     |
| 모듈성     | ⭐     |
| 전체 비용   | ⭐⭐⭐⭐⭐ |
| 성능      | ⭐⭐    |
| 신뢰성     | ⭐⭐⭐   |
| 확장성     | ⭐     |
| 단순성     | ⭐⭐⭐⭐⭐ |
| 시험성     | ⭐⭐    |
- 전체 비용과 단순성은 레이어드 아키텍처의 주요 강점임.
	- 원래 모놀리식에 가깝기 때문에 분산 아키텍처 스타일에 따른 복잡도가 낮고, 구조가 단순해서 알기 쉬운데다 구축 및 유지보수 비용도 비교적 적게 듦
	- 점점 커지고 결과적으로 더 복잡해질수록 이런 장점들도 빛을 바램
- 배포성과 시험성 별점이 매우 낮음. 배포를 하려면 절차가 까다롭고 리스크가 높으면 자주 배포할 수 없기 때문에 배포성이 떨어짐
	- 클래스 파일 3줄 정도의 간단한 변경에도 전체를 다시 배포해야 하고 데이터베이스 변경, 구성 변경이 수반될 수 있으며 다른 코드도 함께 고쳐야 될 수 있다
		- 이 단순한 3줄짜리 변경은 보통 수십가지 다른 변경들 속에 파묻혀 배포 리스크가 한층 더 가중된다.
	- 시험성도 낮다. 코드 3줄만 고치면 되는데 전체 회귀 테스트 스위트를 작성해서 실행해야 된다.
- 분산 아키텍처에서의 네트워크 트래픽, 대역폭, 레이턴시 문제는 덜 하므로 신뢰성은 보통으로 매김. 하지만 모놀리식 배포 속성상 시험성과 배포 리스크 측면에서 점수가 떨어짐
- 모놀리식 배포와 아키텍처 픅면에서의 모듈성이 부족하므로 탄력성과 확장성은 점수가 낮다
	- 내부 기능 중에는 상대적으로 확장이 가능한 것들도 있지만 그렇게 확장하려면 멀티 스레딩, 내부 메시징을 비롯해 이 아키텍처와는 안얼루니는 몇가지 병렬 처리 프랙티스와 기법이 동원된다.
	- 그러나 레이어드 아키텍처는 언제나 단일 시스템 퀀텀이므로 단일 퀀텀을 기반으로 특정 지점까지만 확장이 가능
- 이 아키텍처 스타일은 병렬 처리가 거의 안되고, 폐쇄적인 레이어 구조와 싱크홀 아키텍처 안티패턴 때문에 고성능 시스템에 어울리지 않기 때문에 별점을 2개 줌
- 모놀리식 배포 탓에, 부족한 모듈성 때문에 내고장성도 별로이다.
	- 어느 한 작은 파트에 OOM이 발생하면 애플리케이션 전체적으로 영향을 받고 충돌이 발생한다.
	- 대부분의 모놀리식 애플리케이션이 겪는 MTTR(평균 수리 시간) 때문에 전체 가용성도 영향을 받는다.
