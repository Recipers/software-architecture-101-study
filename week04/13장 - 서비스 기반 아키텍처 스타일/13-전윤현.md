- 서비스 기반 아키텍처는 마이크로서비스 아키텍처 스타일의 일종이다.
  - 유연해서 가장 실용적인 아키텍처 스타일 중 하나이다.
  - 마이크로서비스나 이벤트 기반 아키텍처와 마찬가지로 분산 아키텍처지만 비교적 덜 복잡하고 비용이 많이 들지 않는다.

# 13.1 토폴로지

<img width="621" alt="스크린샷 2025-06-05 오전 6 54 12" src="https://github.com/user-attachments/assets/101a7630-0258-482a-8a42-02bc54146f67" />

- 서비스 기반 아키텍처의 기본 토폴로지는 각각 따로 배포된 UI와 원격 서비스, 모놀리스 DB로 이루어진 대규모 분산 레이어 구조이다.
- 서비스는 큼지막한 단위로 분리해 별도로 배포하는 '애플리케이션의 일부'이다. (보통 도메인 서비스로 불림)
  - 서비스를 배포하는 방식 자체는 여느 모놀리식 애플리케이션과 동일하므로 컨테이너화가 필수는 아니다.
  - 여러 서비스가 단일 모놀리식 DB를 공유하므로 애플리케이션 서비스를 다 합해도 4~12개, 평균 7개 정도이다.
- 도메인 서비스는 각각 단일 인스턴스로 배포하지만 확장성, 내고장성, 처리량 요구사항에 따라 인스턴스를 여럿 둘 수 있다.
  - 서비스 인스턴스를 다수 생성하여 배포하려면 UI로 유입된 요청이 가용한 서비스 인스턴스로 흘러갈 수 있도록 UI와 도메인 서비스 간의 부하 분산 기능이 필요하다.
- 서비스는 원격 액세스 프로토콜로 유저 인터페이스 외부에서 접속할 수 있다. 프로토콜은 일반적으로 REST를 많이 쓴다.
  - 메시징, 원격 프로시절 호출, SOAP도 사용 가능하다.
  - 유저 인터페이스는 프록시나 게이트웨이로 구성된 API 레이어를 통해 서비스에 접속할 수 있지만 대개는 서비스 로케이터 패턴에 따라 유저 인터페이스, API, 게이트웨이, 프록시에 내장된 유저 인터페이스를 직접 액세스한다.
- 중앙 공유 데이터베이스를 사용한다는 특징이 중요하다. 따라서 서비스는 기존 모놀리식 레이어드 아키텍처와 동일한 방식으로 SQL 쿼리와 조인 기능을 사용할 수 있다.
  - 데이터베이스 자체의 변경은 이슈가 될 수 있다.

# 13.2 토폴로지 변형

<img width="600" alt="스크린샷 2025-06-05 오전 7 00 47" src="https://github.com/user-attachments/assets/d4dd4853-6ef1-41f1-89a7-afd37193ada6" />

- 서비스 기반 아키텍처 스타일은 특유의 유연성 때문에 다양한 변형이 존재한다.
  - 단일 모놀리식 유저 인터페이스는 다시 여러 유저 인터페이스 도메인으로 나눌 수 있고, 각 도메인 서비스에 맞게 나눌 수도 있다.

<img width="612" alt="스크린샷 2025-06-05 오전 7 03 16" src="https://github.com/user-attachments/assets/326c9269-a541-46e6-a96b-e05177d7a4cd" />

- 단일 모놀리식 데이터베이스 역시 개별 데이터베이스로 분리할 수 있다(마이크로서비스와 비슷하게) 각 도메인 서비스 전용 데이터베이스들로 쪼갤 수도 있다.
  - 중요한 점은 각 데이터베이스에 있는 도메인 데이터를 다른 도메인의 서비스가 필요로 하지 않도록 설계해야 된다. 이래야 도메인 서비스 간 상호 통신을 방지하고 데이터베이스 간의 중복 데이터를 방지할 수 있다.

<img width="620" alt="스크린샷 2025-06-05 오전 7 03 46" src="https://github.com/user-attachments/assets/d2d15404-5965-45d4-97e6-4a21cbecbbaa" />

- 리버스 프록시 또는 게이트웨이로 구성된 API 레이어를 유저 인터페이스와 서비스 사이에 구성할 수 있다.
  - 도메인 서비스의 기능을 외부 시스템에 표출하거나(메트릭, 보안, 감사 요구사항, 서비스 디스커버리 등) 공통 관심사를 통합해서 유저 인터페이스 밖으로 떼어낼 경우에도 유용하다

# 13.3 서비스 설계 및 세분도

<img width="585" alt="스크린샷 2025-06-05 오전 7 06 29" src="https://github.com/user-attachments/assets/020b61b7-89b8-47c9-ae4d-1c426325d029" />

- 도메인 서비스는 보통 단위가 크기 때문에 도메인 서비스를 API 퍼사드 레이어, 비즈니스 레이어, 퍼시스턴스 레이어로 구성된 레이어드 아키텍처로 설계하는 것이 일반적이다.
  - 모듈러 모놀리스 아키텍처 스타일처럼 서브도메인을 이용해서 각 도메인 서비스를 분할하는 방법도 많이 쓰인다.
- 도메인 서비스는 유저 인터페이스에서 비즈니스 기능을 호출하기 위해 접속할 일종의 API 액세스 퍼사드가 필요하다.
  - API 액세스 퍼사드는 유저 인터페이스를 통해 유입된 비즈니스 요청을 오케스트레이트 하는 역할을 한다.
    - 예를 들어, 유저 인터페이스에서 주문이 접수되면 단건 요청은 OrderService 도메인 서비스의 API 액세스 퍼사드가 받아 내부에서 주문 처리, 주문 ID 생성, 결제 처리를 한 후, 주문이 완료된 제품별 재고 정보를 업데이트하는 일련의 비즈니스 요청을 오케스트레이트 한다.
    - 마이크로서비스 아키텍처에서 한다면 별도 배포된 다수의 전용 원격 서비스를 오케스트레이트해야 한다. 내부 클래스 수준의 오케스트레이션과 외부 서비스의 오케스트레이션이라는 차이점이 서비스 기반 아키텍처와 마이크로서비스의 중요한 차이점이다.
- 도메인 서비스는 세분도가 큰 까닭에 단일 도메인 서비스에서 데이터 무결성을 보장하기 위해 커밋/롤백이 수반되는 ACID 데이터베이스 트랜잭션을 사용한다
  - 마이크로서비스처럼 분산도가 높은 아키텍처는 서비스를 더 잘게 나누어 BASE 트랜잭션이라고 알려진 분산 트랜잭션 기법을 사용한다. 이 기법은 기반이 최종 일관성이므로 서비스 기반 아키텍처의 ACID 트랜잭션 레벨의 데이터 무결성은 지원하지 않는다.
- 도메인 서비스는 단위가 커서 데이터 무결성과 일관성 측면에서는 유리하지만 그에 못지 않은 트레이드오프도 있다.
  - 서비스 기반 아키텍처에서 특정 기능을 변경할 일이 생기면 전체 서비스를 테스트해야 하지만, 마이크로서비스 아키텍처에서는 규모가 더 작은 서비스 하나만 변경 영향도가 있을 것이다.
  - 또한 코드가 점점 더 많이 배포될 수록 서비스 기반 아키텍처는 뭔가 문제를 일으킬 소지가 커지지만, 마이크로서비스 아키텍처는 각 서비스가 한 가지 역할만 수행하므로 다른 기능이 망가질 일이 거의 없다.
 
# 13.4 데이터베이스 분할
- 서비스 기반 아키텍처 서비스는(반드시 그래야 하는 건 아니지만) 주어진 애플리케이션 컨텍스트에서 서비스 수(4~12개)가 적은 편이여서 보통 단일 모놀리식 데이터베이스를 공유한다.
  - 이러한 데이터베이스 커플링은 테이블 스키마 변경 시 문제가 될 수 있다. 테이블 스키마를 올바르게 변경하지 않을 경우 모든 서비스에 악영향을 미친다.

<img width="589" alt="스크린샷 2025-06-05 오전 7 19 47" src="https://github.com/user-attachments/assets/87faad49-1724-47a8-ae43-94a0abdc27ec" />

- 서비스 기반 아키텍처에서 데이터베이스 테이블 스키마를 나타낸 공유 클래스 파일(엔티티 객체라고도 함)은 전체 도메인 서비스가 함꼐 사용하는 커스텀 공유 라이브러리에 둔다.
  - 이 프랙티스는 서비스 기반 아키텍처 관점에서 가장 비효율적인 구현 방법이다. 테이블 구조를 조금이라도 변경할 일이 발생하면 해당 엔티티 객체가 포함된 단일 공유 라이브러리도 같이 변경해야 하는데, 변경된 테이블의 사용 여부와 상관 없이 전체 서비스를 일제히 변경 후 재배포 할 수 밖에 없다.

<img width="590" alt="스크린샷 2025-06-05 오전 7 22 13" src="https://github.com/user-attachments/assets/8746081b-46e0-4c0a-aa70-849364d162e7" />

- 데이터베이스 변경 영향도와 리스크를 낮추는 한 가지 방법은 데이터베이스를 논리적으로 분할하는 것이다.
- 그림 13-7에서 모든 서비스는 공통 도메인과 이 도메인에 해당되는 공유 라이브러리를 함께 사용한다.
  - 모든 서비스의 공통 테이블을 변경하려면 먼저 공유 데이터베이스를 액세스하는 전체 서비스를 미리 조유해야 한다.
  - 테이블과 해당 엔티티 객체의 변경 영향도를 낮추는 한 가지 방법은 공통 엔티티 객체를 버전 관리 시스템에서 잠그고, 수정 권한을 오직 데이터베이스 팀에게만 부여하는 것이다.

# 13.5 아키텍처 예시
- 서비스 기반 아키텍처의 유연함과 강점을 전자 제품 재활용 시스템을 예로 들어 설명한다.
  - 중고 전자 제품의 재활용 처리 프로세스
    - 고객이 회사에 연락하여 자신이 소유한 중고 제품을 얼마에 보상받을 수 있는지 문의한다 (견적)
    - 고객이 보상가에 만족하면 회사에 제품을 보내고 회사는 실무을 받는다 (수취)
    - 재활용 회사는 고객이 보낸 제품의 작동 상태를 꼼곰히 평가한다 (감정)
    - 제품 상태가 좋을 경우 회사는 고객에게 약속한 보상가를 지불한다 (회계)
    - 이 과정 중 언제라도 고객은 회사 웹사이트에 접속해서 진행 상황을 확인할 수 있다 (제품 상태)
    - 감정 결과에 따라 제품은 안전하게 해체 후 재활용되거나 재판매 된다 (재활용)
    - 회사는 재활용 성과에 따른 임시/정기 재무 리포트를 정기적으로 체크한다 (리포팅)

<img width="573" alt="스크린샷 2025-06-05 오전 7 29 06" src="https://github.com/user-attachments/assets/55105db7-abec-4827-8127-bd7cb52e0eef" />

- 그림 13-8은 전자 제품 재활용 시스템을 서비스 기반 아키텍처로 설계한 것이다.
  - 각 도메인 영역을 개별 배포되는 독립적인 도메인 서비스로 구현했다.
  - 높은 처리량이 필요한 서비스만 확장하면 되므로 확장성도 충족된다.
- 유저 인터페이스 애플리케이션이 각 도메인(견적, 수취, 재활용, 회계)과 잘 연합되어 있다.
  - 이 덕분에 유저 인터페이스의 내고장성, 확장성, 보안(외부 고객은 내부 기능으로 향하는 네트워크 접속 불가)이 실현된다
  - 데이터베이스를 외부 고객 처리용 데이터베이스와 내부 처리용 데이터베이스로 물리적으로 분할
    - 내부 데이터와 기능을 외부 작업과 분리된 별도의 네트워크 영역에 두는 것이 데이터 보안상 바람직하다
    - 방화벽을 통해 단방향으로 접근하면 내부 서비스는 고객 정보를 조회/수정할 수 있지만 그 반대는 불가능하다
    - 데이터베이스에 따라 내부 테이블을 미러링하고 테이블을 동기화하는 방법이 있다

# 13.6 아키텍처 등급

| 아키텍처 특성 | 별점 |
|-------------|------|
| 분할 유형 | 도메인 |
| 퀀텀 수 | 하나 또는 여러 개 |
| 배포성 | ⭐⭐⭐⭐ |
| 탄력성 | ⭐⭐ |
| 진화성 | ⭐⭐⭐ |
| 내고장성 | ⭐⭐⭐⭐ |
| 모듈성 | ⭐⭐⭐⭐ |
| 전체 비용 | ⭐⭐⭐⭐ |
| 성능 | ⭐⭐⭐ |
| 신뢰성 | ⭐⭐⭐⭐ |
| 확장성 | ⭐⭐⭐ |
| 단순성 | ⭐⭐⭐ |
| 시험성 | ⭐⭐⭐⭐ |

- 서비스 기반 아키텍처는 도메인 분할된 아키텍처이다. 즉, 기술 관심사보다 도메인을 위주로 구성된 아키텍처이다.
  - 각 서비스는 별도 배포되는 소프트웨어 단위로서 그 범위가 특정 도메인으로(품목 감정 같은) 한정된다

<img width="614" alt="스크린샷 2025-06-05 오전 7 39 48" src="https://github.com/user-attachments/assets/f79d953f-f64c-4268-8e68-71fda1fac2df" />

- 이 아키텍처는 분산 아키텍처이므로 퀀텀은 하나 또는 그 이상일 것이다.
  - 개별 배포된 서비스가 4~12개라도 이들 모두가 동일한 데이터베이스나 유저 인터페이스를 공유할 경우 전체 시스템의 퀀텀은 1이다.
  - 유저 인터페이스와 데이터베이스는 연할 될 수 있으므로 전체 시스템 내부에 여러 퀀텀이 생길 수 있다. 실제로 그림 13-10을 보면 전자 제품 재활용 시스템의 퀀텀은 2이다.
- 서비스 기반 아키텍처는 별점 5개짜리 특성은 하나도 없지만 별점을 높게 받은 중요한 영역들이 많다.
  - 애플리케이션을 개별 배포되는 여러 도메인 서비스로 나누면 신속한 변경이 가능하다(민첩성)
  - 도메인 범위가 한정되므로 테스트 커버리지가 향상된다(시험성)
  - 덩치큰 모놀리스보다 덜 위험하게, 더 자주 배포할 수 있다(배포성)
  - 이 세가지 특성 덕분에 시장 출시를 앞당겨 신기능을 더 빨리 출시하고 신속하게 버그를 조치할 수 있다
- 내고장성과 전체 애플리케이션 가용성도 별점이 높다.
  - 도메인 서비스는 보통 굵직굵직하게 나누지만 서비스 기반 아키텍처의 서비스는 보통 자기 완비형이고 데이터베이스 코드를 공유하는 까닭에 서비스간 통신이 거의 없으므로 별점 4개이다.
  - 따라서 어느 도메인 서비스가 잘못돼도 다른 6개 서비스는 아무 영향도 받지 않는다.
- 확장성은 서비스를 나누는 단위가 크기 때문에 별점 3개이고, 그에 따라 탄력성도 별점 2개이다.
  - 프로그램 방식으로 확장성/탄력성을 추구할 수 있지만 (마이크로서비스처럼) 서비스를 잘게 나누는 것 보다 중복되는 기능이 많아 머신 리소스 및 비용 측면에서 별로 효율적이지 않다.
  - 처리량이나 페일오버를 개선해야 하는 요건이 따로 없다면 서비스 인스턴스는 딱 하나만 있다.
    - 전자 제품 재활용 애플리케이션을 예를 들면 다수의 고객을 처리하려면 견적 및 품목 상태 서비스는 확장이 필요하지만, 그 밖의 서비스는 단일 인스턴스로도 충분하며 단일 인메모리 캐시, 데이터베이스 커넥션 풀링 지원이 더 간편하다
- 단순성과 전체 비용 측면에서 마이크로서비스, 이벤트 기반 아키텍처, 공간 기반 아키텍처 등 비교적 비용이 많이 들고 복잡한 아키텍처와는 차별화된다.
  - 서비스 기반 아키텍처는 가장 구현하기 쉽고 비용면에서도 효율적인 분산 아키텍처라는 매력이 있다.
  - 별점 4개를 받은 모든 아키텍처 특성에서 비용 절감 및 단순함의 트레이드오프가 수반된다. 비용이 더 들고 더 복잡해질수록 이러한 특성들의 등급은 올라간다.
- 도메인 서비스를 굵직하게 나누기 때문에 다른 분산 아키텍처에 비해 신뢰성이 우수하다. 대규모 서비스는 서비스간 네트워크 트래픽이 적고 대역폭을 덜 사용하며, 분산 트랜잭션이 많지 않다.

# 13.7 언제 이 아키텍처 스타일을 사용하는가

- 서비스 기반 아키텍처는 별점 서너 개를 받은 아키텍처 특성과 결부된 아키텍처 스타일의 유연성 덕분에 어쩌면 가장 실용적인 아키텍처이다.
- 도메인 주도 설계와 궁합이 잘 맞는다. 서비스를 큰 단위로 나누고 그 범위를 도메인으로 한정하기 때문에 각 도메인은 개별 배포된 도메인 서비스에 딱 맞아떨어진다.
  - 서비스 기반 아키텍처의 서비스는 각각 지정된 도메인을 포함하므로 그 기능을 단일 소프트웨어 단위로 구분하면 해당 도메인을 더 쉽게 변경할 수 있다
- 분산 아키텍처에서는 데이터베이스 트랜잭션을 관리/조율하는 일이 늘 고칫거리이다. 전통적인 ACID 트랜잭션이 아닌, 최종 일관성에 의존하는 방식으로 수행되기 때문이다.
  - 서비스 기반 아키텍처의 도메인 서비스는 큼지막한 단위로 구성되므로 ACID 트랜잭션이 비교적 더 잘 보존된다.
  - 유저 인터페이스나 API 게이트웨이가 둘 이상의 도메인 서비스를 오케스트레이션 해야 될 경우 트랜잭션이 사가와 BASE 트랜잭션에 의존해야 된다.
  - 그러나 대부분 트랜잭션은 특정 도메인 서비스에 한정되므로 전통적인 커밋//롤백 트랜잭션을 그대로 가능하다.
- 서비스 기반 아키텍처는 복잡하게 뒤얽히거나 세분도의 함정에 빠져 허우적거리지 않고도 아키텍처 모듈성을 괜찮은 수준으로 달성할 수 있다.
  - 서비스를 더 잘게 나눌수록 오케스트레이션 및 코레오그래피 관련 이슈가 발생한다. 여러 서비스를 조율해서 비즈니스 트랜잭션을 완성하려면 오케스트레이션과 코레오그래피 둘 다 필요하다.
    - 오케스트레이션은 트랜잭션의 워크플로를 제어/관리하는 중재자 서비스를 따로 두고 여러 서비스를 조율하는 기법이다.
    - 코레오그래피는 각 서비스가 중앙의 중재자 없이 서로가 알아서 소통하는 방식이다.
  - 서비스가 더 잘개 쪼개지면 비즈니스 트랜잭션을 완성하기 위해 서비스를 서로 단단히 묶어주는 오케스트레이션과 코레오그래피가 필요하다.
  - 서비스 기반 아키텍처의 서비스는 더 큰 단위로 분할되기 때문에 다른 분산 아키텍쳐만큼 정교한 조율은 필요하지 않다.
