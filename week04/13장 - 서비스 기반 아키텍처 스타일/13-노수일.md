# 13. 서비스 기반 아키텍처 스타일
- 마이크로서비스 아키텍처 스타일의 일종
- 아키텍처가 유연해서 가장 실용적인 아키텍처 스타일 중 하나
- 마이크로서비스나 이벤트 기반 아키텍처와 마찬가지로 분산 아키텍처지만 비교적 덜 복잡하고 비용이 많이 들지 않아서 비즈니스 관련 애플리케이션에 널리 채택
## 13.1 토폴로지
- 각각 따로 배포된 유저 인터페이스와 원격 서비스, 모놀리스 데이터베이스로 이루어지느 대규모 분산 레이어 구조
- 서비스는 큰 단위로 분리해 별도로 배포하는 애플리케이션의 일부
- 배포 방식 자체는 모놀리식 애플리케이션과 동일하므로 컨테이너화가 필수는 아님
- 여러 서비스가 단일 모놀리식 데이터베이스를 공유
- 도메인 서비스는 각각 단일 인스턴스로 배포하지만, 확장성, 내고장성, 처리량 요구사항에 따라 인스턴스를 여럿 둘 수 있음
- 서비스 인스턴스를 다수 생성하여 배포하려면 유저 인스턴스로 유입된 요청이 가용한 서비스 인스턴스로 흘러갈 수 있도록 부하 분산 기능이 필요
- 서비스는 원격 엑세스 프로토콜로 유저 인터페이스 외부에서 접속할 수 있음
    - REST
    - 메시징
    - 원격 프로시저 호출 (RPC)
    - SOAP
- 유저 인터페이스는 프록시나 게이트웨이로 구성된 API 레이어를 통해 서비스에 접속할 수 있음
    - 대개는 서비스 로케이터 패턴에 따라 유저 인터페이스, API 게이트웨이, 프록시에 내장된 유저 인터페이스를 직접 엑스사함
- 중앙 공유 데이터베이스를 사용한다는 특징이 중요함
- 기존 모놀리식 레이어드 아키텍처와 동일한 방식으로 SQL 쿼리, 조인 기능 사용
- 서비스 개수가 적어서 DB 커넥션은 대개 문제가 안 되지만, DB 자체의 변경은 이슈가 될 수 있음
## 13.2 토폴로지 변형
- 특유의 유연성 때문에 다양한 변형이 존재함
- 유저 인터페이스 변형
    - 단일 모놀리식 유저 인터페이스
    - 여러 유저 인터페이스
    - 각 도메인에 맞는 유저 인터피에스
- 데이터 베이스 변형
    - 단일 모놀리식 데이터 베이스
    - 개별 데이터베이스 분리
    - 각 도메인 서비스 전용 데이터베이스
        - 각 데이터베이스에 있는 도메인 데이터를 다른 도메인 서비스가 필요로 하지 않도록 설계해야함
        - 도메인 서비스간 상호 통신을 방지하고 데이터베이스간 중복 데이터 방지
- 리버스 프록시 또는 게이트웨이로 구성된 API 레이어를 유저 인터페이스와 서비스 사이에 구성할 수도 있음
    - 도메인 서비스의 기능을 외부 시스템에 표출
    - 공통 관심사(메트릭, 감사 요구사항, 서비스 디스커버리 등)를 통합해서 유저 인터페이스 밖으로 떼어낼 경우 유용함
## 13.3 서비스 설계 및 세분도
- 보통 단위가 크기 떄문에 도메인 서비스를 각 API 퍼사드 레이어, 비즈니스 레이어, 퍼시스턴스 레이어로 구성된 레잉드 아키텍처 스타일로 설게하는 것이 일반적
- 모듈러 모놀리스 아키텍처 스타일처럼 서브도메인을 이용해서 각 도메인 서비스를 분할하는 방법도 많이 쓰임
- 도메인 서비스는 유저 인터페이스에서 비즈니스 기능을 호출하기 위해 접속할 일종의 API 액세스 퍼사드를 필요로 함
- API 액세스 퍼사드
    - 유저 인터페이스를 통해 유입된 비즈니스 요청을 오케스트레이트 하는 역할을 함
    - 어떤 요청을 마잍크로서비스 아키텍처에서 처리한다고 하면, 
    - 주문 시스템에서 주문 처리, ID 생성, 결제 처리를 한후 주문 완료된
- 별도 배포된 다수의 전용 원격 서비스를 오케스트레이트해야함
- 내부 클래스 수준의 오케스트레이션과 외부 서비스의 오케스트레이션이라는 차이점이 서비스 기반 아키텍처와 마이크로서비스의 중요한 차이점
- 도메인 서비스는 세분도가 커서 단일 도메인 서비스에서 데이터 무결성을 보장하기 위해 커밋/롤백이 수반되는 ACID DB 트랜잭션을 사용
- 마이크로서비스처럼 분산도가 높은 아키텍처는 서비스를 더 잘게 나누어 BASE 트랜잭션이라고 알려진 분산 트랜잭션 기법을 이용
- ACID 트랜잭션 레벨의 데이터 무결성은 지원하지 않음
- 주문 처리 서비스 기반 아키텍처
    - 고객이 주문을 하고 결제 화면에서 만료된 신용카드를 사용해서 결제했다면
    - 동일한 서비스 내부에서 발생한 원자적 트랜잭션이니 추가된 데이터는 롤백해서 삭제
- 주문 처리 마이크로서비스 아키텍처
    - OrderPlacement 서비스는 주문을 접소/생성하고 주문 ID를 채번한 다음 order 테이블에 데이터 삽입
    - 모든 작업이 끝나면 PaymentService를 원격 호출
    - 신용카드 유효 기간이 만료됐으므로 결제 불가, 주문 처리를 진행할 수 없음
    - 데이터가 비일관된 상태가 되어버림
- 도메인 서비스는 단위가 커서 데이터 무결성과 일관성 측면에서는 유리하지만, 트레이드오프도 있음
    - OrderPlacement 주문 처리 변경 시 전체 서비스를 테스트 해야됨
    - 코드가 많이 배포될 수록 문제를 일으킬 소지가 커짐
## 13.4 데이터베이스 분할
- 서비스 기반 아키텍처의 서비스는 애플리케이션 콘텍스트에서 서비스 수가 적은 편이라서 단일 모놀리식 데이터베이스를 공유함
- 데이터베이스 커플링은 스키마 변경 시 문제가 될 수 있음
- 데이터베이스 테이블 스키마를 나타낸 공유 클래스 파일은 전체 도메인 서비스가 함께 사용하는 커스텀 공유 라이브러리에 둠
- 테이블 구조 변경 시 엔티티 객체가 포함된 라이브러리도 변경해야하고, 전체 서비스를 재배포해야됨
- 어느 서비스가 테이블 변경에 영향을 받을지를 미치 예측하기는 어려움
- 데이터베이스 변경 영향도와 리스크를 낮추는 방법은 데이터베이스를 논리적으로 분할하고 논리 분할을 연합 공유 라이브러리를 통해 명시하는 것
- 데이터베이스를 5개의 개별 도메인으로 논리 분할하고 도메인 서비스마다 논리 분할한 데이터베이스를 바라보는 전용 공유 라이브러리를 둔 구조
- 공통 엔티티 객체를 버전 관리시스템에서 락킹하고 수정 권한을 오직 데이터베이스 팀에게만 부여
## 13.5 아키텍처 예시
- 전자제품 재활용 시스템
    - 고객이 회사에 연락하여 자신이 소유한 중고 제품을 얼마에 보상받을수 있는지 문의 (견적)
    - 고객이 보상가에 만족하면 회사에 제품을 보내고 회사는 실물을 받음 (수취)
    - 재활용 회사는 고객이 보낸 제품의 작동 상태를 평가 (감정)
    - 제품 상태가 좋을 경우 고객에게 약속한 보상가를 지불 (회계)
    - 고객은 웹 사이트에서 진행 상황 확인 가능 (제품 상태)
    - 감정 결과에 따라 제품은 안전하게 해체 후 재활용되거나 재판매됨 (재활용)
    - 재활용 성과에 따른 임시/정기 재무 리포트를 체크 (리포팅)
- 열거된 각 도메인 영역을 개별 배포되는 독립적인 서비스로 구현
- 높은 처리량이 필요한 서비스만 확장하면 되므로 확장성 충족
- 유저 인터페이스 애플리케이션이 각 도메인과 잘 연합
    - 내고장성, 확장성, 보안이 실현됨
- 민첩성, 시험성, 배포성, 확장성, 내고장성, 보안 등 서비스 기반 아키텍처의 많은 장점을 실감할 수 있음
## 13.6 아키텍처 특성 등급
- 도메인 분할된 아키텍처
    - 기술 관심사보다 도메인을 위주로 구성된 아키텍처
    - 도메인 변경 시 해당 서비스, 해당 유저 인터페이스만 영향을 받음
- 분산 아키텍처이므로 퀀텀은 하나 또는 그 이상
- 서비스 기반 아키텍처는 별점 5개 짜리 특성은 하나도 없지만 별점을 높게 받은 중요한 영역들이 많음
- 개별 배포되는 도메인 서비스로 나누면
    - 신속한 변경 가능 (민첩성)
    - 테스트 커버리지가 향상 (시험성)
    - 덜 위험하게, 더 자주 배포할 수 있음 (배포성)
- 내고장성과 전체 애플리케이션 가용성도 별점이 높음
    - 어느 도메인 서비스가 잘못돼도, 다른 서비스는 영향이 없음
- 확장성은 서비스를 나누는 단위가 크기 때문에 별점 3개, 그에 따라 탄력성은 별점 2개
- 리소스 및 비용 측면에서는 별로 효율적이지 않음
- 단순성과 전체 비용 측면에서 비교적 미용이 많이 들고 복잡한 분산 아키텍처와는 차별화됨
- 가장 구현하기 쉽고 효율적인 분산 아키텍처
- 도메인 서비스를 굵직굵직하게 나누기 때문에 신뢰성이 우수함
    - 서비스 간 네트워크 트래픽이 적고 대역폭을 덜 사용
    - 분산 트랜잭션이 많지 않음
## 13.7 언제 이 아키텍처 스타일을 사용하는가
- 아키텍처 스타일의 유연성 덕분에 가장 실용적인 아키텍처
- 도메인 주도 설계와 궁합이 잘 맞음
    - 서비스를 큰 단위로 나누고 그 범위를 도메인으로 한정하기 때문에 각 도메인은 개별 배포된 도메인 서비스에 딱 맞아떨어짐
- 분산 아키텍처에서는 데이터베이스 트랜잭션을 관리/조율 하는 일이 어려움
    - 전통적인 ACID 트랜잭션이 아닌, 최종 일관성에 의존하는 방식으로 수행되기 때문
- 서비스 기반 아키텍처의 도메인 서비스는 큰 단위로 구성되므로 다른 분산 아키텍처에 비해 ACID 트랜잭션이 잘 보존됨
- 유저 인터페이스나 API 게이트웨이가 둘 이상의 도메인 서비스를 오케스트레이션 하는 경우도 있음
    - 트랜잭션이 사가와 BASE 트랜잭션에 의존해야 함
    - 대부분 트랜잭션은 특정 도메인 서비스에 한정됨
- 서비스 기반 아키텍처는 복잡하게 뒤얽히거나 세분도의 함정에 빠져 허우적 거리지 않고 아키텍처 모듈성을 괜찮은 수준으로 달성할 수 있음
- 서비스를 더 잘게 나눌수록 오케스트레이션 및 코레오그래피 관련 이슈가 발생
    - 오케스트레이션
        - 트랜잭션의 워크플로를 제어/관리하는 중재자 서비스를 따로 두고 여러 서비스를 조율하는 기법
    - 코레오그래피
        - 각 서비스가 중앙의 중재자 없이 서로 알아서 소통하는 방식
- 서비스 기반 아키텍처의 서비스는 다른 분산 아키텍처만큼 정교한 조율은 필요하지 않음
