- 파이프라인 아키텍처 (파이프와 필터 아키텍처라고도 함)는 소프트웨어 아키텍처에서 끊임없이 등장하는 기본적인 아키텍처 스타일이다.

# 11.1 토폴로지
<img width="439" alt="스크린샷 2025-06-04 오전 4 38 28" src="https://github.com/user-attachments/assets/51d881f4-9bb6-4a99-a011-c729901739c8" />

- 파이프라인 아키텍처는 다수의 파이프와 필터로 구성된다.
- 파이프와 필터는 특정한 방식으로 조정되며 보통 필터 간 단방향 통신은 점대점 방식으로 구성한다

### 11.1.1 파이프
- 파이프는 한 소스에서 입력을 받아 다른 소스로 출력을 내는 필터간 통신 채널이다.
  - 성능상 이유로 보통 단방향, 점대점 방식으로 구성된다.
  - 페이로드의 데이터는 어떤 포맷이라도 가능하지만 고성능에 유리한 적은 양의 데이터를 선호

### 11.1.2 필터
- 필터는 자기 완비형(다른 서비스나 모듈 등을 호출하지 않아도 스스로 동작), 다른 필터와 독립적이며, 일반적으로 무상태성(stateless)이다.
  - 한 가지 태스크만 수행하므로 복합 태스크는 여러 필터를 이어 붙여 처리하면 된다
- 파이프라인 아키텍처 스타일에서 필터는 다음 네 가지 종류가 있다.
  - 프로듀서
    - 프로세스의 시작점. 아웃바운드만 있어서 소스라고도 함 (들어오는 트래픽은 없고 나가는 트래픽만 있음)
  - 변환기
    - 입력을 받아 필요시 일부 또는 전체 데이터를 변환한 후 그 결과를 아웃바운드 파이프로 전달. 함수형의 map으로 볼 수 있음
  - 테스터
    - 입력을 받아 하나 이상의 기준에 대해 테스트를 하고 그 결과에 따라 필요시 결과를 생산. 함수형의 reduce로 볼 수 있음
  - 컨슈머
    - 파이프라인 흐름의 종착역. 컨슈머는 파이프라인 프로세스의 최종 결과를 데이터베이스에 저장하거나 유저 인터페이스 화면에 표시
- 각 파이프와 필터는 단방향이고 워낙 단순해서 얼마든지 조합할 수 있음.

# 11.2 예제
- 파이프라인 아키텍처는 다양한 애플리케이션, 특히 간단한 단방향 처리 태스크에서 흔히 찾아볼 수 있음.
  - 전자 데이터 교환 도구, ETL 도구
  - 아파치 카멜 같은 오케스트레이터와 중재자는 파이프라인 아키텍처를 기반으로 정보를 다음 비즈니스 단계로 전달함
- 다양한 서비스의 텔레메트리(원격 계측) 정보를 아파치 카프카에 스트리밍하는 예제

<img width="493" alt="스크린샷 2025-06-04 오전 4 49 06" src="https://github.com/user-attachments/assets/1d8ab0b3-7ba3-4b19-a11d-8b6004cf9e12" />

- 서비스 정보 캡처(프로듀서) 필터는 카프카 토픽을 구독하여 서비스 정보를 받아 이 데이터를 지속 시간 필터라는 테스터 필터에 보냄
  - 지속 시간 필터는 카프카에서 받아온 데이터가 서비스 요청 지속시간과 연관되어 있는지 판단
  - 필터마다 관심사가 분리되어 있음. 서비스 정보 필터는 카프카 토픽에 연결하는 일만 신경씀
    - 지속 시간 필터는 데이터 검증 후 필요시 다음 파이프에 보내는 작업만 수행
- 이 예제는 파이프라인 아키텍처의 확장성을 잘 나타냄.
  - 새로 수집된 메트릭을 데이터베이스에 전달해야 될 경우 간단히 가동 시간 필터 다음에 테스트 필터를 하나 더 추가하면 됨
 
# 11.3 아키텍처 특성 등급
| 아키텍처 특성 | 별점 |
|--------------|------|
| 분할 유형 | 기술 |
| 퀀텀 수 | 1 |
| 배포성 | ⭐ |
| 탄력성 | ⭐ |
| 진화성 | ⭐ |
| 내고장성 | ⭐ |
| 모듈성 | ⭐ |
| 전체 비용 | ⭐⭐⭐⭐⭐ |
| 성능 | ⭐⭐ |
| 신뢰성 | ⭐⭐⭐ |
| 확장성 | ⭐ |
| 단순성 | ⭐⭐⭐⭐⭐ |
| 시험성 | ⭐⭐ |

- 파이프라인 아키텍처 스타일은 애플리케이션 로직을 필터 타입에 따라 나누는, 기술 분할 아키텍처이다. 또한 보통 모놀리식 형태로 구현/배포되므로 아키텍처 퀀텀은 언제나 1이다.
- 주요 강점은 모듈성과 결부된 전체 비용 및 단순성이다.
  - 모놀리식에 가깝기 때문에 분산 아키텍처 스타일에 수반되는 복잡도가 없고 단순해서 알기 쉽고 구축 및 유지보수 비용도 적게 듦
  - 다양한 필터와 변환기 간의 관심사를 분리함으로써 모듈성을 확보할 수 있고 필터를 교체/수정하더라도 다른 필터에 영향을 끼치지 않음
- 평균 수준의 배포성, 시험성. 필터를 통한 모듈성이 더 우수하므로 레이어드 아키텍처보다는 조금 낫다.
  - 그래도 모놀리스라서 절차, 리스크, 배포 빈도, 테스트 완성도의 영향을 받는다.
- 레이어드 아키텍처와 마찬가지로 분산 아키텍처에서 자주 목격되는 네트워크 트래픽, 대역폭, 레이턴시 문제가 비교적 덜 하기 때문에 전체 신뢰성은 별 3개이다.
  - 조금만 변경할 일이 생겨도 전체 모놀리스를 테스트하고 배포해야 되는 모놀리스의 고질적인 문제로 별점이 3개임
- 모놀리식 배포와 아키텍처 픅면에서의 모듈성이 부족하므로 탄력성과 확장성은 점수가 낮다
  - 내부 기능 중에는 상대적으로 확장이 가능한 것들도 있지만 그렇게 확장하려면 멀티 스레딩, 내부 메시징을 비롯해 이 아키텍처와는 안얼루니는 몇가지 병렬 처리 프랙티스와 기법이 동원된다.
  - 그러나 레이어드 아키텍처는 언제나 단일 시스템 퀀텀이므로 단일 퀀텀을 기반으로 특정 지점까지만 확장이 가능
- 모놀리식 배포 탓에, 부족한 모듈성 때문에 내고장성도 별로이다.
  - 어느 한 작은 파트에 OOM이 발생하면 애플리케이션 전체적으로 영향을 받고 충돌이 발생한다.
  - 대부분의 모놀리식 애플리케이션이 겪는 MTTR(평균 수리 시간) 때문에 전체 가용성도 영향을 받는다.
