- 이 아키텍처 스타일은 단일 모놀리식 배포 단위로 패키징해서 다운로드 및 설치가 가능하며, 보통 고객사이트에서 서드파티 제품으로 설치되는 제품 기반 애플리케이션 적합하다.
- 비제품 고객 비즈니스 애플리케이션에서도 많이 사용된다

# 12.1 토폴로지
- 코어 시스템과 플러그인 컴포넌트라는 두 가지 아키텍처 요소로 구성된 단순한 모놀리식 아키텍처이다.
  - 애플리케이션 로직은 독립적인 플러그인 컴포넌트와 기본 코어 시스템에 골고루 분산되어 확장성, 적응성, 애플리케이션 기능 분리, 커스텀 처리 등을 수행

### 12.1.1 코어 시스템

<img width="444" alt="스크린샷 2025-06-04 오후 6 16 11" src="https://github.com/user-attachments/assets/78b86b13-b6fd-4f86-89c9-e2c39155a2c7" />

- 코어 시스템은 시스템을 실행시키는데 필요한 최소한의 기능으로 정의된다.
  - 이클립스 IDE가 좋은 예이다. 이클립스 코어 시스템은 파일을 열고, 텍스트를 고치고, 다시 파일을 저장하는 기본적인 텍스트 에디터에 불과하다
  - 코어 시스템은 커스텀 처리가 거의/전혀 필요없는, 애플리케이션을 관통하는 정상 경로(일반적인 처리흐름)라고 정의
  - 코어 시스템의 순환 복잡도를 없애고 별도의 플러그인 컴포넌트를 장착하면 확장성, 유지보수성, 시험성이 좋아진다.
- 어떤 전자 제품 재활용 애플리케이션에서 수취한 제품마다 정해진 감정 규칙을 적용한다고 가정했을 때
  - 클라이언트에 종속된 코드를 순환 복잡도가 높은 코어 시스템에 두는 대신, 각 전자 제품마다 플러그인 컴포넌트를 따로 만들어 감정하면 훨씬 효율적일 것이다.
  - 감정할 전자 제품이 새로 추가되면 새 플러그인 컴포넌트를 추가하고 레지스트리를 업데이트하면 된다.
- 코어 시스템은 규모와 복잡도에 따라 레이어드 아키텍처나 모듈러 모놀리스로 구현할 수 있다.
  - 경우에 따라 코어 시스템을 별도 배포하는 도메인 서비스로 나누어 서비스별 도메인에 특정한 플러그인 컴포넌트를 둘 수 있다.

<img width="540" alt="스크린샷 2025-06-04 오후 6 24 37" src="https://github.com/user-attachments/assets/db90bb67-c174-4af6-aa0c-f9f409876415" />

- 코어 시스템의 프레젠테이션 레이어는 코어 시스템에 내장하거나 별도의 UI로 구현하고 코어 시스템은 백엔드 서비스를 제공한다.

<img width="541" alt="스크린샷 2025-06-04 오후 6 25 24" src="https://github.com/user-attachments/assets/bbee99aa-242b-4a77-acf2-c478564b19be" />

- 실제로 별도의 UI를 마이크로커널 아키텍처 스타일로 구현할 수도 있다. 그림 12-3은 코어 시스템에 대해 프레젠테이션 레이어를 구성하는 세 가지 변형이다.

### 12.1.2 플러그인 컴포넌트
- 플러그인 컴포넌트는 특수한 처리 로직, 부가 기능, 코어 시스템을 개선/확장하기 위한 커스텀 코드가 구현된 스탠드얼론 컴포넌트이다.
  - 변동성이 매우 큰 코드를 분리하여 애플리케이션 내부의 유지보수성, 시험성을 높인다. 이상적인 플러그인 컴포넌트는 상호 독립적이며 의존성이 없다.
- 플러그인 컴포넌트와 코어 시스템은 일반적으로 점대점 통신을 한다. 코어 시스템에 플러그인을 연결하는 '파이프'는 대부분 플러그인 컴포넌트의 진입점 클래스를 호출하는 메서드나 함수 코드이다.
  - 플러그인 컴포넌트는 컴파일 기반 또는 런타임 기반으로 만들 수 있다.
    - 런타임 플러그인 컴포넌트는 런타임에 코어 시스템이나 다른 플러그인을 재배포하지 않고도 바로 추가/삭제가 가능하다.
    - 컴파일 플러그인 컴포넌트는 관리하기는 편하지만 변경, 추가, 삭제 시 전체 모놀리식 애플리케이션을 재배포해야 된다.
- 점대점 플러그인 컴포넌트는 (JAR, DLL, Gem 같은) 공유 라이브러리, 패키지명(자바), 네임스페이스(C#)으로 구현할 수 있다.

<img width="541" alt="스크린샷 2025-06-04 오후 6 32 47" src="https://github.com/user-attachments/assets/983c7fca-e8ac-4617-beb7-ccf71163019c" />

- 그림 12-5처럼 각 플러그인 컴포넌트를 코드베이스나 IDE 프로젝트 내부의 개별 네임스페이스 또는 패키지명으로 구현하면 더 알기 쉽다.

<img width="541" alt="스크린샷 2025-06-04 오후 6 42 05" src="https://github.com/user-attachments/assets/ce4dcd4a-dc93-4f2a-b2fa-0f8c5d03825a" />


- 플러그인 컴포넌트가 반드시 코어 시스템과 점대점 통신을 해야 하는 것은 아니다.
  - 각 플러그인을 스탠드얼론 서비스(또는 컨테이너로 구현한 마이크로서비스)로 만들어 REST나 메시징등 다른 방법으로 기능을 호출하는 방법도 있다.
  - 이것은 언뜻 보기에 전체 확장성을 개선하는 좋은 방법 같지만 그림 12-6을 보면 이 토폴로지는 코어 시스템이 모놀리식이므로 여전히 단일 아키텍처 퀀텀이다.
- 플러그인 컴포넌트를 개별 서비스로 구현해서 원격 액세스하는 방법은 전체 컴포넌트의 커플링이 낮아져 확장성과 처리량이 개선되고 특수한 프레임워크 없이 런타임 변경이 가능한 장점이 있다.
  - 또 플러그인과 비동기 통신도 가능하게 한다. 경우에 따라 전체 유저 반응성도 엄청나게 끌어올릴 수 있다.
- 원격 플러그인에 접속하라면 마이크로커널 아키텍처를 모놀리식이 아닌 분산 아키텍처로 바꿔야하는데, 대부분의 서드파티 온프렘 제품은 그렇게 구현/배포하기가 쉽지 않다.
  - 또한 전반적으로 복잡도와 비용이 높아져 전체 배포 토폴리지가 상당히 난해해진다.
  - 플러그인이 무응답이거나 작동되지 않는 경우(특히 REST 사용 시) 요청은 완료될 수 없다.
  - 따라서 플러그인 컴포넌트와 코어 시스템이 점대점을 통신할 지, 원격 액세스 할 지는 주어진 요구사항에 따라 선택해야 할 문제이다.
- 플러그인 컴포넌트가 중앙 공유 데이터베이스에 직접 접속할 일은 거의 없다.
  - 코어 시스템이 그 역할을 담당하여 필요한 데이터를 모두 가져와 각 플러그인에게 전달한다.
  - 디커플링의 목적으로 이런 원칙을 수립한다. 데이터베이스를 변경하는 행위는 코어 시스템에만 영향을 미치고 플러그인 컴포넌트에는 아무 영향을 끼치지 않으므로 플러그인은 자기만 액세스 가능한 데이터 저장소를 따로 가질 수 있다.
  - 플러그인 컴포넌트가 소유한 데이터 저장소는 외부화하거나, 인메모리 또는 임베디드 데이터베이스처럼 플러그인 컴포넌트 또는 모놀리식 배포의 일부로 내장할 수 있다.

<img width="539" alt="스크린샷 2025-06-04 오후 6 55 19" src="https://github.com/user-attachments/assets/d99df1f0-e198-4702-ad6b-a55cb5a30b5a" />

# 12.2 레지스트리
- 코어 시스템은 어떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야하는지 알고 있어야 한다.
  - 가장 일반적인 구현 방법은 플러그인 레지스트리를 경유하는 것이다.
  - 이 레지스트리에는 플러그인 명칭, 데이터 계약, (플러그인에서 코어 시스템으로 접속하는 방법별) 세부 원격 액세스 프로토콜 등 각 플러그인 모듈에 관한 정보가 있다.
- 레지스트리는 코어 시스템이 소유한 내부 맵 구조처럼 단순할 수도 있고, 레지스트리 및 디스커버리 도구가(Apache Zookeeper, Consul 등) 코어 시스템이나 외부 배포된 시스템에 내장된 복잡한 형태일 수도 있다.

# 12.3 계약
- 플러그인 컴포넌트와 코어 시스템 간의 계약은 보통 플러그인 컴포넌트의 도메인 단위로 표준화 되어 있고, 플러그인 컴포넌트가 수행하는 기능 및 출력 데이터는 계약에 명시되어 있다.
  - 플러그인 컴포넌트의 계약을 마음대로 바꿀 수 없을 때에 보통 커스텀 계약을 사용한다. 일반적으로 코어 시스템이 각 플러그인 별 코드를 필요로 하지 않도록 플러그인 계약과 우리가 정한 표준 계약 간의 어댑터를 만든다.
- 플러그인 계약은 플러그인과 코어 시스템이 서로 주고받는 XML, JSON 또는 객체로 구현한다.

# 12.4 실제 용례
- 이클립스 IDE, PMD, 지라, 젠킨스 등 많은 소프트웨어 개발/릴리스 도구가 마이크로커널 아키텍처를 사용해서 개발됐다.
  - 크롬, 파이어폭스 같은 인터넷 웹 브라우저도 마이크로커널 아키텍처를 응용한 제품이다.
  - 제품 기반의 소프트웨어 역시 용례는 무궁무진하지만 마이크로커널 아키텍처는 대규모 비즈니스 애플리케이션에도 적용할 수 있다.
- 보험금 청구건을 처리하는 보험 회사 시스템이 있다고 가정한다.
  - 보험금 청구 프로세스는 관할 구역마다 보험금 청구 시 허용/금지된 규칙과 규정이 제각각이기 때문에 매우 복잡하다.
- 보험금 청구 처리 애플리케이션은 대부분 아주 크고 복잡한 규칙 엔진을 이용해서 복잡한 로직을 처리하지만, 이 규칙 엔진이 진흙잡탕이 되어 규칙 하나를 변경하면 다른 규칙들이 연쇄적으로 영향을 받거나, 단순한 규칙 하나를 바꾸려고 해도 여러 분석가, 개발자, 테스터가 한데 모여 문제 없는지 검토하는 과정을 거쳐야할 수 있다.
- 관할 구역별 청구 규칙을 별도의 스탠드얼론 플러그인 컴포넌트에 보관하는 패턴을 도입할 수 있다.
  - 그러면 다른 시스템 파트에 영향을 주지 않고 특정 관할 구역의 규칙을 추가, 삭제, 변경할 수 있다.
  - 관할 구역을 새로 추가하거나 기존 관할 구역을 삭제해도 다른 시스템 파트에는 영향이 없다.

# 12.5 아키텍처 특성 등급
| 아키텍처 특성 | 별점 |
|--------------|------|
| 분할 유형 | 도메인 및 기술 |
| 컨텍 수 | 1 |
| 배포성 | ⭐⭐⭐ |
| 탄력성 | ⭐ |
| 진화성 | ⭐⭐⭐ |
| 내고장성 | ⭐ |
| 모듈성 | ⭐⭐⭐ |
| 전체 비용 | ⭐⭐⭐⭐⭐ |
| 성능 | ⭐⭐⭐ |
| 신뢰성 | ⭐⭐⭐ |
| 확장성 | ⭐ |
| 단순성 | ⭐⭐⭐⭐ |
| 시험성 | ⭐⭐⭐ |

- 마이크로커널도 레이어드처럼 단순성과 전체 비용은 주요강점이다.
  - 반면 고질적인 모놀리식 배포 탓에 탄력성, 내고장성, 확장성이 문제가 될 때가 많다. 모든 요청은 코어 시스템을 통해 유입되어 독립적인 플러그인 컴포넌트로 흘러가므로 퀀텀은 언제나 1이다.
- 마이크로커널은 도메인 분할, 기술 분할이 모두 가능한 유일한 아키텍처 스타일이다.
  - 마이크로커널은 대부분 기술 분할되지만, 도메인 분할 역시 강력한 도메인 대 아키텍처 동형성을 통해 실현된다.
  - 예를 들어, 위치나 클라이언트에 따라 설정이 달라지는 문제는 이 아키텍처가 제격이다.
  - 지라나 이클립스 IDE처럼 커스터마이징, 기능 신장성에 중점을 둔 제품이나 애플리케이션도 마찬가지이다.
- 기능을 독립적인 플러그인 컴포넌트로 분리할 수 있으므로 시험성, 배포성, 신뢰성은 평균보다 약간 높다.
  - 잘 분할하기만 한다면(특히 플러그인 컴포넌트를 런타임에 배포할 경우) 변경분에 대한 전체 테스트 범위와 배포 리스크가 줄어든다
- 모듈성은 평균보다 조금 높다. 마이크로커널은 독립적인 자기 완비형 플러그인 컴포넌트를 통해 기능을 추가, 삭제, 변경할 수 있다.
  - 덕분에 애플리케이션을 개선/확장하는 작업이 비교적 용이하다.
- 성능은 항상 별점을 주기 애매하지만 평균보다 약간 높은 3개를 주었다.
  - 이 아키텍처를 기반으로 개발한 애플리케이션은 대부분 규모가 작고 레이어드처럼 갈수록 커지지 않기 때문이다.
  - 싱크홀 안티패턴으로 고생할 일도 없으며, 불필요한 기능은 해제하여 처리 흐름을 간소화할 수 있다.
