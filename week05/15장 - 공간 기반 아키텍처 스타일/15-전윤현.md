- 웹 기반 비즈니스 애플리케이션은 일반적으로 브라우저 -> 웹 서버 -> 애플리케이션 서버 -> 데이터베이스 서버 순서로 도달하는 요청 흐름을 가지고 있다.
  - 유저 수가 늘어나면 점점 병목 현상이 나타난다. 웹 서버 레이어, 애플리케이션 서버, 데이터베이스 레이어 순으로 병목이 발생한다.
  - 웹 서버를 확장한다고 해도, 확장하기 더 어려운 애플리케이션 서버에 병목이 생기고, 애플리케이션 서버를 확장해도 확장하기 더 어려운 데이터베이스 레이어에 병목이 생긴다.

<img width="536" alt="스크린샷 2025-06-10 오후 2 22 01" src="https://github.com/user-attachments/assets/d128166f-8273-4a17-9183-30d342412359" />

- 동시 유저 부하가 많은 대용량 애플리케이션은 데이터베이스의 동시 처리 가능한 트랜잭션 수 가 최종 제약조건이 되는 경우가 많다.
  - 다양한 캐시 기술과 데이터베이스 확장 제품으로 문제를 해결할 수 있지만, 부하가 극심할 때 애플리케이션을 확장하는 작업은 쉽지 않다.
- 공간 기반 아키텍처 스타일은 높은 확장성, 탄력성, 동시성 및 이와 관련된 문제를 해결하기 위해 설계된 아키텍처 스타일이다.
  - 동시 유저 수가 매우 가변적이라서 예측조차 곤란한 애플리케이션에 유용하다.
  - 극단적이고 가변적인 확장성 문제는 데이터베이스를 확장하거나 확장성이 떨어지는 아키텍처에 맞게 캐시 기술을 적용하는 것 보다 아키텍처적으로 해결하는 것이 더 낫다.

# 15.1 토폴로지
- 공간 기반 아키텍처라는 명층은 튜플 공간에서 유래됐다.
  - 튜플 공간은 공유 메모리를 통해 통신하는 다중 병렬 프로세서를 사용하는 기술이다.
  - 동기 제약조건인 중앙 데이터베이스를 없애는 대신, 복제된 인메모리 데이터 그리드를 활용하면 확장성, 탄력성, 성능을 높일 수 있다.
  - 애플리케이션 데이터는 메모리에 둔 상태로 모든 활성 처리 장치들이 데이터를 복제한다.
  - 처리 장치는 데이터를 업데이트할 때 퍼시스턴스 큐에 메시지를 보내는 식으로 데이터베이스에 데이터를 비동기 전송한다.
  - 유저 부하의 증가/감소에 따라 처리 장치는 동적으로 시작/종료할 수 있어 가변적으로 확장할 수 있다.
  - 중앙 데이터베이스가 애플리케이션의 표준 트랜잭션 처리에 관여하지 않으므로 데이터베이스 병목 현상이 사라진다.

<img width="572" alt="스크린샷 2025-06-10 오후 2 26 41" src="https://github.com/user-attachments/assets/b1e82eff-1058-436a-bf2e-bd50c45f72e2" />

- 공간 기반 아키텍처의 컴포넌트
  - 애플리케이션 코드가 구현된 처리 장치
  - 처리 장치를 관리/조정하는 가상 미들웨어
  - 업데이트된 데이터를 데이터베이스에 비동기 전송하는 데이터 펌프
  - 데이터 펌프에서 데이터를 받아 업데이트를 수행하는 데이터 라이터
  - 처리 장치가 시작되자마자 데이터베이스의 데이터를 읽어 전달하는 데이터 리더

### 15.1.1 처리 장치

<img width="345" alt="스크린샷 2025-06-10 오후 2 36 58" src="https://github.com/user-attachments/assets/0fd30cc7-0a81-41d8-87d1-d37cb94bf09c" />

- 애플리케이션 로직을 갖고 있다. 보통 웹 기반 컴포넌트와 백엔드 비즈니스 로직이 포함된다.
  - 작은 웹 기반 애플리케이션은 단일 처리 장치에 배포할 수 있지만, 대규모 애플리케이션은 기능별로 여러 장치에 나누어 배포해야 된다.
  - 애플리케이션 로직 외에도 Hazelcast, Apache Ignite 등의 제품에 있는 인메모리 데이터 그리드 및 복제 엔진도 포함된다
 
### 15.1.2 가상 미들웨어
- 아키텍처 내부에서 데이터 동기화 및 요청 처리의 다양한 부분을 제어하는 인프라를 담당한다.
  - 메시징 그리드, 데이터 그리드, 처리 그리드, 배포 관리자 등의 컴포넌트로 구성된다. 이들 컴포넌트들은 직접 작성하거나, 제품으로 구매할 수 있다.

#### 메시징 그리드

<img width="604" alt="스크린샷 2025-06-10 오후 2 39 17" src="https://github.com/user-attachments/assets/9fb189b1-6968-4092-9f51-72e3ccf99838" />

- 입력 요청과 세션 상태를 관리한다.
  - 가상 미들웨어에 요청이 유입되면 메시징 그리드는 어느 활성 처리 장치가 요청을 받아 처리할지 결정한다.
  - 단순한 라운드 로빈 알고리즘부터 처리 장치의 요청 처리 상태를 추적하는 복잡한 알고리즘까지 다양하다
  - 보통 부하 분산이 가능한 일반 웹 서버 (예: nginx)로 구현된다
 

#### 데이터 그리드

<img width="591" alt="스크린샷 2025-06-10 오후 2 41 38" src="https://github.com/user-attachments/assets/68096475-1a84-449f-837d-ba4da3a5f597" />

- 가장 중요하고 필수적인 컴포넌트이다.
  - 거의 대부분 복제 캐시로서 처리 장치에만 구현되어 있지만, 외부 컨트롤러가 필요한 복제 캐시 구현체나 분산 캐시를 사용할 경우 데이터 그리드는 가상 미들웨어 내부의 데이터 그리드 컴포넌트와 처리 장치 모두에 위치한다.
  - 메시징 그리드는 가용한 모든 처리 장치에 요청을 전달할 수 있으므로 각 처리 장치는 자신의 인메모리 데이터 그리드에 정확히 동일한 데이터를 갖고 있어야 한다.
  - 그림[15-5]는 처리 장치 간 동기식 데이터 복제 흐름을 나타낸 것이다. 실제로 동기화는 비동기 방식으로 매우 신속하게, 일반적으로 100밀리초 미만으로 이루어진다.

```java
HazelcastInstance hz = Hazlecast.newHazelcastInstance();
Map<String, CustomerProfile> profileCache = hz.getReplicatedMap("CustomerProfile");
```

- 데이터는 이름이 동일한 데이터 그리드가 포함된 처리 장치 간에 동기화된다.
  - 위의 코드는 고객 프로필 정보에 액세스하는 모든 처리 장치에 포함된다.
  - 만약 처리 장치 어디서건 CustomerProfile라는 캐시에 변경이 일어나면 동일한 이름의 캐시가 포함된 다른 모든 처리 장치에 변경된 데이터가 복제된다.
  - 처리 장치는 작업을 마치는데 필요한 만큼의 복제 캐시를 소유할 수 있다. 한 처리 장치가 다른 처리 장치를 원격 호출해서 데이터를 요청하거나(코레오그래피), 처리 그리드를 이용해서 요청을 오케스트레이트하는 방법도 있다.
- 데이터는 처리 장치 내부에서 복제되므로 데이터베이스에서 데이터를 읽지 않아도 서비스 인스턴스의 기동/중지가 가능하다
  - 단, 이름을 부여한 복제 캐시를 가진 인스턴스가 하나 이상 필요하다.
  - 처리 장치 인스턴스가 기동되면 캐시 프로바이더에 연결해서 이 캐시를 가져오라고 요청한다.
  - 다른 처리 장치에 접속되면 다른 인스턴스 중 한곳에서 캐시를 로드한다.
- 각 처리 장치는 멤버 리스트를 사용해 다른 모든 처리 장치의 인스턴스를 인지한다.
  - 멤버 리스트에는 동일한 이름의 캐시를 사용하는 다른 모든 처리 장치의 IP 주소 및 포트가 들어있다.
  - 멤버 리스트에 고객 프로필에 액세스하는 인스턴스가 인스턴스 1, 인스턴스 2, 인스턴스 3이 있을 때
    - 인스턴스 1이 고객 프로필 정보의 업데이트 요청을 받았을 때, 인스턴스 1은 cache.put()과 같은 업데이트 메서드로 캐시를 업데이트한다.
    - 데이터 그리드(예: 헤이즐캐스트, Apache Ignite)는 다른 복제 캐시도 똑같이 비동기 업데이트하는 식으로 세 개의 고객 프로필 캐시를 항상 똑같이 맞춘다.
    - 처리 장치 인스턴스가 다운되면 이 사실을 알 수 있게 다른 모든 처리 장치의 멤버 리스트가 자동으로 업데이트 된다.

#### 처리 그리드

<img width="591" alt="스크린샷 2025-06-10 오후 3 10 25" src="https://github.com/user-attachments/assets/0fb73d5c-acee-410b-95fc-4246fa97bec6" />

- 필수 컴포넌트는 아니지만, 다수의 처리 장치가 단일 비즈니스 요청을 처리할 경우 요청 처리를 오케스트레이트하는 일을 한다.
  - 또 종류가 다른 처리 장치 (예: 주문 처리 장치와 결제 처리 장치) 사이에 조정이 필요한 요청이 들어오면 두 처리 장치 사이에서 요청을 중재/조정한다.

#### 배포 관리자
- 부하 조건에 따라 처리 장치 인스턴스를 동적으로 시작/종료하는 컴포넌트이다.
  - 응답 시간, 유저 부하를 계속 모니터링하다 부하가 증가하면 새로운 처리 장치를 기동하고 반대로 감소하면 기존 처리 장치를 종료한다.

### 15.1.3 데이터 펌프

- 데이터를 다른 프로세서에 보내 데이터베이스를 업데이트하는 장치이다.
  - 처리 장치가 데이터를 데이트베이스에서 직접 읽고 쓰지 않으므로 데이터 펌프는 반드시 필요하다.
  - 데이터 펌프는 항상 비동기로 동작하면서 메모리 캐시와 데이터베이스의 최종 일관성을 실현한다.

<img width="352" alt="스크린샷 2025-06-10 오후 3 29 35" src="https://github.com/user-attachments/assets/a3660d43-f2f3-42eb-bfaa-ede84b048cc6" />

- 대개 메시징 기법으로 구현된다. 공간 기반 아키텍처에서 메시징은 데이터 펌프를 구현하는 효과적인 방법이다.
  - 메시징은 비동기 통신을 지원하고, 전달을 보장하며, FIFO 큐를 통해 메시지 순서를 유지한다.
  - 메시징을 이용하면 처리 장치와 데이터 라이터를 분리할 수 있기 때문에 데이터 라이터를 사용할 수 없을 경우에도 처리 장치에서 무중단 처리가 가능하다.
- 대부분의 경우 데이터 펌프는 도메인이나 그 서브도메인 별로 여러 개를 사용한다.
  - 캐시 종류(예: CustomerProfile, CustomerWishlist 등) 별로 전용 데이터 펌프를 두거나, 이 보다 훨씬 더 큰 일반적인 캐시를 포함한 처리 장치 도메인(예: Customer)별로 배정할 수도 있다.
  - 데이터 펌프는 계약 데이터와 연관된 액션(추가, 삭제, 수정)을 포함한다. 계약 포맷은 JSON 스키마, XML 스키마, 객체, 값 기반 메시지 등 다양하다.
  - 업데이트 데이터는 보통 데이터 펌프 안에 새 데이터 값만 보관한다.

### 15.1.4 데이터 라이터

<img width="577" alt="스크린샷 2025-06-10 오후 3 37 52" src="https://github.com/user-attachments/assets/d0f60b26-550f-4b2f-a2ee-03f6af00d50c" />

- 데이터 펌프에서 메시지를 받아 그에 맞게 데이터베이스를 업데이트하는 컴포넌트이다.
  - 서비스나 애플리케이션 데이터 허브(예" Ab Initio)로 구현할 수 있다.
  - 데이터 라이터의 세분도는 데이터 펌프와 처리 장치의 범위마다 다르다.
- 도메인 기반의 데이터 라이터는 데이터 펌프 수와 무관하게 특정 도메인(예: 고객)의 전체 업데이트를 처리하는데 필요한 모든 데이터베이스 로직을 가지고 있다.

<img width="629" alt="스크린샷 2025-06-10 오후 3 43 21" src="https://github.com/user-attachments/assets/5d8638b3-fc89-48c8-b19d-fad288f930f8" />

- 처리 장치 클래스마다 자체 전용 데이터 라이터를 두는 경우도 있다.
  - 각 데이터 라이터가 자신의 전용 데이터 펌프를 소유하고 해당 처리 장치(예: 위시리스트)의 데이터베이스 로직을 처리한다.
  - 데이터 라이터가 너무 많은 단점이 있지만, 처리 장치, 데이터 펌프, 데이터 라이터가 나란히 정렬되어 확장성 민첩성은 더 좋다.

### 15.1.5 데이터 리더
