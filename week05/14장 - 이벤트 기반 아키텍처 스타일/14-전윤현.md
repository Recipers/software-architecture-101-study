- 이벤트 기반 아키텍처는 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 쓰이는 비동기 분산 아키텍처 스타일이다.
  - 이벤트를 비동기 수신/처리하는 별도의 이벤트 처리 컴포넌트들로 구성되며, 스탠드얼론 아키텍처 스타일을 사용하거나 다른 아키텍처 스타일에 내장할 수 있다.

<img width="612" alt="스크린샷 2025-06-09 오후 2 38 57" src="https://github.com/user-attachments/assets/0befc427-8b47-4788-a652-b145b5747753" />

- 애플리케이션은 대부분 요청 기반 모델을 따른다.
  - 이 모델에서는 어떤 액션을 수행하도록 시스템에 요청하면 요청 오케스트레이터가 접수한다.
    - 요청 오케스트레이터는 보통 유저 인터페이스이지만 API 레이어나 엔터프라이즈 서비스 버스로도 구현할 수 있다.
    - 이 컴포넌트의 임무는 다양한 요청 프로세스에 확장적으로, 동기적으로 요청을 전달하는 일이다. 요청 프로세서는 요청을 받아 데이터베이스에서 정보를 조회/수정하는 등의 작업을 수행하는 식으로 요청을 처리한다.
    - 예를 들어, 어느 시스템에서 유저가 지난 반년치 주문 이력을 검색한다고 하자. 주문 이력 조회는 특정한 콘텍스트에서 시스템에 데이터를 달라고 전달된, 데이터 기반의 확정적인 요청이지, 시스템이 반응해야 할 이벤트가 발생한 것은 아니다.
- 반면 이벤트 기반 모델은 특정한 상황에 대응하여 그 이벤트에 알맞게 액션을 취하는 형식이다.
  - 온라인 경매 사이트에서 입찰자가 어떤 품목을 입찰할 때, 입찰을 하는 행위는 시스템에 뭔가 요청을 하는 것으로도 볼 수 있다.
    - 하지만 현재 가격이 발표된 직후에 발생하는 이벤트로도 볼 수 있다. 시스템은 이벤트에 반응함으로써 동시 발생한 다른 입찰가와 비교하여 현재까지 누가 가장 높은 가격을 부른 입찰자인지 결정한다.

# 14.1 토폴로지

### 14.2 브로커 토폴로지
- 브로커 토폴로지는 중앙에 이벤트 중재자가 없다는 점에서 중재자 토폴리좌 다르다.
  - 메시지는 (RabbitMQ, ActiveMQ 등)의 경량 메시지 브로커를 통해 브로드캐스팅되는 식으로 이벤트 프로세서 컴포넌트에 분산되어 흘러간다.
  - 비교적 이벤트 처리 흐름이 단순하고 굳이 중앙에서 이벤트를 조정할 필요가 없을 때 유용하다

<img width="580" alt="스크린샷 2025-06-09 오후 2 47 46" src="https://github.com/user-attachments/assets/ef3de7fc-cc6e-418c-9da3-c26491a80135" />

- 브로커 토폴로지는 네 가지 기본 아키텍처 컴포넌트(시작 이벤트, 이벤트 브로커, 이벤트 프로세서, 처리 이벤트)로 구성된다.
  - 시작 이벤트는 단순한 이벤트든, 복잡한 이벤트든 전체 이벤트 흐름을 개시하는 이벤트를 말한다. 시작 이벤트는 이벤트 브로커의 이벤트 채널로 전송되어 처리된다.
  - 이벤트를 관리/제어하는 중재자가 브로커 토폴로지에는 없으므로 단일 이벤트 프로세서는 이벤트 브로커에서 시작 이벤트를 받자마자 관련된 처리 작업을 마친뒤 처리 이벤트를 생성하고 시스템의 나머지 부분에 자신이 한 일을 비동기로 알린다.
  - 처리 이벤트는 필요시 부가적인 처리를 위해 이벤트 브로커에 비동기 전송된다.
  - 다른 이벤트 프로세서는 처리 이벤트를 리스닝하고 있다가 이벤트가 들어오면 그에 맞는 작업을 수행한 뒤 다시 새로운 처리 이벤트를 발행함으로써 자신이 한일을 모두에게 알린다.
  - 이 과정은 최종 이벤트 프로세서가 한 일에 아무도 관심이 없을 때 까지 되풀이된다.
- 이벤트 브로커 컴포넌트는 보통 연합체(도메인 기반으로 클러스터링된 다수의 인스턴스)로 구성되며, 연합된 각 브로커에는 주어진 도메인의 이벤트 흐름에서 사용되는 모든 이벤트 채널이 들어있다.
  - 브로커 토폴로지는 속성상 fire-and-forget 방식으로 비동기 브로드캐스팅 하므로 토픽은 일반적으로 발행-구독 모델을 사용하는 브로커 토폴로지에서 사용된다.

<img width="636" alt="스크린샷 2025-06-09 오후 2 56 21" src="https://github.com/user-attachments/assets/85bce742-a7c4-4d5f-a1f4-0a2ba1cb19f3" />


- 브로커 토폴로지에서는 다른 이벤트 프로세서의 관심 여부와 무관하게 각 이벤트 프로세서가 자신이 한 일을 모두에게 알리는게 항상 바람직하다.
  - 그래야 나중에 이벤트를 처리하는 과정에서 기능 추가가 필요하게 되더라도 아키텍처를 쉽게 확장할 수 있다.
- 이것은 아키텍처 확장성의 좋은 사례다.
  - 어차피 무시될 메시지를 보내는 것이 리소스 낭비로 보일 수 있지만 실은 그렇지 않다.
  - 만약에 나중에 새로운 요구사항이 생겼을 때 따로 인프라를 추가하거나 다른 이벤트 프로세서를 변경하지 않아도 보다 수월하게 요구사항을 구현할 수 있다.

<img width="576" alt="스크린샷 2025-06-09 오후 2 57 49" src="https://github.com/user-attachments/assets/23d16939-f877-4222-9804-e4d703937fd5" />

- 어느 서점의 주문 입력 시스템에서 이벤트가 처리되는 흐름이다.
  - 품목(도서)에 대해 주문이 접수되면 OrderPlacement 이벤트 프로세서는 시작 이벤트(PlaceOrder)를 받아 데이터베이스 테이블에 주문을 삽입한 다음 고객에게 주문 ID를 반환한다.
  - 그리고 나서 자신이 주문을 생성했음을 order-created 처리 이벤트를 통해 나머지 프로세서에게 통보한다.
  - order-created 처리 이벤트에 관심 있는 이벤트 프로세서는 Notification, Payment, Inventory 3개이다. 이들은 각자의 임무를 나란히 수행한다.
- order-created 처리 이벤트를 접수한 Notification 이벤트 프로세서는 고객에게 이메일을 보낸 후 또 다른 처리 이벤트(email-sent)를 생성한다.
- Inventory 이벤트 프로세서도 order-created 처리 이벤트를 받아 해당 품목의 재고를 차감한 후 inventory-updated 처리 이벤트를 통해 자신이 완료한 작업을 알린다.
  - Warehouse 이벤트 프로세서는 이 이벤트를 받아 창고 간 재고 상태를 관리하고 재고 부족 시 해당 품목을 재주문한다.
- Payment 이벤트 프로세서 역시 order-created 처리 이벤트를 받아 방금 주문한 고객의 신용카드를 결제 처리한다.
  - 결제가 완료됐음을 나머지 시스템에 알리는 이벤트(payment-applied), 승인 거절됐음을 나머지 시스템에 알리는 이벤트(payment-denied), 이렇게 두 가지의 이벤트를 생성한다.
    - 이 중 Notification 이벤트 프로세서는 payment-denied 처리 이벤트에만 관심이 있다. 승인 거절시 고객이 신용카드 정보를 업데이트하거나 다른 방법으로 결제하도록 이메일로 유도해야 하기 때문이다.
- OrderFulfillment 이벤트 프로세서는 payment-applied 처리 이벤트를 받아 오더 피킹과 포장 작업을 수행한다.
  - 작업을 마치면 order-fulfilled 처리 이벤트를 발행해서 주문이 이행됐음을 나머지 시스템에 알린다.
  - 이 이벤트는 Notification 이벤트 프로세서, Shipping 이벤트 프로세서가 수신한다.
    - Notifiaction 이벤트 프로세서는 주문이 이행됐고, 배송 준비가 완료됐음을 고객에게 알린다.
    - Shipping 이벤트 프로세서는 적절한 배송 방법을 선택하여 주문을 배송하고 order-shipped 처리 이벤트를 발행한다.
      - 이 이벤트를 받은 Notification 이벤트 프로세서는 고객에게 주문 상태가 변경됐음을 알린다.
- 예제를 보면 모든 이벤트 프로세서가 고도로 분리되어 있고, 서로 독립적으로 움직인다.
  - 이벤트 프로세서는 이벤트 전달 후 더 이상 그 이벤트 처리에는 관연하지 않고 다른 시작 이벤트 또는 처리 이벤트에 반응할 준비를 한다.
  - 각 이벤트 프로세서는 처리 도중 가변적인 부하나 백업 조건을 처리하기 위해 서로 독립적으로 확장할 수 있다.
  - 만약 어떤 환경 문제로 인해 이벤트 프로세서가 느려지거나 실패하면 그 프로세서가 구독하는 토픽이 배압(back-pressure) 지점이 된다.
- 브로커 토폴로지는 성능, 응답성, 확장성 측면에서 장점이 많지만 단점도 적지 않다.
  - 무엇보다 시작 이벤트와 관련된 전체 워크플로를 제어할 수 없다.
  - 따라서 다양한 조건에 따라 상황이 매우 유동적이고, 어느 시스템 파트도 실제 주문 트랜잭션이 언제 끝났는지 알 수 없다.
  - 에러 처리 역시 어렵다. 비즈니스 트랜잭션을 관찰/통제하는 중재자가 없으므로 처리가 실패해도 다른 파트는 그 사실을 모른다. 결국 비즈니스 프로세스는 교착 상태에 빠지고 뭔가 다른 조치를 해주지 않으면 프로세스는 정체된다.
    - 게다가 이런 에러가 나든 안 나든 다른 모든 프로세스는 그냥 알아서 작동한다.
- 비즈니스 트랜잭션을 재시작하는 기능(복구성)도 브로커 토폴로지에서 지원되지 않는다.
  - 처음 시작 이벤트를 처리할 때 부터 이미 다른 작업이 비동기로 수행된 터라 시작 이벤트를 다시 넣는 것은 불가능하다.
 
| 장점 | 단점 |
|------|------|
| 이벤트 프로세서가 디커플링됨 | 워크플로 제어 |
| 확장성 높음 | 에러 처리 |
| 응답성 우수함 | 복구성 |
| 성능 우수함 | 재시작 능력 |
| 내고장성 뛰어남 | 데이터 비일관성 |

# 14.3 중재자 토폴로지
- 중재자 토폴로지는 좀 전에 살펴본 브로커 토폴로지의 단점을 일부 보완한다.
  - 여러 이벤트 프로세서 간의 조정이 필요한 시작 이벤트에 대하여 워크플로를 관리/제어하는 이벤트 중재자가 핵심이다.
  - 중재자 토폴로지는 시작 이벤트, 이벤트 큐, 이벤트 중재자, 이벤트 채널, 이벤트 프로세서, 이렇게 5개의 아키텍처 컴포넌트로 구성된다.

<img width="561" alt="스크린샷 2025-06-09 오후 5 12 38" src="https://github.com/user-attachments/assets/ed637ad8-26f0-46e8-acce-273121a00ff3" />

- 시작 이벤트는 중재자 토폴로지에서 시작 이벤트를 거쳐 이벤트 중재자로 전달된다.
  - 이벤트 중재자는 이벤트 처리에 관한 단계 정보만 갖고 있다. 점대점 메시징으로 각각의 이벤트 채널(대부분 큐)로 전달되는 처리 이벤트를 생성한다.
  - 각 이벤트 프로세서는 자신의 이벤트 채널에서 이벤트를 받아 처리한 다음 중재자에게 작업을 완료했다고 응답한다.
- 중재자 토폴로지 구현체에는 대부분 특정 도메인이나 이벤트 그룹과 연관된 중재자가 여럿 존재하므로 단일 장애점을 줄이고 전체 처리량과 성능을 높일 수 있다.
- 이벤트 중재자는 처리하는 이벤트의 특성과 복잡도에 따라 다양한 방법으로 구현할 수 있다.
  - 간단한 에러 처리와 오케스트레이션이 필요한 이벤트는 Apache Camel, Mule, ESB, Spring Integration등으로 충분하다.
  - 이벤트 워크플로에 조건부 처리가 많고 동적 경로가 많아 에러 처리가 복잡하다면 아파치 ODE, BPEL을 기반으로한 오케스트레이션을 구현하는 편이 더 낫다.
 
<img width="589" alt="스크린샷 2025-06-09 오후 5 19 23" src="https://github.com/user-attachments/assets/e3aa9e01-b0f4-4ee9-9919-f81b6066907b" />

- 이벤트 복잡도를 단순함, 어려움, 복잡함 정도로 분류한 뒤 모든 이벤트가 항상 단순한 중재자를 거치도록 하는 것이 좋다.
  - 그러면 이 중재자는 이벤트 등급에 따라 이벤트를 직접 처리하거나 더 복잡한 다른 이벤트 중재자에게 위임한다.
 
<img width="570" alt="스크린샷 2025-06-09 오후 5 22 26" src="https://github.com/user-attachments/assets/3eb37dc9-d9e3-4437-98f0-f7c154ea1392" />

- 브로커 토폴로지로 구현했던 서점 주문 입력 시스템을 중재자 토폴로지로 변경하는 예
  - 동일하게 시작 이벤트(PlaceOrder)를 customer-event-queue로 흘려 처리를 개시한다.
  - Customer 중재자는 이 시작 이벤트를 받아 처리 이벤트를 생성하는데 2, 3, 4단계의 처리 이벤트는 모두 동시에 발생하면서 단계별로 처리된다.

<img width="543" alt="스크린샷 2025-06-09 오후 5 29 02" src="https://github.com/user-attachments/assets/0fe8b3f5-b666-4e3d-9a3f-9e7e3b4dc8c9" />

- 시작 이벤트를 접수한 Customer 중재자는 먼저 create-order 처리 이벤트를 생성하고 이 메시지를 order-placement-queue로 보낸다.
  - OrderPlacement 이벤트 프로세서는 이 이벤트를 받아 문제가 없는지 확인한 뒤 주문 ID와 함께 중재자에게 확인 응답한다.

<img width="565" alt="스크린샷 2025-06-09 오후 5 31 52" src="https://github.com/user-attachments/assets/925120bc-7051-4831-b927-13c29f4d0791" />

- 1단계가 끝났으니 중재자는 2단계로 넘어가 세 처리 이벤트, email-customer, apply-payment, adjust-inventory를 동시에 만들어 각각 지정된 큐로 전달한다
  - 세 이벤트 프로세서는 모두 메시지를 받아 할 일을 한 다음 처리가 완료됐음을 중재자에게 알린다.
  - 중재자는 3단계로 이동하기 위해 3개의 병렬 프로세스로부터 모두 확인 응답을 받을 때 까지 대기한다. 어느 한 곳이라도 문제가 발생하면 중재자는 조치를 취할 수 있다.
 
<img width="586" alt="스크린샷 2025-06-09 오후 5 32 05" src="https://github.com/user-attachments/assets/12666d08-d3b4-45b2-84c1-5896034be808" />

- 2단계의 세 이벤트 프로세서로부터 정상 확인 응답을 받은 중재자는 이제 3단계로 넘어가 주문을 이행한다.
  - 이 때 fulfill-order, order-stock 두 이벤트는 동시에 발생할 수 있고, OrderFulfillment, Warehouse 이벤트 프로세서는 각자 해야 할 일을 하고 중재자에게 확인응답을 한다.

<img width="594" alt="스크린샷 2025-06-09 오후 5 33 51" src="https://github.com/user-attachments/assets/549dd3a7-d7f5-4390-951f-b4f39d5e47ca" />

- 중재자는 4단계로 넘어가 주문을 배송한다. 이 때 ship-order 이벤트 뿐만 아니라 다음에 해야 할 일에 관한 정보가 담긴 email-customer 처리 이벤트도 함께 생성한다.

<img width="594" alt="스크린샷 2025-06-09 오후 5 51 13" src="https://github.com/user-attachments/assets/c6e4a401-9288-418d-88e7-c6e9f4b472c9" />

- 마지막으로, 중재자는 5단계로 넘어가 email-customer 이벤트를 하나 더 생성한 뒤 주문이 배송됐음을 고객에게 알린다.
- 중재자 컴포넌트는 브로커 토폴로지와 달리 워크플로에 대해 잘 알고 있고 통제가 가능하다.
  - 중재자는 워크플로를 제어하므로 이벤트 상태를 유지하면서 필요 시 에러 처리, 복구, 재시작을 할 수 있다.
- 두 토폴로지는 처리 이벤트의 의미와 사용 방법이 본질적으로 다르다
  - 브로커 토포롤지에서는 시스템에서 발생한 이벤트로 처리 이벤트가 발행되고 이벤트 프로세서는 각자 맡은 일을 하면서 나머지 이벤트 프로세서는 그 액션에 반응하는 식으로 돌아간다.
  - 중재자 토폴로지에서 처리 이벤트는 사건(이미 일어난 일)이 아니라 커맨드(일어나야 할 일)이다.
  - 따라서 중재자 토폴로지에서는 처리 이벤트가 반드시 처리 되어야 할 이벤트인 반면 브로커 토폴로지에서는 그냥 무시해도 된다.
- 중재자 토폴로지는 브로커 토폴로지에서 불가능한 문제를 해결할 수 있지만 그만큼 부정적인 면도 있다.
  - 이벤트 흐름 내에서 발생하는 동적인 처리를 선언적으로 모델링하기 어렵다. 그래서 보통은 중재자의 내부 워크플로는 일반적인 처리만하고 복잡한 이벤트 처리의 변화무쌍한 부분은 중재자 + 브로커 형태의 하이브리드 모델로 처리한다
  - 이벤트 프로세서는 브로커 토폴로지와 동일한 방식으로 쉽게 확장할 수 있지만, 중재자도 함께 확장해야 하므로 전체 이벤트 처리 흐름에 병목 지점이 생기기 쉽다
  - 이벤트 처리를 중재자가 제어하므로 이벤트 프로세서가 상대적으로 더 많이 커플링되어 성능은 브로커 토폴로지보다 좋지 않다.
 
| 장점 | 단점 |
|------|------|
| 워크플로 제어 | 이벤트 프로세서가 커플링됨 |
| 에러 처리 | 확장성 낮음 |
| 복구성 | 성능 낮음 |
| 재시작 능력 | 내고장성 출지 않음 |
| 데이터 일관성 | 워크플로 모델링 복잡함 |재시도Claude는 실수를 할 수 있습니다. 응답을 반드시 다시 확인해 주세요.

- 브로커냐 중재자냐, 결국 워크플로 제어와 에러 처리 기능이 우선인가, 아니면 고성능과 확장성이 더 중요한가의 트레이드오프를 잘 따져 선택해야 된다.

# 14.4 비동기 통신

- 이벤트 기반 아키텍처 스타일은 (이벤트 컨슈머의 응답을 받아야 하는) 요청/응답 처리 뿐만 아니라 (응답이 필요 없는) fire-and-forget 처리 모두 비동기 통신만 사용하는 점에서 다른 아키텍처 스타일과 차별화된다.

<img width="562" alt="스크린샷 2025-06-09 오후 6 35 48" src="https://github.com/user-attachments/assets/126d3abe-90dc-45c6-94b9-7ae4f3ef9713" />

- 유저가 작성한 제품 후기를 댓글로 게시하는 웹사이트를 생각해보자.
  - 댓글 서비스는 여러 파싱 엔진을 거친다. 보통 댓글 하나를 게시하려면 3000밀리초가 걸린다.
  - REST로 동기 호출하면 유저가 댓글을 게시하는 데 총 3100밀리초의 응답 시간이 걸린다.
  - 메시지를 비동기 전송하면 최종 유저 입장에서 댓글을 게시하는데 25밀리초 밖에 걸리지 않는다.
    - 물론 실제로 댓글을 게시하려면 여전히 3025 밀리초가 걸지만 최종 유저 관점에서는 이미 댓글의 처리는 완료되었다
- 이 것은 응답성과 성능의 차이점을 잘 보여주는 예이다.
  - 유저가 어떤 정보를 돌려받을 필요가 없으면 기다리게 할 이유가 없다. 응답성은 어떤 액션이 접수되어 곧 처리될 것이라는 사실을 유저에게 알리는 것이다.
  - 성능은 종단간 프로세스가 더 빨리 수행되게끔 만드는 것이다.
  - 댓글 서비스는 텍스트를 처리하는 방식을 최적화하지 않았기 때문에 3000 밀리초는 어느 쪽이든 똑같이 걸린다.
  - 만약 성능에 손을 댔다면 캐시나 그와 유사한 기술을 적용해 모든 텍스트와 문법 파싱 엔진이 병렬 실행되도록 댓글 서비스를 최적화했을 것이다.
  - 이런 점에서 위의 예는 시스템 성능이 아닌 응답성을 개선한 것이다.
- 동기 호출은 댓글이 게시되었음을 최종 유저에게 보장한다. 비동기 호출은 언젠가 댓글이 게시될 예정이라는 약속과 함께 확인 응답을 받는 것 뿐이다.
  - 만약 이 댓글에 비속어 등이 포함되어서 댓글 게시가 거부되었다면 최종 유저에게 돌아갈 방법이 없다.
    - 아주 방법이 없지는 않다. 회원 가입을 한 유저만 댓글을 게시할 수 있다면 이를 알리는 메시지와 조치 방법을 유저에게 따로 안내할 수 있다.
    - 하지만 좀 더 복잡한 경우에는 이러한 임시방편이 쓸모 없어지는 경우가 많다.
- 비동기 통시에서는 에러 처리가 가장 큰 문제이다. 응답성은 엄청나게 개선되지만 에러를 제대로 처리하기가 쉽지 않기 떄문에 시스템의 복잡도가 가중된다.

# 14.5 에러 처리

- 리액티브 아키텍처의 워크플로 이벤트 패턴은 비동기 워크플로에서 에러 처리 문제를 해결하는 한 가지 방법이다.
  - 탄력성과 응답성이라는 두 마리 토끼를 겨냥한 리액티브 아키텍처 패턴의 일종이다.
  - 시스템의 응답성에 영향을 미치지 않고 탄력적으로 에러를 처리할 수 있게 만드는 패턴이다.

<img width="571" alt="스크린샷 2025-06-09 오후 6 45 25" src="https://github.com/user-attachments/assets/298d3997-c27e-41a0-b91d-20a13777eec0" />

- 워크플로 대리자를 통해 위임, 봉쇄, 수리 작업을 한다.
  - 이벤트 프로듀서는 메시지 채널을 통해 데이터를 이벤트 컨슈머에게 비동기 전송한다
  - 이벤트 컨슈머가 데이터를 처리하는 도중 에러가 발생하면 즉시 해당 에러를 워크플로 프로세서에게 위임한 뒤 다음 메시지로 넘어간다
  - 이렇게 에러가 발생해도 바로 다음 메시지를 바로 처리하므로 전체 응답성은 영향을 받지 않는다.
- 에러를 수신한 워크플로 프로세서는 사람의 개입 없이 프로그래밍 방식으로 원데이터를 변경해서 긴급 조치한 후 원래 큐로 돌려보낸다.
  - 이 메시지를 새로운 메시지로 간주하여 이번에는 성공을 기대하며 재처리를 시도한다
  - 워크플로 프로세서가 메시지의 문제점을 파악할 수 없는 경우도 있다. 이럴 때에는 메시지를 다른 큐로 보내 '대시보드'로 불리는 애플리케이션(마이크로소프트 아웃룩, 애플 메일)이 받는다.
  - 업무 담당자는 직접 메시지를 확인해 조치하고 원래 큐로 다시 전송한다

<img width="535" alt="스크린샷 2025-06-09 오후 7 02 45" src="https://github.com/user-attachments/assets/f15571e5-7eee-4bfb-a40f-a5abc5a2129c" />

- 워크플로 이벤트 패턴의 예

# 14.6 데이터 소실 방지

- 비동기 통신을 할 때 데이터 소실은 언제나 중요한 관심사이다. 불행하게도 이벤트 기반 아키텍처는 데이터가 소실될 만한 곳이 많다.
  - 데이터 소실이란, 메시지가 도중에 삭제되거나 최종 목적지에 도달하지 못한 상태이다.

<img width="565" alt="스크린샷 2025-06-09 오후 7 13 18" src="https://github.com/user-attachments/assets/4fb0d96e-3b09-4087-9ae6-7ab58d62e8b6" />

- 예를 들어, 이벤트 프로세서 A가 큐에 메시지를 비동기 전송하고 이벤트 프로세서 B는 이 메시지를 받아 데이터베이스에 삽입한다고 가정한다.
  - 일반적인 시나리오에서는 데이터 소실이 일어나는 경우는 다음과 같은 세 가지로 정리한다.
    - 이벤트 프로세서 A에서 메시지가 큐로 전달되지 않는다. 아니면 전달되어도 다음 이벤트 프로세서가 메시지를 가져오기 전에 브로커가 다운된다
    - 이벤트 프로세서 큐에서 다음 메시지를 꺼내 이벤트를 처리하기 전에 장애가 발생한다
    - 데이터 에러로 인해 이벤트 프로세서 B가 데이터베이스에 메시지를 저장할 수 없다

<img width="551" alt="스크린샷 2025-06-09 오후 7 24 48" src="https://github.com/user-attachments/assets/3e7e615c-4d00-47bb-82cc-57d85c84fdd7" />

- 1번 이슈는 동기 전송과 퍼시스턴스 메시지 큐를 이용하면 쉽게 해결할 수 있다.
  - 퍼시스턴스 메시지 큐는 전달 보장도 지원한다. 즉, 메시지 브로커가 메시지를 수신하면 신속한 조회를 위해 메모리에 저장하는 동시에 물리적 데이터 저장소에도 메시지를 저장하는 것이다.
  - 동기 전송은 브로커가 메시지를 저장했다고 확인 응답을 줄 때까지 메시지 프로듀서를 차단하여 기다리게 한다.
  - 이 두 가지 기본 기술을 활용하면 메시지는 프로듀서 또는 퍼시스턴스 메시지 큐에 있기 때문에 이 둘 사이에서 메시지가 소실될 일은 없다.
- 2번 이슈 역시 클라이언트 확인 응답 모드(client ack mode)라는 기본적인 메시징 기술을 이용하면 해결 가능하다.
  - 원래 메시지는 큐에 빠져나가는 즉시 삭제되는데(auto ack mode), 클라이언트 확인응답 모드는 메시지를 큐에 보관한 채 다른 컨슈머가 메시지를 읽을 수 없게 클라이언트 ID를 메시지에 부착한다. 따라서 이벤트 프로세서 B가 잘못돼도 메시지는 큐에 계속 남아 있으니 데이터 소실을 방지할 수 있다.
- 3번 이슈는 데이터베이스 본연의 ACID 트랜잭션 커밋으로 해결 가능하다. 데이터베이스에 커밋이 일어나면 데이터가 확실히 저장된다.
  - 최종 참여자 지원을 활용하면 메시지 처리가 끝나 데이터베이스에 저장됐음을 확인한 이후에 큐에서 메시지가 삭제된다. 따라서 이벤트 프로세서 A에서 데이터베이스로 가는 도중에 메시지가 소실될 일은 없다.

# 14.7 브로드캐스팅

<img width="566" alt="스크린샷 2025-06-09 오후 7 29 17" src="https://github.com/user-attachments/assets/3587a494-d382-4aed-a897-8ae34ed05dd0" />

- 이벤트 기반 아키텍처는 메시지를 누가 받든, 그 메시지로 무슨 일을 하든 상관없이 이벤트를 브로드캐스트 할 수 있다.
- 메시지 프로듀서는 자신이 보내는 메시지를 어느 이벤트 프로세서가 수신할 지, 메시지를 받아 무슨 일을 할지 모른다.
  - 그러므로 어쩌면 브로드캐스팅은 여러 이벤트 프로세스를 가장 높은 수준으로 디커플링하는 수단이다. 최종 일관성, 복잡한 이벤트 처리(CEP) 등 다양한 쓰임새를 지닌 필수 기능이다.
 
# 14.8 요청-응답
- 지금까지는 이벤트 컨슈머의 죽시 응답이 필요하지 않은 비동기 요청만 이야기했다. 하지만 서비스나 이벤트 프로세서 간에 동기 통신이 필요한 경우도 있다.

<img width="518" alt="스크린샷 2025-06-09 오후 7 33 09" src="https://github.com/user-attachments/assets/e3f7757d-0508-4130-a6df-c2a4de0d9eaf" />

- 이벤트 기반 아키텍처는 동기 통신을 요청-응답 메시징(의사 동기 통신이라고도 함) 방식으로 수행된다.
  - 요청-응답 메시징 내부의 각 이벤트 채널은 요청 큐, 응답 큐로 구성된다.
  - 처음 정보를 요청하면 요청 큐에 비동기 전송된 후 메시지 프로듀서에 제어권이 반환되며 메시지 프로듀서는 응답 큐에 응답이 도착하길 기다리며 차단 대기 상태가 된다.
  - 메시지 컨슈머가 메시지를 받아 처리한 후 응답 큐에 응답을 보내면 이벤트 프로듀서는 응답 데이터가 포함된 메시지를 수신한다.
- 요청-응답 메시지를 구현하는 주요한 기술을 두 가지이다.
  - 가장 일반적인 기술로, 메시지 헤더에 상관(correlation) ID를 사용하는 것이다. 상관 ID는 응답 메시지의 필드로, 대부분 원요청 메시지의 메시지 ID로 세팅된다.
  - 응답 큐에 임시 큐를 두고 요청-응답 메시지을 구현하는 방법이다. 임시 큐는 지정된 요청에만 사용된다. 요청이 들어오면 생성되고 요청이 들어오면 삭제된다. 임시큐는 각 요청별로 이벤트 프로듀서만 알고있는 전용 큐이므로 상관 ID가 필요하지 않다.
 
<img width="558" alt="스크린샷 2025-06-09 오후 7 40 21" src="https://github.com/user-attachments/assets/b10d8791-555f-40b3-8309-2f7090a98bc7" />
<img width="547" alt="스크린샷 2025-06-09 오후 7 43 14" src="https://github.com/user-attachments/assets/c98ee54e-366e-4c6f-b369-895bf6d48068" />

# 14.9 요청 기반이냐, 이벤트 기반이냐
- 요청 기반 모델과 이벤트 기반 모델 모두 소프트웨어 시스템을 설계하는 유효한 접근 방식이다. 시스템이 전체적으로 성공하려면 가장 알맞은 모델을 선택해야 된다.
  - 워크플로의 확정성과 제어가 중요하면 체계적인 데이터 기반의 요청(예: 고객 프로필 데이터 검색)에 특화된 요청 기반 모델을
  - 복잡하고 동적인 유저 처리 등 주로 고도의 응답성과 확장성을 요하는, 유여한 액션 단위의 이벤트를 처리한다면 이벤트 기반 모델을

| 요청 기반보다 좋은 점 | 장단점 |
|---------------------|--------|
| 동적인 유저 콘텐츠의 응답성이 좋음 | 최종 일관성만 지원됨 |
| 확장성, 탄력성이 우수함 | 처리 흐름을 제어하기 곤란함 |
| 민첩성과 변화 관리가 우수함 | 이벤트 흐름의 결과를 예측하기 어려움 |
| 적응성과 확장성이 뛰어남 | 테스팅, 디버깅이 어려움 |
| 응답성과 성능이 좋음 | |
| 실시간 의사 결정이 가능함 | |
| 상황 인지에 따른 반응성이 좋음 | |

# 14.10 하이브리드 이벤트 기반 아키텍처
- 이벤트 기반 아키텍처와 다른 아키텍처 스타일을 함께 사용하는 하이브리드 아키텍처 기반의 애플리케이션도 있다.
  - 이벤트 기반 아키텍처를 다른 아키텍처 스타일의 일부로 활용하는 아키텍처로는 마이크로서비스 아키텍처, 공간 기반 아키텍처가 대표적이다.
  - 그 밖에 이벤트 기반 마이크로커널 아키텍처, 마이크로 기반 파이프라인 아키텍처도 있다.
- 이벤트 기반 아키텍처를 추가하면 병목 지점을 제거하고 이벤트 요청을 백업하는 배압 지점(back pressure point)를 확보하는데 유용하며, 다른 아키텍처 스타일에서 찾아볼 수 없는 유저 응답성이 보장된다.
  - 마이크로서비스 아키텍처, 공간 기반 아키텍처는 데이터 펌프에 메시징을 활용하며, 다른 프로세서에 데이터를 비동기 전송하여 데이터베이스 데이터를 업데이트한다.
  - 서비스 간에 메시지를 주고받으면 통신할 때 마이크로서비스 아키텍처의 서비스와 공간 기반 아키텍처의 처리 장치 모두 이벤트 기반 아키텍처를 활용함으로써 프로그래밍 방식의 확장성을 달성할 수 있다.

# 14.11 아키텍처 특성 등급

| 아키텍처 특성 | 별점 |
|--------------|------|
| 분할 유형 | 기술 |
| 퀀텀 수 | 하나 또는 여러 개 |
| 배포성 | ⭐⭐⭐ |
| 탄력성 | ⭐⭐⭐ |
| 진화성 | ⭐⭐⭐⭐⭐ |
| 내고장성 | ⭐⭐⭐⭐⭐ |
| 모듈성 | ⭐⭐⭐⭐ |
| 전체 비용 | ⭐⭐⭐ |
| 성능 | ⭐⭐⭐⭐⭐ |
| 신뢰성 | ⭐⭐⭐ |
| 확장성 | ⭐⭐⭐⭐⭐ |
| 단순성 | ⭐ |
| 시험성 | ⭐⭐ |

- 특정 도메인이 여러 이벤트 프로세서에 분산되어 있고 중재자, 큐, 토픽을 통해 서로 묶여 있는 기술 분할된 아키텍처이다.
  - 한 도메인에 변경이 발생하면 많은 이벤트 프로세서, 중재자, 다른 메시징 아티팩트도 영향을 미치므로 도메인 분할 아키텍처는 아니다.
- 각 이벤트 프로세서의 데이터베이스 상호작용 및 요청-응답 처리를 기반으로 하므로 퀀텀 수는 1개 이상 가능하다.
  - 모든 통신은 비동기로 이루어지지만 여러 이벤트 프로세서가 단일 데이터베이스 인스턴스를 공유하는 공유 전부 동일한 아키텍처 퀀텀 내에 포함된다
  - 요청-응답 처리도 마찬가지다. 이벤트 프로세서끼리는 여전히 비동기 통신을 주고받지만 이벤트 컨슈머에게 직접 요청을 받아야 하는 구조라면 결국 해당 이벤트 프로세서는 동기적으로 함께 묶여 동일한 퀀텀에 소속된다.
- 성능, 확장성, 내고장성에 별점 5점을 주었다. 이벤트 프로세서(경쟁 컨슈머라고도 함)는 프로그래밍 방식의 로드 밸런싱이 가능하며 확장성이 매우 뛰어나다. 요청 부하가 증가하면 프로그래밍 방식으로 이벤트 프로세서를 추가해서 증가된 요청을 처리할 수 있다.
  - 이벤트 워크플로의 최종 일관성 및 최종 처리를 제공하는 고도로 분리된 비동기 이벤트 프로세서를 활용하면 내고장성을 실현할 수 있다.
  - 유저 인터페이스나 이벤트 프로세서를 제공하는 행위는 즉시 응답을 필요로 하지 않으며, 다른 다운스트림 프로세서를 사용할 수 없을 경우 나중에 이벤트를 처리할 목적으로 Promise와 Future를 이용하면 된다.
- 특유의 비결정적, 동적인 이벤트 흐름 때문에 단순성과 시험성은 상대적으로 낮다.
  - 요청 기반 모델의 확정적인 흐름은 경로와 결과가 잘 알려져있으므로 비교적 테스트하기 쉽지만 이벤트 기반 모델은 그렇지 않다.
  - 이벤트 프로세서가 동적 이벤트에 어떻게 반응할지, 어떤 메시지를 생성할지 알 수 없는 때가 더 많다.
  - 따라서 이벤트 트리 다이어그램이 매우 복잡해질 수 있고 시나리오 가짓수만 수백~수천 개에 달하므로 관리 및 테스트가 매우 어렵다
- 고도로 진화적이므로 진화성은 별점 5개이다. 신규 이벤트 프로세서를 통해 새로운 기능을 추가하는 것은 특히 브로커 토폴로지에서 비교적 간단하다.
