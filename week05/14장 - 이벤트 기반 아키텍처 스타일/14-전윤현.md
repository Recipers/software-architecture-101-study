- 이벤트 기반 아키텍처는 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 쓰이는 비동기 분산 아키텍처 스타일이다.
  - 이벤트를 비동기 수신/처리하는 별도의 이벤트 처리 컴포넌트들로 구성되며, 스탠드얼론 아키텍처 스타일을 사용하거나 다른 아키텍처 스타일에 내장할 수 있다.

<img width="612" alt="스크린샷 2025-06-09 오후 2 38 57" src="https://github.com/user-attachments/assets/0befc427-8b47-4788-a652-b145b5747753" />

- 애플리케이션은 대부분 요청 기반 모델을 따른다.
  - 이 모델에서는 어떤 액션을 수행하도록 시스템에 요청하면 요청 오케스트레이터가 접수한다.
    - 요청 오케스트레이터는 보통 유저 인터페이스이지만 API 레이어나 엔터프라이즈 서비스 버스로도 구현할 수 있다.
    - 이 컴포넌트의 임무는 다양한 요청 프로세스에 확장적으로, 동기적으로 요청을 전달하는 일이다. 요청 프로세서는 요청을 받아 데이터베이스에서 정보를 조회/수정하는 등의 작업을 수행하는 식으로 요청을 처리한다.
    - 예를 들어, 어느 시스템에서 유저가 지난 반년치 주문 이력을 검색한다고 하자. 주문 이력 조회는 특정한 콘텍스트에서 시스템에 데이터를 달라고 전달된, 데이터 기반의 확정적인 요청이지, 시스템이 반응해야 할 이벤트가 발생한 것은 아니다.
- 반면 이벤트 기반 모델은 특정한 상황에 대응하여 그 이벤트에 알맞게 액션을 취하는 형식이다.
  - 온라인 경매 사이트에서 입찰자가 어떤 품목을 입찰할 때, 입찰을 하는 행위는 시스템에 뭔가 요청을 하는 것으로도 볼 수 있다.
    - 하지만 현재 가격이 발표된 직후에 발생하는 이벤트로도 볼 수 있다. 시스템은 이벤트에 반응함으로써 동시 발생한 다른 입찰가와 비교하여 현재까지 누가 가장 높은 가격을 부른 입찰자인지 결정한다.

# 14.1 토폴로지

### 14.2 브로커 토폴로지
- 브로커 토폴로지는 중앙에 이벤트 중재자가 없다는 점에서 중재자 토폴리좌 다르다.
  - 메시지는 (RabbitMQ, ActiveMQ 등)의 경량 메시지 브로커를 통해 브로드캐스팅되는 식으로 이벤트 프로세서 컴포넌트에 분산되어 흘러간다.
  - 비교적 이벤트 처리 흐름이 단순하고 굳이 중앙에서 이벤트를 조정할 필요가 없을 때 유용하다

<img width="580" alt="스크린샷 2025-06-09 오후 2 47 46" src="https://github.com/user-attachments/assets/ef3de7fc-cc6e-418c-9da3-c26491a80135" />

- 브로커 토폴로지는 네 가지 기본 아키텍처 컴포넌트(시작 이벤트, 이벤트 브로커, 이벤트 프로세서, 처리 이벤트)로 구성된다.
  - 시작 이벤트는 단순한 이벤트든, 복잡한 이벤트든 전체 이벤트 흐름을 개시하는 이벤트를 말한다. 시작 이벤트는 이벤트 브로커의 이벤트 채널로 전송되어 처리된다.
  - 이벤트를 관리/제어하는 중재자가 브로커 토폴로지에는 없으므로 단일 이벤트 프로세서는 이벤트 브로커에서 시작 이벤트를 받자마자 관련된 처리 작업을 마친뒤 처리 이벤트를 생성하고 시스템의 나머지 부분에 자신이 한 일을 비동기로 알린다.
  - 처리 이벤트는 필요시 부가적인 처리를 위해 이벤트 브로커에 비동기 전송된다.
  - 다른 이벤트 프로세서는 처리 이벤트를 리스닝하고 있다가 이벤트가 들어오면 그에 맞는 작업을 수행한 뒤 다시 새로운 처리 이벤트를 발행함으로써 자신이 한일을 모두에게 알린다.
  - 이 과정은 최종 이벤트 프로세서가 한 일에 아무도 관심이 없을 때 까지 되풀이된다.
- 이벤트 브로커 컴포넌트는 보통 연합체(도메인 기반으로 클러스터링된 다수의 인스턴스)로 구성되며, 연합된 각 브로커에는 주어진 도메인의 이벤트 흐름에서 사용되는 모든 이벤트 채널이 들어있다.
  - 브로커 토폴로지는 속성상 fire-and-forget 방식으로 비동기 브로드캐스팅 하므로 토픽은 일반적으로 발행-구독 모델을 사용하는 브로커 토폴로지에서 사용된다.

<img width="636" alt="스크린샷 2025-06-09 오후 2 56 21" src="https://github.com/user-attachments/assets/85bce742-a7c4-4d5f-a1f4-0a2ba1cb19f3" />


- 브로커 토폴로지에서는 다른 이벤트 프로세서의 관심 여부와 무관하게 각 이벤트 프로세서가 자신이 한 일을 모두에게 알리는게 항상 바람직하다.
  - 그래야 나중에 이벤트를 처리하는 과정에서 기능 추가가 필요하게 되더라도 아키텍처를 쉽게 확장할 수 있다.
- 이것은 아키텍처 확장성의 좋은 사례다.
  - 어차피 무시될 메시지를 보내는 것이 리소스 낭비로 보일 수 있지만 실은 그렇지 않다.
  - 만약에 나중에 새로운 요구사항이 생겼을 때 따로 인프라를 추가하거나 다른 이벤트 프로세서를 변경하지 않아도 보다 수월하게 요구사항을 구현할 수 있다.

<img width="576" alt="스크린샷 2025-06-09 오후 2 57 49" src="https://github.com/user-attachments/assets/23d16939-f877-4222-9804-e4d703937fd5" />

- 어느 서점의 주문 입력 시스템에서 이벤트가 처리되는 흐름이다.
  - 품목(도서)에 대해 주문이 접수되면 OrderPlacement 이벤트 프로세서는 시작 이벤트(PlaceOrder)를 받아 데이터베이스 테이블에 주문을 삽입한 다음 고객에게 주문 ID를 반환한다.
  - 그리고 나서 자신이 주문을 생성했음을 order-created 처리 이벤트를 통해 나머지 프로세서에게 통보한다.
  - order-created 처리 이벤트에 관심 있는 이벤트 프로세서는 Notification, Payment, Inventory 3개이다. 이들은 각자의 임무를 나란히 수행한다.
- order-created 처리 이벤트를 접수한 Notification 이벤트 프로세서는 고객에게 이메일을 보낸 후 또 다른 처리 이벤트(email-sent)를 생성한다.
- Inventory 이벤트 프로세서도 order-created 처리 이벤트를 받아 해당 품목의 재고를 차감한 후 inventory-updated 처리 이벤트를 통해 자신이 완료한 작업을 알린다.
  - Warehouse 이벤트 프로세서는 이 이벤트를 받아 창고 간 재고 상태를 관리하고 재고 부족 시 해당 품목을 재주문한다.
- Payment 이벤트 프로세서 역시 order-created 처리 이벤트를 받아 방금 주문한 고객의 신용카드를 결제 처리한다.
  - 결제가 완료됐음을 나머지 시스템에 알리는 이벤트(payment-applied), 승인 거절됐음을 나머지 시스템에 알리는 이벤트(payment-denied), 이렇게 두 가지의 이벤트를 생성한다.
    - 이 중 Notification 이벤트 프로세서는 payment-denied 처리 이벤트에만 관심이 있다. 승인 거절시 고객이 신용카드 정보를 업데이트하거나 다른 방법으로 결제하도록 이메일로 유도해야 하기 때문이다.
- OrderFulfillment 이벤트 프로세서는 payment-applied 처리 이벤트를 받아 오더 피킹과 포장 작업을 수행한다.
  - 작업을 마치면 order-fulfilled 처리 이벤트를 발행해서 주문이 이행됐음을 나머지 시스템에 알린다.
  - 이 이벤트는 Notification 이벤트 프로세서, Shipping 이벤트 프로세서가 수신한다.
    - Notifiaction 이벤트 프로세서는 주문이 이행됐고, 배송 준비가 완료됐음을 고객에게 알린다.
    - Shipping 이벤트 프로세서는 적절한 배송 방법을 선택하여 주문을 배송하고 order-shipped 처리 이벤트를 발행한다.
      - 이 이벤트를 받은 Notification 이벤트 프로세서는 고객에게 주문 상태가 변경됐음을 알린다.
- 예제를 보면 모든 이벤트 프로세서가 고도로 분리되어 있고, 서로 독립적으로 움직인다.
  - 이벤트 프로세서는 이벤트 전달 후 더 이상 그 이벤트 처리에는 관연하지 않고 다른 시작 이벤트 또는 처리 이벤트에 반응할 준비를 한다.
  - 각 이벤트 프로세서는 처리 도중 가변적인 부하나 백업 조건을 처리하기 위해 서로 독립적으로 확장할 수 있다.
  - 만약 어떤 환경 문제로 인해 이벤트 프로세서가 느려지거나 실패하면 그 프로세서가 구독하는 토픽이 배압(back-pressure) 지점이 된다.
- 브로커 토폴로지는 성능, 응답성, 확장성 측면에서 장점이 많지만 단점도 적지 않다.
  - 무엇보다 시작 이벤트와 관련된 전체 워크플로를 제어할 수 없다.
  - 따라서 다양한 조건에 따라 상황이 매우 유동적이고, 어느 시스템 파트도 실제 주문 트랜잭션이 언제 끝났는지 알 수 없다.
  - 에러 처리 역시 어렵다. 비즈니스 트랜잭션을 관찰/통제하는 중재자가 없으므로 처리가 실패해도 다른 파트는 그 사실을 모른다. 결국 비즈니스 프로세스는 교착 상태에 빠지고 뭔가 다른 조치를 해주지 않으면 프로세스는 정체된다.
    - 게다가 이런 에러가 나든 안 나든 다른 모든 프로세스는 그냥 알아서 작동한다.
- 비즈니스 트랜잭션을 재시작하는 기능(복구성)도 브로커 토폴로지에서 지원되지 않는다.
  - 처음 시작 이벤트를 처리할 때 부터 이미 다른 작업이 비동기로 수행된 터라 시작 이벤트를 다시 넣는 것은 불가능하다.
 
| 장점 | 단점 |
|------|------|
| 이벤트 프로세서가 디커플링됨 | 워크플로 제어 |
| 확장성 높음 | 에러 처리 |
| 응답성 우수함 | 복구성 |
| 성능 우수함 | 재시작 능력 |
| 내고장성 뛰어남 | 데이터 비일관성 |

# 14.3 중재자 토폴로지
- 중재자 토폴로지는 좀 전에 살펴본 브로커 토폴로지의 단점을 일부 보완한다.
  - 여러 이벤트 프로세서 간의 조정이 필요한 시작 이벤트에 대하여 워크플로를 관리/제어하는 이벤트 중재자가 핵심이다.
  - 중재자 토폴로지는 시작 이벤트, 이벤트 큐, 이벤트 중재자, 이벤트 채널, 이벤트 프로세서, 이렇게 5개의 아키텍처 컴포넌트로 구성된다.

<img width="561" alt="스크린샷 2025-06-09 오후 5 12 38" src="https://github.com/user-attachments/assets/ed637ad8-26f0-46e8-acce-273121a00ff3" />

- 시작 이벤트는 중재자 토폴로지에서 시작 이벤트를 거쳐 이벤트 중재자로 전달된다.
  - 이벤트 중재자는 이벤트 처리에 관한 단계 정보만 갖고 있다. 점대점 메시징으로 각각의 이벤트 채널(대부분 큐)로 전달되는 처리 이벤트를 생성한다.
  - 각 이벤트 프로세서는 자신의 이벤트 채널에서 이벤트를 받아 처리한 다음 중재자에게 작업을 완료했다고 응답한다.
- 중재자 토폴로지 구현체에는 대부분 특정 도메인이나 이벤트 그룹과 연관된 중재자가 여럿 존재하므로 단일 장애점을 줄이고 전체 처리량과 성능을 높일 수 있다.
- 이벤트 중재자는 처리하는 이벤트의 특성과 복잡도에 따라 다양한 방법으로 구현할 수 있다.
  - 간단한 에러 처리와 오케스트레이션이 필요한 이벤트는 Apache Camel, Mule, ESB, Spring Integration등으로 충분하다.
  - 이벤트 워크플로에 조건부 처리가 많고 동적 경로가 많아 에러 처리가 복잡하다면 아파치 ODE, BPEL을 기반으로한 오케스트레이션을 구현하는 편이 더 낫다.
 
<img width="589" alt="스크린샷 2025-06-09 오후 5 19 23" src="https://github.com/user-attachments/assets/e3aa9e01-b0f4-4ee9-9919-f81b6066907b" />

- 이벤트 복잡도를 단순함, 어려움, 복잡함 정도로 분류한 뒤 모든 이벤트가 항상 단순한 중재자를 거치도록 하는 것이 좋다.
  - 그러면 이 중재자는 이벤트 등급에 따라 이벤트를 직접 처리하거나 더 복잡한 다른 이벤트 중재자에게 위임한다.
 
<img width="570" alt="스크린샷 2025-06-09 오후 5 22 26" src="https://github.com/user-attachments/assets/3eb37dc9-d9e3-4437-98f0-f7c154ea1392" />

- 브로커 토폴로지로 구현했던 서점 주문 입력 시스템을 중재자 토폴로지로 변경하는 예
  - 동일하게 시작 이벤트(PlaceOrder)를 customer-event-queue로 흘려 처리를 개시한다.
  - Customer 중재자는 이 시작 이벤트를 받아 처리 이벤트를 생성하는데 2, 3, 4단계의 처리 이벤트는 모두 동시에 발생하면서 단계별로 처리된다.

<img width="543" alt="스크린샷 2025-06-09 오후 5 29 02" src="https://github.com/user-attachments/assets/0fe8b3f5-b666-4e3d-9a3f-9e7e3b4dc8c9" />

- 시작 이벤트를 접수한 Customer 중재자는 먼저 create-order 처리 이벤트를 생성하고 이 메시지를 order-placement-queue로 보낸다.
  - OrderPlacement 이벤트 프로세서는 이 이벤트를 받아 문제가 없는지 확인한 뒤 주문 ID와 함께 중재자에게 확인 응답한다.

<img width="565" alt="스크린샷 2025-06-09 오후 5 31 52" src="https://github.com/user-attachments/assets/925120bc-7051-4831-b927-13c29f4d0791" />

- 1단계가 끝났으니 중재자는 2단계로 넘어가 세 처리 이벤트, email-customer, apply-payment, adjust-inventory를 동시에 만들어 각각 지정된 큐로 전달한다
  - 세 이벤트 프로세서는 모두 메시지를 받아 할 일을 한 다음 처리가 완료됐음을 중재자에게 알린다.
  - 중재자는 3단계로 이동하기 위해 3개의 병렬 프로세스로부터 모두 확인 응답을 받을 때 까지 대기한다. 어느 한 곳이라도 문제가 발생하면 중재자는 조치를 취할 수 있다.
 
<img width="586" alt="스크린샷 2025-06-09 오후 5 32 05" src="https://github.com/user-attachments/assets/12666d08-d3b4-45b2-84c1-5896034be808" />

- 2단계의 세 이벤트 프로세서로부터 정상 확인 응답을 받은 중재자는 이제 3단계로 넘어가 주문을 이행한다.
  - 이 때 fulfill-order, order-stock 두 이벤트는 동시에 발생할 수 있고, OrderFulfillment, Warehouse 이벤트 프로세서는 각자 해야 할 일을 하고 중재자에게 확인응답을 한다.

<img width="594" alt="스크린샷 2025-06-09 오후 5 33 51" src="https://github.com/user-attachments/assets/549dd3a7-d7f5-4390-951f-b4f39d5e47ca" />

- 중재자는 4단계로 넘어가 주문을 배송한다. 이 때 ship-order 이벤트 뿐만 아니라 다음에 해야 할 일에 관한 정보가 담긴 email-customer 처리 이벤트도 함께 생성한다.

<img width="594" alt="스크린샷 2025-06-09 오후 5 51 13" src="https://github.com/user-attachments/assets/c6e4a401-9288-418d-88e7-c6e9f4b472c9" />

- 마지막으로, 중재자는 5단계로 넘어가 email-customer 이벤트를 하나 더 생성한 뒤 주문이 배송됐음을 고객에게 알린다.
- 중재자 컴포넌트는 브로커 토폴로지와 달리 워크플로에 대해 잘 알고 있고 통제가 가능하다.
  - 중재자는 워크플로를 제어하므로 이벤트 상태를 유지하면서 필요 시 에러 처리, 복구, 재시작을 할 수 있다.
- 두 토폴로지는 처리 이벤트의 의미와 사용 방법이 본질적으로 다르다
  - 브로커 토포롤지에서는 시스템에서 발생한 이벤트로 처리 이벤트가 발행되고 이벤트 프로세서는 각자 맡은 일을 하면서 나머지 이벤트 프로세서는 그 액션에 반응하는 식으로 돌아간다.
  - 중재자 토폴로지에서 처리 이벤트는 사건(이미 일어난 일)이 아니라 커맨드(일어나야 할 일)이다.
  - 따라서 중재자 토폴로지에서는 처리 이벤트가 반드시 처리 되어야 할 이벤트인 반면 브로커 토폴로지에서는 그냥 무시해도 된다.
- 중재자 토폴로지는 브로커 토폴로지에서 불가능한 문제를 해결할 수 있지만 그만큼 부정적인 면도 있다.
  - 이벤트 흐름 내에서 발생하는 동적인 처리를 선언적으로 모델링하기 어렵다. 그래서 보통은 중재자의 내부 워크플로는 일반적인 처리만하고 복잡한 이벤트 처리의 변화무쌍한 부분은 중재자 + 브로커 형태의 하이브리드 모델로 처리한다
  - 이벤트 프로세서는 브로커 토폴로지와 동일한 방식으로 쉽게 확장할 수 있지만, 중재자도 함께 확장해야 하므로 전체 이벤트 처리 흐름에 병목 지점이 생기기 쉽다
  - 이벤트 처리를 중재자가 제어하므로 이벤트 프로세서가 상대적으로 더 많이 커플링되어 성능은 브로커 토폴로지보다 좋지 않다.
 
| 장점 | 단점 |
|------|------|
| 워크플로 제어 | 이벤트 프로세서가 커플링됨 |
| 에러 처리 | 확장성 낮음 |
| 복구성 | 성능 낮음 |
| 재시작 능력 | 내고장성 출지 않음 |
| 데이터 일관성 | 워크플로 모델링 복잡함 |재시도Claude는 실수를 할 수 있습니다. 응답을 반드시 다시 확인해 주세요.

- 브로커냐 중재자냐, 결국 워크플로 제어와 에러 처리 기능이 우선인가, 아니면 고성능과 확장성이 더 중요한가의 트레이드오프를 잘 따져 선택해야 된다.

# 14.4 비동기 통신
