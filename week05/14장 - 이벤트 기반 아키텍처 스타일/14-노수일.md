# 14. 이벤트 기반 아키텍처 스타일
- 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 쓰이는 비동기 분산 아키텍처 스타일
- 적응성이 좋아서 소규모 부터 크고 복잡한 애플리케이션까지 두루 사용 가능
- 이벤트를 비동기 수신/처리하는 별도의 이벤트 처리 컴포넌트들로 구성
- 스탠드얼론 아키텍처 스타일로 사용하거나 다른 아키텍처 스타일 (이벤트 기반 마이크로 서비스 아키텍처)에 내장할 수도 있음
- 애플리케이션은 대부분 요청 기반 모델을 따름
    - 이 모델에서는 어떤 액션을 수행하도록 시스템에 요청하면 요청 오케스트레이터가 접수
    - 요청 오케스트레이터는 보통 유저 인터페이스이지만, API 레이어나 엔터프라이즈 서비스버스로도 구현할 수 있음
    - 이 컴포넌트의 임무는 다양한 요청 프로세서에 확정적으로, 동기적으로 요청을 전달하는 일
    - 요청 프로세서는 요청을 받아 데이터베이스에서 정보를 조회/수정하는 등의 작업을 수행
- 이벤트 기반 모델은 특정한 상황에 대응하여 그 이벤트에 알맞게 액션을 취함
## 14.1 토폴로지
- 중재자 토폴로지와 브로커 토폴로지
- 중재자 토폴로지
    - 이벤트 처리 워크플로를 제어해야 할 경우
- 브로커 토폴로지
    - 신속한 응답과 동적인 이벤트 처리 제어가 필요할 떄 사용됨
## 14.2 브로커 토폴로지
- 중앙에 이벤트 중재자가 없다는 점에서 중재자 토폴로지와 다름
- 메시지는 경량 메세지 브로커(RabbitMQ, ActiveMQ, HornetQ 등)를 통해 브로드캐스팅되는 식으로 이벤트 프로세서 컴포넌트에 분산되어 흘러감
- 이벤트 처리 흐름이 단순하고 중앙에서 이벤트를 조장할 필요가 없을 때 유용함
- 네 가지 기본 아키텍처 컴포넌트
    - 시작 이벤트
        - 전체 이벤트 흐름을 개시하는 이벤트
    - 이벤트 브로커
        - 이벤트 브로커의 이벤트 채널로 전송되어 처리됨
    - 이벤트 프로세서
        - 이벤트를 관리/제어하는 중재자가 브로커 토폴로지에 없으므로
        - 단일 이벤트 프로세서는 이벤트 프로커에서 시작 이벤트를 받고 관련된 처리 작업을 마친 뒤 처리 이벤트를 생성하고 시스템에 자신이 한 일을 비동기로 알림
    - 처리 이벤트
        - 필요시 부가적인 처리를 위해 이벤트 브로커에 비동기 전송됨
- 이 과정은 최종 이벤트 프로세서가 한 일에 아무도 관심이 없을 때까지 되풀이됨
- 이벤트 브로커 컴포넌트는 보통 연합체(도메인 기반으로 클러스터링된 다수의 인스턴스)로 구성
- 연합된 각 브로커에는 주어진 도메인의 이벤트 흐름에서 사용된 모든 이벤트 채널이 들어 있음
- 브로커 토폴로지는 속성상 파이어 앤드 포겟 방식으로 비동기 브로드캐스팅을 하므로 토픽은 일반적으로 발행-구독 메시징 모델을 사용하는 브로커 토폴로지에서 사용됨
- 브로커 토폴로지에서는 다른 이벤트 프로세서의 관심 여부와 무관하게 각 이벤트 프로세서가 자신이 한 일을 모두에게 알리는게 항상 바람직함
    - 나중에 이벤트를 처리하는 과정에서 기능추가가 필요하게 되더라도 아키텍처를 쉽게 확장할 수 있음
    - 어차피 무시될 메세지를 보내는 것이 낭비 같아 보이지만, 기능 추가 측면에서는 확장성에 좋은 사례가 됨
- 주문 입력 시스템
    - OrderPlacement 이벤트 프로세서는 시작 이벤트(PlaceOrder)를 받아 DB 테이블에 주문을 삽입한 다음 고객에게 주문 ID를 반환
        - 주문을 생성했음을 order-created 처리 이벤트를 통해 나머지 프로세서에 통보
        - order-created 처리 이벤트 프로세서 : Notification, Payment, Inventory
    - Notification 이벤트 프로세서는 이메일을 보낸 후 또 다른 처리 이벤트를 생성(email-sent)
        - 나중에 다른 이벤트가 해당 이벤트를 받아 활용할 수 있는 걸쇠를 장치
    - Inventory 이벤트 프로세서도 order-created를 받아 재고 차감 후 inventory-updated 처리 이벤트를 통해 자신이 완료한 작업을 알림
        - Warehouse 이벤트 프로세서는 이 이벤트를 받아 창고 간 재고 상태를 관리하고 재고 부족 시 해당 품목을 재주문
    - Payment 이벤트 프로세서 역시 order-created를 받아 주문 고객의 신용 카드르 결제
        - 결제 완료 (payment-applied), 승인 거절 이벤트 (payment-denied) 이벤트 생성
        - Notification 이벤트 프로세서는 payment-denied 처리 이벤트에 관심
    - OrderFulfillment 이벤트 프로세서는 payment-applied 처리 이벤트를 받아 오더 피킹과 포장 작업을 수행
        - 작업을 마치면 order-fulfilled 처리 이벤트 발행
        - Notification, Shipping 이벤트 프로세서가 수신
    - Shipping 이벤트 프로세서는 적절한 배송 방법을 선택하여 주문을 배송하고 order-shipped 처리 이벤트를 발행
        - Notification 이벤트 프로세서가 수신
- 모든 이벤트 프로세서가 고도로 분리되어 있고 서로 독립적으로 움직임
- 이벤트 프로세서는 이벤트 전달 후 더 이상 그 이벤트 처리에는 관여하지 않고 다른 시작 이벤트 또는 처리 이벤트에 반응할 준비를 함
- 이벤트 처리 도중 가변적인 부하나 백업 조건을 처리하기 위해 서로 독립적으로 확장할 수 있음
- 장점
    - 성능
    - 응답성
    - 확장성
- 단점
    - 시작 이벤트와 연관된 전체 워크플로를 제어할 수 없음
    - 다양한 조건에 따라 상황이 유동적이고, 어떤 파트도 트랜잭션이 언제 끝났는지 모름
    - 에러 처리도 어려움
    - 비즈니스 트랜잭션을 재시작하는 기능도 지원되지 않음
- 장단점 정리
    |장점|단점|
    |--|--|
    |이벤트 프로세서가 디커플링 됨|워크플로 제어|
    |확장성 높음|에러 처리|
    |응답성 우수함|복구성|
    |성능 우수함|재시작 능력|
    |내고장성 뛰어남|데이터 일관성|
## 14.3 중재자 토폴로지
- 브로커 토폴로지의 단점들을 일부 보완
- 여러 이벤트 프로세스 간 워크플로를 관리/제어하는 이벤트 중재자가 핵심
- 구성 컴포넌트
    - 시작 이벤트
    - 이벤트 큐
    - 이벤트 중재자
    - 이벤트 채널
    - 이벤트 프로세서
- 시작 이벤트는 시작 이벤트 큐를 거쳐 이벤트 중재자로 전달됨
- 이벤트 중재자는 이벤트 처리에 관한 단계 정보만 가지고 있음
    - 점대점 메시징으로 각각의 이벤트 채널로 전달되는 처리 이벤트를 생성
- 이벤트 프로세서는 자신의 이벤트 채널에서 이벤트를 받아 처리한 다음 중재자에게 작업 완료 응답
- 중재자 토폴로지 구현체에는 대부분 특정 도메인이나 이벤트 그룹과 연관된 중재자가 여럿 존재
    - 단일 장애점을 줄이고 전체 처리량과 성능을 높일 수 있음
- 이벤트 중재자는 처리하는 이벤트의 특성과 복잡도에 따라 다양한 방법으로 구현할 수 있음
    - 간단한 에러 처리와 오케스트레이션이 필요한 이벤트
        - 아파치 카멜, 뮬 ESB, 스프링 인티그레이션
        - 워크플로를 프로그래밍 코드로 제어
    - 이벤트 워크플로에 조건부 처리가 많고 동적 경로가 많아 에러 처리가 복잡하다면
        - 아파치 ODE, 오라클 BPEL 프로세스 관리자
        - 이벤트 처리 단계를 기술하는 BPEL을 기반
        - BPEL 아티팩트에는 에러 처리, 리다이렉션, 멀티 캐스팅 기능을 하는 요소들이 체계적으로 구현
        - BPEL
            - 복잡하고 동직인 워크플로에는 잘 맞음
            - 이벤트 처리 단계 중 사람이 개입하는, 실행시간이 긴 트랜잭션이 필요한 이벤트 워크플로에는 적합하지 않음
        - BPM 엔진
            - 사람이 개입하는 복잡하고 실행시간이 긴 이벤트 처리에 적합
    - 이벤트 복잡도에 알맞은 이벤트 중재자 구현체를 선택해야됨
- 주문 입력 시스템
    - 시작 이벤트(PlaceOrder)를 customer-event-queue로 흘려 처리 개시
    - Customer 중재자는 시작 이벤트를 받아 처리 이벤트를 생성
        - 2(주문 처리), 3(주문 이행), 4(주문 배송) 단계 처리 이벤트는 모두 동시에 발생하며 단계별로 처리됨
    - 1단계
        - Customer 중재자는 create-order 처리 이벤트를 생성하고 order-placement-queue 로 보냄
        - OrderPlacement 이벤트 프로세서는 이 이벤트를 받아 문제가 없는지 확인한 뒤 주문 ID와 함께 중재자에 확인 응답
    - 2단계
        - email-customer, apply-payment, adjust-inventory를 동시에 만들어 각각 지정된 큐로 전달
        - Notification, Payment, Inventory 세 이벤트 프로세서는 메시지 받아 처리 후 완료를 중재자에게 알림
        - 3단계로 이동하기 전, 3개 병렬 프로세스로부터 모두 확인응답을 받을때까지 대기
            - 어느 한곳이라도 에러가 발생하면 문제 해결을 위한 조치
    - 3단계
        - fulfill-order, order-stock 동시에 발생
        - OrderFulfillment, Warehouse 이벤트 프로세서는 두 이벤트를 받아 처리 후 중재자에게 확인 응답
    - 4단계
        - ship-order 이벤트, email-customer 처리 이벤트 생성
    - 5단계
        - email-customer 이벤트를 하나 더 생성하여 주문이 배송됐음을 고객에게 알림
        - 워크플로 완료 후 시작 이벤트 흐름을 완료로 마킹 후, 연관된 상태를 모두 삭제
- 중재자 컴포넌트는 워크플로에 대해 잘 알고 있고 통제가 가능함
    - 이벤트 상태를 유지하면서 필요시 에러 처리, 복구, 재시작할 수 있음
- 브로커 토폴로지에서는 발생한 이벤트로서 처리 이벤트가 발행됨
    - 이벤트 프로세서는 각자 맡은 일을 하면서 나머지 이벤트 프로세서는 그 액션에 반응하는 식으로 돌아감
    - 처리 이벤트는 무시해도 됨
- 중재자 토폴로지에서 처리 이벤트는 사건(이미 일어난 일)이 아니라 커맨드(일어나야 할 일)
    - 처리 이벤트가 반드시 처리되어야 할 이벤트
- 부정적인 요소
    - 복잡한 이벤트 흐름 내에서 발생하는 동적인 처리를 선언적으로 모델링하기 어려움
    - 이벤트 프로세서는 브로커 토폴로지와 동일한 방식으로 쉽게 확장할 수 있지만, 중재자도 함께 확장해야 하므로 전체 이벤트 처리 흐름에 병목지점이 생길 수 있음
    - 이벤트 처리를 중재자가 제어하므로 이벤트 프로세서가 상대적으로 더 많이 커플링되어 성능은 좋지 않음
- 장단점 정리
    |장점|단점|
    |--|--|
    |워크플로 제어|이벤트 프로세서가 커플링 됨|
    |에러 처리|확장성 낮음|
    |복구성|성능 낮음|
    |재시작 능력|내고장성 좋지 않음|
    |데이터 일관성|워크플로 모델링 복잡함|
## 14.4 비동기 통신
- 이벤트 기반 아키텍처 스타일은 요청/응답 처리 뿐만 아니라 응답이 필요 없는 파이어 앤드 포겟 처리 모두 비동기 통신만 사용한다는 점이 차별화됨
- 비동기 통신은 시스템 응답성을 전반적으로 높이는 강력한 기법으로 활용할 수 있음
- 댓글 게시
    - 파싱 엔진을 거침
    - 댓글 게시에 3,000 밀리초
    - REST 동기 호출 시, 총 3,100 밀리초의 응답 시간
    - 비동기 전송하면, 댓글 게시에 25밀리 초
        - 실제 댓글 게시까지는 여전이 3,025밀리초
        - 최종 유저 관점에서는 댓글 처리는 완료된 셈
    - 응답성과 성능의 차이가 보여지는 예시
    - 어떤 정보를 돌려받을 필요가 없으면 기다리게 할 이유도 없음
    - 성능은 종단간 프로세스가 더 빨리 수행되게끔 하는 것
    - 성능이 아닌 응답성을 개선한 것
    - 동기 호출은 댓글이 게시되었음을 최종 유저에게 보장함
    - 비동기 호출은 미래의 약속과 함께 확인 응답을 받은 것뿐
        - 댓글이 게시되지 않을 수 있음
- 비동기 통신에서는 에러 처리가 가장 큰 문제임
    - 워크플로 이벤트 패턴이라는 리액티브 아키텍처 패턴으로 해결할 수 있음
## 14.5 에러 처리
- 리액티브 아키텍처 패턴은 비동기 워크플로에서 에러 처리 문제를 해결하는 한 가지 방법
- 탄력성과 응답성, 시스템을 응답성에 영향을 미치지 않고 탄력적으로 에러를 처리할 수 있게 만드는 패턴
- 워크플로 대리자를 통해 위임, 봉쇄, 수리 작업을 함
    - 이벤트 프로듀서는 메시지 채널을 통해 데이터를 이벤트 컨슈머에게 비동기로 전송
    - 이벤트 컨슈머가 데이터를 처리하는 도중 에러가 발생하면 즉시 해당 에러를 워크플로 프로세스에게 위임
    - 이벤트 큐에 있는 다음 메시지로 넘어감
- 에러가 발생해도 바로 다음 메시지를 처리하므로 전체 응답성에는 형향을 받지 않음
- 에러를 수신한 워크플로 프로세서는 메시지에 뭐가 잘못됐는지 살펴봄
    - 정적, 확정적 에러도 있지만, 메시지 분석으로 데이터의 이상한 점을 조사해야 할 수 있음
    - 원 데이터를 변경해서 긴급 조치 후 원래 큐로 돌려보냄
    - 컨슈머는 새로운 메세지를 재처리 시도
- 끝내 메시지의 문제점을 파악할 수 없는 경우 다른 큐로 보내 대시보드라는 애플리케이션이 받음
    - 대시보드는 업무 담당자 데스크탑에 위치
    - 담당자는 직접 메시지를 확인해 조치하고 원래 큐로 다시 전송
- 에러가 발생한 메시지를 조치 후 다시 제출하면 처리 순서가 바뀌는 점을 주위해야 함
## 14.6 데이터 소실 방지
- 비동기 통신 시, 데이터 소실은 언제나 중요한 관심사
- 이벤트 기반 아키텍처는 데이터가 소실될 만한 곳이 많음
- 데이터 소실
    - 메시지가 도중에 삭제되거나 최종 목적지에 도착하지 못한 상태
- 데이터 소실 시나리오 : 이벤트 프로세서 A가 큐에 메시지를 비동기 전송하고 이벤트 프로세서 B는 메시지를 받아 데이터베이스에 삽입
    1. 이벤트 프로세서 A에서 메시지가 큐로 전달되지 않는다, 전달되어도 다음 이벤트 프로세서가 메시지를 가져오기 전에 브로커가 다운
    2. 이벤트 프로세서 B가 큐에서 메시지를 꺼내 이벤트를 처리하기 전에 장애가 발생
    3. 데이터 에러로 인해 이벤트 프로세서 B가 데이터베이스에 메시지를 저장할 수 없음
- 기본적인 메시징으로 어느정도 해결 가능
    1. 동기 전송과 퍼시스턴트 메시지 큐를 이용하면 쉽게 해결
        - 퍼시스턴스 메시지 큐는 전달 보장도 지원함
        - 메시지 브로커가 메시지를 수신하면 신속한 조회를 위해 메모리에 저장하는 동시에 물리적 데이터 저장소에도 메시지를 저장
        - 동기 전송은 메시지를 저장했다고 확인응답을 줄 때까지 메시지 프로듀서를 차단하여 기다리게 함
    2. 클라이언트 확인응답 모드라는 메시징 기술을 이용하면 해결 가능
        - 큐에서 빠져나가는 즉시 삭제하지 않고, 큐에 보관한 채 다른 컨슈머가 메시지를 읽을 수 없게 클라이언트 ID를 메세지에 부착
    3. 데이터베이스 본연의 ACID 트랜잭션 커밋으로 해결 가능
        - 데이터베이스에 커밋이 일어나면 데이터가 확실하게 저장됨
        - 최종 참여자 지원을 활용하면 메시지 처리가 끝나 데이터베이스에 저장됐음을 확인한 후 큐에서 메시지가 삭제
## 14.7 브로드캐스팅
- 메시지를 누가 받든 무슨 일을 하든 상관없이 이벤트를 브로드캐스트 할 수 있음
- 여러 이벤트 프로세서를 가장 높은 수준으로 디커플링하는 수단
- 최종 일관성, 복잡한 이벤트 처리 등 다양한 쓰임새를 지닌 필수 기능
## 14.8 요청-응답
- 동기 통신을 요청-응답 메시징 방식으로 수행 (의사 동기 통신)
- 요청-응답 메시징 내부의 각 이벤트 채널은 요청 큐, 응답 큐로 구성됨
- 처음 정보를 요청하면 요청 큐에 비동기 전송된 후 메시지 프로듀서에게 제어권이 반환
- 메시지 프로듀서는 응답 큐에 응답이 도착하길 기다리며 차단 대기 상태가 됨
- 메시지 컨슈머가 메시지를 받아 처리한 후 응답 큐에 응답을 보내면 이벤트 프로듀서는 응답 데이터가 포함된 메시지를 수신
- 요청-응답 메시징을 구현하는 주요한 기술은 두 가지
    - 메시지 헤더에 상관 ID를 사용
        - 상관 ID는 응답 메시지의 필드로, 대부분 원격 요청 메시지의 메시지 ID로 세팅됨
        - 처리 흐름
            1. 이벤트 프로듀서는 요청 큐에 메시지를 보내고 고유한 메시지 ID를 기록
            2. 이벤트 프로듀서는 메시지 필터로 응답 큐를 차단 대기함
            3. 이벤트 컨슈머는 메시지 ID를 받아 요청을 처리함
            4. 이벤트 컨슈머는 응답 메시지를 생성하고 메시지 헤더의 상관 ID를 원메시지 ID로 세팅
            5. 이벤트 컨슈머는 새 메시지를 응답 큐로 보냄
            6. 2단계의 메시지 셀렉터와 상관ID가 일치하므로 이벤트 프로듀서는 메시지를 수신
    - 응답 큐에 임시 큐를 두고 요청-응답 메시징을 구현
        - 임시 큐는 지정된 요청에만 사용
        - 요청이 들어오면 생성되고 요청이 종료되면 삭제
        - 임시 큐는 각 요청별로 이벤트 프로듀서만 알고 있는 전용 큐이므로 상관 ID는 필요하지 않음
        - 작동 메커니즘
            1. 이벤트 프로듀서는 임시 큐를 생성하고 reply-to 헤더에 임시 큐 이름을 세팅하여 요청 큐에 메시지를 보냄
            2. 이벤트 프로듀서는 임시 응답 큐를 차단 대기하면서 응답이 도착하길 기다림, 이 큐에 전달된 메시지는 원메시지를 보낸 이벤트 프로듀서에게만 속하므로 따로 메시지 셀렉터는 필요 없음
            3. 이벤트 컨슈머는 메시지를 받아 요청을 처리한 후 reply-to 헤더에 세팅된 이름을 가진 응답 큐로 응답 메시지를 보냄
            4. 이벤트 프로세서는 메시지를 수신한 다음 임시 큐를 삭제
- 기술적으로는 임시 큐가 훨씬 단순하지만 메시지 브로커는 매번 요청을 처리할 때마다 임시 큐를 생성/폐기하는 일을 반복해야 함
- 대용량 메시지 처리 시 메시지 브로커의 속도가 크게 떨어지고 전체 성능과 응답성 역시 영향을 받을 수 있음
- 대체로 상관 ID를 사용하는 방법을 권장함
## 14.9 요청 기반이냐, 이벤트 기반이냐
- 워크플로의 확정성과 제어가 중요하면 체계적인 데이터 기반의 요청에 특화된 요청 기반 모델
- 복잡하고 동적인 유저 처리 등 주로 고도의 응답성과 확장성을 요하는, 유연한 액션 단위의 이벤트를 처리한다면 이벤트 기반 모델이 좋은 선택
- 이벤트 기반 모델의 장단점
    |요청 기반보다 좋은점|장단점|
    |--|--|
    |동적인 유저 콘텐츠의 응답성이 좋음|최종 일관성만 지원됨|
    |확장성, 탄력성이 우수함|처리 흐름을 제어하기 곤란함|
    |민첩성과 변화 관리가 우수함|이벤트 흐름의 결과를 예측하기 어려움|
    |적응성과 확장성이 뛰어남|테스팅, 디버깅이 어려움|
    |응답성과 성능이 좋음||
    |실시간 의사 결정이 가능함||
    |상황 인지에 따른 반응성이 좋음||
## 14.10 하이브리드 이벤트 기반 아키텍처
- 이벤트 기반 아키텍처와 다른 아키텍처 스타일을 함께 사용하는 하이브리드 아키텍처 기반의 애플리케이션도 있음
    - 마이크로서비스 아키텍처
    - 공간 기반 아키텍처
    - 이벤트 기반 마이크로커널 아키텍처
    - 이벤트 기반 파이프라인 아키텍처
- 이벤트 기반 아키텍처를 추가하면 좋은 점
    - 요청을 백업하는 배압 지점을 확보하는데 유용
    - 유저 응답성이 보장됨
    - 프로그래밍 방식의 확장성을 달성할 수 있음
## 14.11 아키텍처 특성 등급
- 특정 도메인이 여러 이벤트 프로세서에 분산되어 있고 중재자, 큐, 토픽을 통해 서로 묶여 있는, 기술 분할된 아키텍처
- 도메인 변경이 많은 아티팩트에 영향을 미치므로 도메인 분할 아키텍처는 아님
- 퀀텀 수는 1개 이상 가능
- 성능, 확장성, 내고장성이 주요 강점
    - 프로그래밍 방식의 로드 밸런싱이 가능하며 확장성이 뛰어남
    - 최종 일관성 및 최종 처리를 제공하는 고도로 분리된 비동기 이벤트 프로세서를 활용하면 내고장성을 실현할 수 있음
- 특유의 비결정적, 동적인 이벤트 흐름 때문에 단순성과 시험성은 상대적으로 낮은 편
    - 이벤트 트리 다이어그램이 매우 복잡해질 수 있고 시나리오 가짓수만 수백~ 수천 개에 달하므로 관리 및 테스트가 어려움
- 고도로 진화적이므로 진화성이 높음
