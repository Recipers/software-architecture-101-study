
# 1.1 소프트웨어 아키텍처란?
- 아키텍처 특성
	- 시스템의 기능과 직교하는 시스템의 성공 기준 (가용성, 신뢰성, 보안, 확장성 등등)
- 아키텍처 결정
	- 시스템 구축에 필요한 규칙들을 정의한 것, 즉 소프트웨어에서 지켜야할 원칙들 (레이어드 아키텍처에서 프레젠테이션 레이어가 데이터베이스에 직접 액세스하지 못한다)
	- 이러한 원칙들을 반드시 지킬 수는 없으므로 특정 시점에 논의하여 지킬 수 없는 아키텍처 결정을 완화하기도 한다
- 설계 원칙
	- 위의 아키텍처 결정이 반드시 지켜야 할 규칙이라면 설계 원칙은 가이드라인이다 (성능 향상을 위해서 서비스 간 통신은 비동기 메시징을 활용)
	- 아키텍처 결정만으로 모든 조건과 구현 방안을 다룰 수 없기 때문에 설계 원칙이 존재한다
	- 아키텍처 결정만큼의 강제성을 지니지는 않는다. 즉, "반드시" 지켜야하는 속성은 아니다.
- 시스템의 구조
	- 시스템이 구현된 아키텍처 스타일의 종류(마이크로서비스, 레이어드, 모놀리식, 마이크로커널)
# 1.2 아키텍트에 대한 기대치
## 1.2.1 아키텍처 결정을 내린다
- 아키텍트는 아키텍처와 설계 원칙을 결정하고 팀, 부서뿐만 아니라 회사 전체의 기술 결정을 가이드한다
	- 아키텍트는 기술 선택을 가이드하는 사람이지 결정하는 사람이 아니다
		- ReactJS를 사용하기로 결정하는 것은 가이드하는 것이 아니라 결정한 것이다. 더 올바른 접근법은 프런트엔드 프레임워크를 선택할 수 있는 기준(아키텍처 결정 및 설계 원칙)을 결정하고 팀에 가이드하여 팀원들이 프런트엔드 프레임워크를 결정할 수 있도록 하는 것이다.
	- 모든 경우에 기술 선택을 가이드하는 것은 바람직하지 않을 수 있다. 그러므로 각 상황에서 기술 선택을 가이드하는 것이 더 적합할지 아니면 직접 기술을 결정하는 것이 적합할지 고려해야 된다.
## 1.2.2 아키텍처를 지속적으로 분석한다
- 끊임없이 아키텍처와 현재 기술 환경을 분석하고 이를 개선하기 위한 해결 방안을 제시해야 된다
- 소프트웨어 아키텍처는 매우 빠르게 변화하는 동적인 환경이므로 예전의 아키텍처를 지속적으로 분석하고 개선하도록 노력해야 된다.
- 테스팅과 릴리스 환경을 망각하지 않아야 된다.
## 1.2.3 최신 트렌드를 계속 따라간다
- 아키텍트는 최신 기술과 업계 트렌드를 지속적으로 따라가야한다.
- 아키텍트가 결정한 것들은 대개 오래 지속되고, 바꾸기도 어렵다. 그러므로 결정하는 시점의 핵심 트렌드를 이해하고 있어야 그나마 미래를 대비한 올바른 결정을 내릴 수 있다.
## 1.2.4 아키텍처 결정의 컴플라이언스를 보장한다
- 팀이 아키텍처 결정과 설계 원칙의 컴플라이언스를 보장하고 있는지 지속적으로 확인해야 된다. (UI 개발자가 데이터베이스에 직접 액세스하는 프레젠테이션 레이어 코드를 작성하지 않았는지)
## 1.2.5 다양한 기술과 경험에 노출된다
- 아키텍트는 다양한 기술, 프레임워크, 플랫폼, 환경에 노출되어야 한다
- 요즘 환경은 대부분 복합적인 경우가 많아서 어떤 언어와 플랫폼, 기술로 개발되었든지 다양한 시스템과 서비스를 연동하는 방법을 알고 있어야 된다
- 아키텍트는 기술의 깊이보다는 폭에 초점을 두어야한다 (한 가지 캐시 제품에 전문가가 되는 것보다 10가지 캐시 제품을 어느정도 아는 것이 더 낫다)
## 1.2.6 비즈니스 도메인 지식을 보유한다
- 아키텍트는 어느정도 수준 이상의 비즈니스 도메인 전문가여야 한다
- 비즈니스의 문제점, 목표, 요구사항을 이해하고 있어야만 비즈니스 요구사항을 수용할 만한 효율적인 아키텍처를 설계할 수 있다.
- 내부 이해관계자들과 효율적인 의사소통을 위해서는 도메인 지식과 언어를 이해하고 있어야 한다.
## 1.2.7 대인 관계 기술이 뛰어나다
- 아키텍트는 팀워크, 조정, 리더십을 포함한 대인 관계 기술이 뛰어나야 한다
- 아키텍트는 개발팀을 기술적으로 이끌기만 하는 사람이 아니라, 개발팀을 리드해서 아키텍처를 구현하는 사람이므로 리더십 스킬은 매우 중요하다
## 1.2.8 정치를 이해하고 처세를 잘한다
- 아키텍트는 기업 내부의 정치적 분위기를 이해하고 적절하게 잘 처신할 줄 알아야 한다
- 아키텍트가 내린 거의 모든 결정은 사람들의 반발에 부딪히게 마련이다. 그러므로 대부분의 결정을 사람들이 수용하도록 기본적인 협상 기술을 발휘해야 한다.
# 1.3 아키텍처의 교차점 그리고...
- 소프트웨어 아키텍처는 지난 10년 동안 점점 더 많은 책임과 관점을 아우르는 방향으로 확대되었다.
- 10년 전만 해도 대부분의 회사는 자체 운영보다 서드파티 회사에 외주를 맡기는 경우가 많았다. 가동 시간, 확장성, 응답성, 그 밖의 중요한 아키텍처 특성을 SLA 형태로 외주를 맡겼다.
- 현재의 마이크로서비스 같은 아키텍처에서는 예전의 순전히 운영 관심사였던 부문(외주줬던 부분)을 자유롭게 넘나들 수 있게되었다. (예전에는 탄력적 확장 기능을 구현하기 까다로웠지만 현재는 아키텍트와 데브옵스 간에 소통을 하면서 마이크로서비스를 훨씬 수월하게 구현할 수 있다)
- `pets.com 사례 (40p)`
	- 아키텍처 특성 중 탄력적 확장을 전혀 고려하지 않아서 회사가 문닫음
## 1.3.1 엔지니어링 프랙티스
- 지난 몇 년 동안 엔지니어링 분야가 발전을 거듭했고 소프트웨어 아키텍처의 프로세스 문제를 고민하기 시작했다.
	- 엔지니어링 프랙티스
		- 프로세스와 무관하게 가시적이고 반복 가능한 혜택을 주는 실천론 (CI/CD)
	- 소프트웨어 개발 프로세스
		- 팀을 어떻게 구성하고 관리할지, 회의는 어떻게 하고 워크플로 조직은 어떻게 운영할지 등 사람을 조직하고 상호작용하는 총체적인 기법(애자일)
- 엔지니어링 프랙티스에 집중하는 것이 중요하다
	- 소프트웨어 개발 분야는 보다 성숙한 다른 엔지니어링 체계에 있는 많은 특성들이 빠져있다(중요한 구조를 변경할 경우 토목 엔지니어는 소프트웨어 엔지니어보다 훨씬 더 정확하게 결과를 예측할 수 있다)
	- 소프트웨어 개발에서 추정은 매우 어렵다. 'unknown unknowns' 때문에 더 어렵다.
		- known knowns: 이미 알고있는 것들
		- known unknowns: 모른다는 것을 알고있는 것들
		- unknown unknowns: 모른다는 사실 조차 모르는 것들
	- 이 'unknown unknowns' 때문에 반복적인 프로세스가 더 잘 맞는다. 폭포수 모델로 마이크로서비스 같은 현대적인 시스템을 구축하기란 까다로울 것 이다.
- 아키텍트는 프로젝트 기술 리더를 겸하는 경우도 많기에 팀의 엔지니어링 프랙티스를 결정한다.
	- 아키텍처 스타일과 엔지니어링 프랙티스가 공생 관계망을 형성하도록 해야한다 (마이크로 서비스 아키텍처 - 머신 프로비저닝, 자동화 테스트, 배포)
- 정적인 것은 하나도 없다. 아키텍트가 시스템을 설계할 수 있는 있지만 그 설계는 구현과 개발 생태계의 변화를 모두 거치면서 살아남아야 한다. 그러므로 진화하는 아키텍처가 필요하다.
	- 시간이 지나 변경이 일어나도 아키텍처 특성을 보호하기 위해 아키텍처 피트니스 함수라는 개념을 도입한다.
		- 어떤 아키텍처 특성의 개관적인 완전성을 평가하느 수단이다. 메트릭, 단위 테스트, 모니터링, 카오스 엔지니어링 등 다양한 메커니즘이 이 평가에 포함된다.
			- 예: 페이지 로드 시간이 중요한 아키텍처 특성이라고 할 때 각 페이지 로드 시간을 측정하는 피트니스 함수를 CI에 추가하는 것
## 1.3.2 운영/데브옵스
- ???
## 1.3.3 프로세스
- 역사적으로 소프트웨어 개발 프로세스는 소프트웨어 아키텍처에 별다른 영향을 끼치지 않는다고 알려졌다.하지만 소프트웨어를 개발하는 개발팀의 프로세스는 소프트웨어 아키텍처의 여러 파트에 영향을 미친다.
	- 지난 수십 년 간 소프트웨어의 본질 때문에 애자일 개발 방법론을 도입한 회사들이 많다. 애자일 프로세스는 아키텍트로 하여금 반복적인 개발을 통해 의사 결정에 필요한 피드백을 더 빨리 받아볼 수 있고, 피드백에 의존하는 실험과 다른 지식에 더욱 적극적으로 참여할 수 있다.
- 재구성은 애자일 방법론의 진면목을 볼 수 있는 아키텍처의 분야이다.
	- 팀은 종종 아키텍처를 어떤 패턴에서 다른 패턴으로 바꾸어야 할 필요성을 깨닫는다. (모놀리식 -> 마이크로서비스)
	- 애자일 방법론은 피드백 루프가 더 촘촘하므로 스트랭글러 패턴, 기능 토글 등의 기법을 조합한다면 이런 변경을 더 잘 지원한다.
## 1.3.4 데이터
- 대부분의 애플리케이션은 외부 데이터 스토리지가 큰 비중을 차지한다. 그러므로 DBA는 아키텍트와 협업하여 복잡한 시스템의 데이터 아키텍처를 구축한다.
- 그러므로 데이터 및 외부 데이터 스토리지 또한 아키텍처의 중요한 관심사이다.
# 1.4 소프트웨어 아키텍처 법칙
- 소프트웨어 아키텍처의 모든 것은 다 트레이드오프다
	- 아키텍트가 트레이드오프가 아닌 뭔가를 발견했다고 생각한다면, 아직 트레이드오프를 발견하지 못했다는 증거일 가능성이 크다. 즉 소프트웨어의 거의 모든 부분에는 트레이드오프가 존재한다.
- '어떻게'보다 '왜'가 더 중요하다.
	- 자신이 전혀 모르는 기존 시스템을 들여다보면서 아키텍처의 구조적인 작동원리를 알아 낼 수는 있지만 왜 그런 선택을 했는지는 설명하기 힘들다.
	- 트레이드오프를 감안하여서 왜 그런 결정을 하는지 이해하고 판단하는 것이 중요하다.
