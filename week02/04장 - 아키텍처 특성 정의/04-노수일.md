# 4. 아키텍처 특성 정의
- 어떤 문제를 소프트웨어로 해결하려면 아키텍트는
    - 시스템 요구사항을 취함
    - 이것을 구현하는 데 다양한 기술을 소프트웨어 개발 프로세스에 따라 정리
- 개발팀과 함께 도메인 기능과 직접적인 관련이 없는 모든 것들, 아키텍처 특성을 정의, 발견, 분석하는 일을 수행
- 아키텍트의 역할부터 문제 영역 및 독립적인 시스템의 중요한 부분까지 많은 점들이 다름, 이런 소프트웨어 특성을 비기능 요구사항이라고 표현
- 비기능 요구사항보다는 아키텍처 특성이라는 용어를 선호함
- 아키텍처 특성은 세 가지 기준을 충족
    - 비도메인 설계 고려 사항을 명시
    - 설계의 구조적 측면에 영향을 미침
    - 애플리케이션 성공에 (절대적으로)중요
#### 비도메인 설계 고려사항을 명시한다
- 애플리케이션 설계 시 애플리케이션으로 처리할 일은 구체적인 요구사항으로 정리
- 아키텍처 특성은 이 요구사항을 구현하는 방법
- 어떤 선택을 하게 된 이유와 관련된 운영/설계 기준을 명시
#### 설계의 구조적 측면에 영향을 미친다
- 아키텍트가 아키텍처 특성을 기술하는 주된 이유
    - 이 아키텍처 특성은 어떤 특별한 구조적 요소를 고려해야 하는가? 하는 설계 고려 사항
- ex : 보안은 사실상 모든 프로젝트의 주요 관심사
- 아키텍트가 무언가 특별한 것을 설계해야 한다면 보안은 아키텍처 특성 수준으로 격상됨
- 서드파티 결제 프로세서
    - 결제 처리를 한 곳에서 처리한다면 아키텍트가 특별히 구조에 신경 쓸 일은 없음
- 애플리케이션 내부 결제 처리
    - 애플리케이션이 직접 결제 처리를 한다면 중오한 보안 문제를 구조적으로 분리하기 위해 특정한 모듈이나 컴포넌트, 서비스를 설계해야 함
    - 이 경우, 아키텍처 특성은 아키텍처와 설계 모두에 영향을 미침
#### 애플리케이션 성공에 (절대적으로)중요하다
- 애플리케이션이 무수히 많은 아키텍처 특성을 전부 다 지원할 수 도 있지만, 그러면 안됨
- 지원하는 아키텍처 특성을 한 가지만 늘려도 설계 복잡도가 가중됨
- 가급적 아키텍처 특성을 적게 선정하는 일도 아키텍트의 중요한 책무
- 아키텍처 특성은 명시적, 암묵적 특성으로 분류
- 암묵적 아키텍처 특성
    - 요구사항 정의서에는 거의 안나오지만 프로젝트 성공을 위해 꼭 필요한 특성
    - 가용성, 신뢰성, 보안
    - 애플리케이션의 근간이지만 설계 문서에는 등장하지 않음
- 명시적 아키텍처 특성
    - 요구사항 정의서나 다른 지침서에 기재됨
- 시스템 전체 설계를 지원하는 모습은 삼각형
- 삼각형이 지탱하는 지점은 아키텍처 특성들이 끊임없이 상호작용함으로써 트레이드오프가 발생할 수 밖에 없음
## 4.1 아키텍처 특성 (일부) 목록
- 아키텍처 특성은 모듈성 같은 저수준 코드의 특성부터 확장성, 탄력성 같은 복잡한 운영문제까지 소프트웨어 시스템의 넓은 범위에 고루 존재
- 아키텍처 특성을 체계화 하려는 시도는 있었지만 보편적인 표준은 없고, 조직마다 자체적으로 해석, 정의
- 빠르게 변화하는 생태계 특성상 새로운 개념, 용어, 측정, 검증이 계속 출현, 계속 새로운 방식으로 아키텍처 특성 정의
### 4.1.1 운영 아키텍처 특성
- 성능, 확장성, 탄력성, 가용성, 신뢰성 등의 능력
- 가용성
    - 시스템이 얼마나 오랫동안 사용 가능해야 하나
- 연속성
    - 재해 복구 능력
- 성능
    - 스트레스 테스트, 피크 분석, 기능의 사용빈도 분석, 필요 용량, 응답 시간
- 복구성
    - 비즈니스 연속성 요구사항, 백업 전략과 하드웨어 다중화 요건에 영향을 미침
- 신뢰성/안전
    - 시스템에 페일 세이프 (fail-safe)가 필요한가? 시스템 실패 시 회사에 거액의 손실이 발생하는가?
- 견고성
    - 프로그램 샐행 중 인터넷 접속 끊김, 정전, 하드웨어 실패 등 에러 및 경계 조건을 감당하는 능력
- 확장성
    - 유저 수, 요청 수가 늘어나도 시스템이 그에 맞는 성능을 발휘하는 능력
### 4.1.2 구조 아키텍처 특성
- 아키텍트는 코드 구조에도 심혈을 기울여야 함
- 우수한 모듈성, 컴포넌트 간 커플링 제어, 가독성 높은 코드, 내부 품지 평가 등 코드 품질 문제를 전담 (혹은 공동으로 담당)
- 설정성
    - 최종 유저가 (쓰기 편한 인터페이스를 통해) 소프트웨어 설정을 쉽게 바꿀 수 있는가
- 신장성
    - 새로운 기능을 삽입하는 일의 중요성
- 설치성
    - 필요한 모든 플랫폼에 시스템을 얼마나 손쉽게 설치할 수 있나
- 활용성/재사용
    - 공통 컴포넌트를 여러 제품에서 활용할 수 있나
- 지역성
    - 데이터를 입력/조회하는 화면에서 다국어가 지원되는가?
    - 리포트 징표에서 멀티바이트 문자 및 측정, 화폐 단위 등의 요구사항
- 유지보수성
    - 시스템을 얼마나 쉽게 변경/개선할 수 있나
- 이식성
    - 하나 이상의 플랫폼에서 시스템을 실행할 수 있나?
- 지원성
    - 애플리케이션은 어느 정도의 기술 지원을 필요로 하나?
    - 시스템에서 발생한 에러를 디버깅하려면 로깅 및 기타 기능이 어느 수준으로 뒷바침되어야 하나
- 업그레이드성
    - 이 애플리케이션/솔루션의 구 버전을 새 버전으로 쉽고 빠르게 업그레이드할 수 있나?
### 4.1.3 아키텍처 공통 특성
- 쉽게 뷴류할 수 있는 범주에 속하는 아키텍처 특성들도 있지만, 중요한 설계 제약 조건과 고려 사항은 대부분 따로 분류하기가 어려운 경우가 많음
- 접근성
    - 색맹, 청각 장애인 등 모든 유저가 접근하는데 불편함이 없나
- 보관성
    - 데이터를 따로 아카이빙해야 하나, 아니면 일정 시간 경과 후 삭제해야 하나
- 인증
    - 유저가 본인이 맞다는 것을 증명하기 위해 필요한 보안 요구사항
- 인가
    - 유저가 애플리케이션에서 정해진 기능만 사용할 수 있도록 강제하는 보안 요구사항
- 합법성
    - 시스템 운영상 법적 제약조건이 있는가?
- 프라이버시
    - 회사 내부 임직원의 트랜잭션을 외부에 드러내지 않는 기능
- 보안
    - 데이터를 암호화한 후 데이터베이스에 보관해야 하나
    - 내부 시스템 간 네트워크 통신도 암호화해야 하나
    - 원격 유저 엑세스는 어떤 종류의 인증이 필요한가
- 사용성/성취성
    - 유저가 애플리케이션/솔루션을 이용하여 원하는 목적을 달성하기 위해 필요한 교육/훈련 수준
    - 사용성 요구사항 역시 다른 아키텍처 이슈 못지않게 진지하게 다루어야 함
- 지금까지의 용어는 의미가 미묘하거나, 객관적으로 정의하기 어렵다거나, 부정확하고 모호한 부분이 있음
    - 상호운용성, 호환성은 동등해보이고 시스템에 따라 정말 그런 경우도 있음
    - 상호운용성은 다른 시스템과의 통합 용이성을 내포
    - 호환성은 산업 표준, 도메인 표준과 더 연관되어 있음
- 이 세상에 완벽한 표준 목록은 없음
- ISO가 발표한 기능별 목록
    - 나열된 특성과 중복되거나 카테고리 목록이 불완전한 편
    - 이하 ISO 정의에서 발췌한 목록
- 성능 효율
    - 알려진 조건에서 리소스 양에 비례하는 성능 측정값, 시간특징(응답시간, 처리 시간, 처리율), 리소스 사용(사용한 리소스 사용), 능력(최대 설정된 한계치를 초과한 정도) 등이 포함
- 호환성
    - 제품, 시스템, 컴포넌트가 다른 제품, 시스템, 컴포넌트와 정보를 교환하고 동일한 하드웨어/소프트웨어 환경을 공유하면서 필요한 기능을 수행할 수 있는 정도
    - 공존
        - 환경과 리소스를 다른 제품과 공유하면서 효율적으로 필요한 기능을 수행할 수 있음
    - 상호운용
        - 둘 이상의 시스템에 정보를 교환, 활용 가능한 정도
- 사용성
    - 유저가 시스템을 원하는 목적에 맞게 효과적으로, 효율적으로, 만족스럽게 사용할 수 있는 정도
    - 적합성 인지도
        - 유저가 자신의 사용 목적에 소프트웨어가 부합하는지 인식할 수 있음
    - 학습성
        - 유저가 얼마나 쉽게 소프트웨어 사용법을 익히는가
    - 유저 에러 방지
        - 유저 실수 방지
    - 접근성
        - 사람들이 소프트웨어의 가장 다양한 능력과 기능을 접할 수 있게 함
- 신뢰성
    - 주어진 기간 동안 특정 조건에서 시스템이 가능하는 정도
    - 성숙도
        - 정상 작동 시 소프트웨어가 원하는 신뢰성을 보장하는가
    - 가용성
        - 소프트웨어가 가동중이고 엑세스 가능한가
    - 내고장성
        - 하드웨어/소프트웨어가 고장나도 소프트웨어가 의도한 대로 작동되나
    - 복구성
        - 소프트웨어가 고장나도 영향 받은 데이터를 되살리고 원하는 시스템 상태로 돌아갈 수 있는가
- 보안
    - 사람, 다른 제품, 시스템이 자신의 인증 레벨에 맞게 데이터를 엑세스할 수 있게귺ㅁ 소프트웨어가 정보를 보호하는 정도
    - 기밀성
        - 데이터는 인증된 사람만 엑세스 할 수 있음
    - 무결성
        - 데이터를 함부로 변조하지 못하게 소프트웨어가 허가되지 않은 엑세스를 차단함
    - 부인 방지
        - 어떤 액션이나 엑세스가 발생했음을 증명
    - 책임 소재
        - 유저가 수행한 액션을 추적
    - 진위
        - 유저 신원을 증명
- 유지보수성
    - 개발자가 얼마나 효율적으로 소프트웨어를 고쳐 개선/발전시키고 계속 변화하는 환경이나 요구사항에 맞게 적용할 수 있는가를 나타냄
    - 모듈성
        - 소프트웨어를 독립된 컴포넌트로 구성할 수 있는 정도
    - 재사용성
        - 개발자가 어떤 자산을 여러 시스템에서, 다른 자산을 구축하는 데 다시 사용할 수 있는 정도
    - 분석성
        - 개발자가 얼마나 쉽게 소프트웨어 메트릭을 취합할 수 있나
    - 수정성
        - 개발자가 기존 제품 품질을 떨어뜨리지 않고도 어렵지 않게 소프트웨어를 수정할 수 있나
    - 시험성
        - 개발자나 다른 사람들이 얼마나 쉽게 소프트웨어를 테스트할 수 있나
- 이식성
    - 개발자가 하드웨어, 소프트웨어 또는 다른 운용 환경에 있는 시스템, 제품, 컴포넌트를 다른 곳에 옮길 수 있는 정도
    - 적응성
        - 개발자가 소프트웨어를 다른 하드웨어, 소프트웨어, 기타 운용 환경에 맞게 적용시킬 수 있나
    - 설치성
        - 소프트웨어를 주어진 환경에 설치/삭제할 수 있나
    - 교체성
        - 개발자가 얼마나 쉽게 다른 소프트웨어로 기능을 교체할 수 있는가
- 기능적합성
    - 주어진 조건에서 시스템을 가동할 때 명시/암묵적인 요구사항을 충족하는 정도
    - 기능 완전성
        - 제공되는 기능들이 전체 작업과 유저 목표를 얼마나 커버하는가
    - 기능 정확성
        - 제품이나 시스템이 올바른 결과를 어느 정도로 정확하게 제공하는가
    - 기능 타당성
        - 주어진 목표를 얼마나 쉽게 달성할 수 있는가
## 4.2 트레이드오프 및 나쁜 것 중에서 제일 나은 아키텍처
- 지금까지의 아키텍처 특성들은 여러 가지 이유로 일부만 애플리케이션에서 지원 가능
- 지원되는 특성마다 설계 노력이 필요하고 구조적으로도 지원돼야 함
- 각 아키텍처 특성이 다른 특성에 영향을 미치는 경우가 많음, 더 큰 문제
    - ex : 보안을 강화하려고 하면 성능에 부정적인 영향을 미침
- 아키텍처 특성을 선택할 때 트레이드 오프가 발생
- 아키텍처 특성 하나하나가 전체 설계를 복잡하게 만들 가능성을 품고 있음
- 아키텍처 특성을 너무 욕심내면 모든 비즈니스 문제를 해결하려고 시도하는 일반적인 솔루션이 되어버림
    - 설계하기 대단히 까다로워 실현 가능성이 낮음
- 아키텍트는 가능한 한 아키텍처 설계를 꾸준히 조금씩 반복해보는 게 좋음
