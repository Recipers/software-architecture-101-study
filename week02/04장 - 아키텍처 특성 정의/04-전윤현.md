- 아키텍트는 개발팀과 함께 도메인 또는 비즈니스 요구사항을 정의할 수 있지만, 주로 소프트웨어로 처리할 일 중 도메인 기능과 직접적인 관련이 없는 모든 것들, 즉 아키텍처 특성(비기능 요구사항)을 정의, 발견, 분석하는 일을 수행한다
- 아키텍처 특성은 다음 세 가지 기준을 충족한다
	- 비도메인 설계 고려 사항을 명시한다
		- 애플리케이션 설계 시 애플리케이션으로 처리할 일은 구체적인 요구사항으로 정리된다. 아키텍처 특성은 이 요구사항을 구현하는 방법, 어떤 선택을 하게 된 이유와 관련된 운영/설계 기준을 명시한다. 예를 들어, 일반적으로 어느정도의 애플리케이션 성능은 중요한 아키텍처이지만 요구사항 정의서에 명시되어 있지 않는 경우가 많다.
	- 설계의 구조적 측면에 영향을 미친다
		- 아키텍러 특성을 기술하는 주된 이유는 '이 아키텍처 특성은 어떤 특별한 구조적 요소를 고려해야 하는가?'하는 설계 고려 사항 때문이다. 예를 들어 보안은 모든 프로젝트의 주요 관심사이므로 어느정도 기본 보안 지침은 준수해야 하지만 아키텍트가 뭔가 특별한 것을 설계해야 된다면 보안은 아키텍처 특성 수준으로 격상된다
	- 애플리케이션 성공에 절대적으로 중요하다
		- 애플리케이션이 지원하는 아키텍처 특성이 늘어날 수록 설계 복잡도는 가중된다. 그러므로 가급적 아키텍처 특성을 적게 선정하는 것도 중요하다.
	- 암묵적 특성
		- 요구사항 정의서에는 거의 나오지는 않지만 프로젝트 성공을 위해 꼭 필요한 특성들이다. 예를 들면 가용성, 신뢰성, 보안등이 있다. 아키텍트는 분석 단계에서 자신의 도메인 지식을 최대한 활용하여 아키텍처 특성을 밝혀내야 한다. 예를 들어 거래가 잦은 무역 회사에서 모든 시스템의 요구사항 정의서에 낮은 레이턴시를 명시할 필요는 없지만 아키텍트는 낮은 레이턴시가 얼마나 중요한지 간파해야 된다.
	- 명시적 특성
		- 요구사항 정의서나 다른 지침서에 명시적으로 기재되는 아키텍처 특성이다
# 4.1 아키텍처 특성 (일부) 목록
### 4.1.1 운영 아키텍처 특성
- 성능, 확장성, 탄력성, 가용성, 신뢰성 등의 특성이다. 운영 아키텍처 특성은 운영 및 데브옵스와 많은 부분에서 중첩된다.
	- 가용성: 시스템이 얼마나 오랫동안 사용 가능해야 하나
	- 연속성: 재해 복구 능력
	- 성능: 스트레스 테스트, 피크 분석, 기능의 사용 빈도 분석, 필요 용량, 응답 시간
	- 복구성: 비즈니스 연속성 요구사항(장애 발생 시 얼마나 신속하게 시스템을 재가동 시켜야하나), 백업 전략과 하드웨어 다중화 요건에 영향을 끼침
	- 신뢰성/안전: 시스템에 페일 세이프가 필요한가?
	- 견고성: 프로그램 실행 중 인터넷 접속 끊김, 정전, 하드웨어 실패 등 에러 및 경계 조건을 감당하는 능력
	- 확장성: 유저 수, 요청 수가 늘어나도 시스템이 그에 맞는 성능을 발휘하는 능력
### 4.1.2 구조 아키텍처 특성
- 아키텍트는 코드 구조에도 심혈을 기울여야 하며 일반적으로 우수한 모듈성, 컴포넌트 간 커플링 제어, 가동성 높은 코드, 그 밖의 내부 품질 평가 등 코드 품질 문제를 전담해야 된다
	- 설정성: 최종 유저가 (쓰기 편한 인터페이스를 통해) 소프트우에 설정을 쉽게 바꿀 수 있는가?
	- 신장성: 새로운 기능을 삽입하는 일의 중요성
	- 설치성: 필요한 모든 플랫폼에 시스템을 얼마나 쉽게 설치할 수 있나?
	- 활용성/재사용: 공통 컴포넌트를 여러 제품에서 활용할 수 있나?
	- 지역성: 데이터를 입력/조회하는 화면에서 다국어가 지원되는가?
	- 유지보수성: 시스템을 얼마나 쉽게 변경/개선할 수 있나?
	- 이식성: 하나 이상의 플랫폼에서 시스템을 실행할 수 있나? (가령, 동일한 프런트엔드를 SAP DB와 오라클 DB 모두에서 실행 가능한가)
	- 지원성: 애플리케이션은 어느 정도의 기술 지원을 필요로 하나? 시스템에서 발생한 에러를 디버깅하려면 로깅 및 기타 기능이 어느 수준으로 뒷받침되어야 하나?
	- 업그레이드 성: 이 애플리케이션/솔루션이 구 버전을 새 버전으로 쉽고 빠르게 업그레이드할 수 있는가?
### 4.1.3 아키텍처 공통 특성
- 접근성: 색맹, 청각 장애인 등 모든 유저가 접근하는데 불편함이 없나?
- 보관성: 데이터를 따로 아카이빙해야 하나? 아니면 일정 시간 경과 후 삭제해야 하나?
- 인증: 유저가 본인이 맞다는 것을 증명하기 위해 필요한 보안 요구사항
- 인가: 유즈케이스, 서브시스템, 웹페이지, 비즈니스 규칙, 필드 레벨 등 유저가 애플리케이션에서 정해진 기능만 사용할수 있도록 강제하는 보안 요구사항
- 합법성: 시스템 운영상 법적 제약 조건이 있는가?
- 프라이버시: 회사 내부 임직언의 트랜잭션을 외부에 드러내지 않는 기능 (암호화 트랜잭션은 DBA나 네트워크 아키텍트도 해독 불가)
- 보안: 데이터를 암호화한 후 데이터베이스에 보관해야 하나?
- 사용성/성취성: 유저가 애플리케이션/솔루션을 이용하여 원하는 목적을 달성하기 위해 필요한 교육/훈련 수준

**ISO 기능별 목록**
- 성능 효율
	- 알려진 조건에서 리소스 양에 비례하는 성능 측정값
- 호환성
	- 제품, 시스템, 컴포넌트가 다른 제품, 시스템, 컴포넌트와 정보를 교환하고(하거나) 동일한 하드웨어/소프트웨어 환경을 공유하면서 필요한 기능을 수행할 수 있는 정도
- 사용성
	- 유저가 시스템을 원하는 목적에 맞게 효과적으로, 효율적으로, 만족스럽게 사용할 수 있는 정도
- 신뢰성
	- 주어진 기간동안 특정 조건에서 시스템이 기능하는 정도
- 보안
	- 사람들, 다른 제품, 시스템이 자신의 인증 레벨에 맞게 데이터를 액세스할 수 있게끔 소프트웨어가 정보를 보호하는 정도
- 유지보수성
	- 개발자가 얼마나 효율적으로 소프트웨어를 고쳐 개선/발전시키고 계속 변화하는 환경이나 요구사항에 맞게 적용할 수 있는가를 나타냄
- 이식성
	- 개발자가 하드웨어, 소프트웨어, 또는 다른 운용 환경에 있는 시스템, 제품, 컴포넌트를 다른 곳에 옮길 수 있는 정도
- 기능 적합성
	- 주어진 조건에서 제품이나 시스템을 가동할 때 명시/암묵적인 요구사항을 충족하는 정도
		- 기능 완전성: 제공되는 기능들이 전체 작업과 유저 목표를 얼마나 커버하는가?
		- 기능 정확성: 제품이나 시스템이 올바른 결과를 어느정도로 정확하게 제공하는가?
		- 기능 타당성: 주어진 작업과 목표를 얼마나 쉽게 달성할 수 있는가?
# 4.2 트레이드오프 및 나쁜 것 중에서 제일 나은 아키텍처
- 지금까지 열거한 아키텍처 특성들은 여러가지 이유로 일부만 지원이 가능하다.
	- 지원되는 특성마다 설계 노력이 필요하며 구조적으로도 지원되어야 한다
	- 아키텍처 특성이 다른 특성에 영향을 미치는 경우가 많다. 예를 들어 보안을 강화하려고 하면 십중팔구 성능에 부정적인 영향을 미치기 쉽다.
- 아키텍트가 설계하기로 결정한 아키텍처 특성 하나하나가 전체 설계를 복잡하게 만들 가능성을 품고 있다. 따라서 시스템을 설계하며 모든 아키텍처 특성을 빠짐없이 최상으로 반영하기란 불가능에 가깝다.
- 최고의 아키텍처를 고집하지 말고, 나쁜 것 중에서 제일 나은 아키텍처를 선택해야 된다.
- 아키텍트는 가능한한 아키텍처 설계를 꾸준히 조금씩 반복하는게 좋다. 아키텍처를 쉽게 변경할 수 있다면 첫술에 배불러야 한다는 강박관념도 사라진다.
