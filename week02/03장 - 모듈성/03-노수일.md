# 3. 모듈성
- 소프트웨어 아키텍처 용어의 95%는 '모듈성'의 이로움을 찬양하는데 사용되고 있지만, 정작 모듈성을 어떻게 달성할지에 대해서는 별 다른 얘기가 없다 - 글렌포트 J.마이어스
- 모듈성은 제대로 정의하기 쉽지 않은 개념
    - 정의가 난무하고 일관성이 없음
    - 심지어 모순된 정의도 있음
- 본인이 선택한 개발 플랫폼에서 모듈성과 그것을 구현한 수많은 코드를 이해하는 것은 아키텍트에게 대단히 중요
- 아키텍처를 분석해야 할 (메트릭, 피트니스 함수, 시각화 등) 많은 도구가 모듈성에 기반
- 모듈성은 일종의 구성 원리
- 모듈성을 잘 유지하는 건 암묵적 아키텍처 특성이라고 정의한 것의 좋은 예
- 모듈이 확실히 구분되고 모듈 간 통신이 잘 되어야 한다고 공식적으로 아키텍트에게 요구하는 프로젝트는 드물지만, 코드베이스를 잘 발전시켜 나가려면 암묵적으로 질서와 일관성이 필요
## 3.1 정의
- 사전적 정의
    - '복잡한 구조를 만드는 데 쓰이는 각각의 표준화한 부품이나 독립적인 단위'
- 모듈성을 이용해 객체지향 언어의 클래스, 함수형 언어의 함수가 될 만한 연관된 코드를 논리적으로 묶음
- 프로그래밍 언어는 대부분 모듈성 매커니즘을 제공
- 아키텍트는 개발자가 코드를 어떻게 패키징하는지 반드시 알아야 함
- 여러 패키지가 서로 단단히 커플링되어 있으면 그 중 하나를 다른 작업에 재사용하기가 아주 어려워짐
- 클래스, 함수처럼 묶어놓은 덩어리는 논리적인 구분에 의한 모듈성, 물리적인 분리와 다른 개념으로 바라봐야 함
- 대부분의 언어에는 변수, 함수, 메서드 등을 구성하는데 필요한 네임스페이스 역할을 하는 모듈성 매커니즘이 있음.
    - 모듈 구조가 물리적으로 반영되기도 함
    - 자바 패키지 구조는 실제 클래스 파일의 물리적인 디렉터리 구조를 그대로 나타냄
## 3.2 모듈성 측정
- 모듈성을 이해하는데 도움이 될만한 세 가지 핵심 개념
    - 응집
    - 커플링
    - 커네이선스
### 3.2.1 응집
- 한 모듈의 파트가 동일한 모듈 안에 얼마나 포함되어 있는 지, 모듈을 구성하는 파트가 서로 얼마나 연관되어 있는가
- 이상적으로 응집된 모듈이라면 모든 파트가 함께 패키징
- 응집된 모듈을 나누려고 해봐야 더 커플링되고 가독성은 떨어진다 -래리 콘스탄틴
- 응집도의 측정 범위 (좋은 것 -> 나쁜 것)
    - 기능적 응집
        - 모듈의 가가 파트는 다른 파트와 연관되어 있고 기능상 꼭 필요한 모든 것이 모듈에 들어있음
    - 순차적 응집
        - 두 모듈이, 한쪽이 데이터를 출려갛면 다른 한쪽이 그것을 입력 받는 형태로 상호작용
    - 소통적 응집
        - 두 모듈이, 각자 정보에 따라 작동하고 어떤 출력을 내는 형태로 통신 체인을 형성함
    - 절차적 응집
        - 두 모듈은 정해진 순서대로 실행되어야 함
    - 일시적 응집
        - 모듈은 시점 의존성에 따라 연관됨
        - 많은 시스템들이 시동할 때 그다지 관련 없어 보이는 것들을 초기화 하는 경우
    - 논리적 응집
        - 모듈의 내부 데이터는 기능적이 아니라, 논리적으로 연관되어 있음
    - 동시적 응집
        - 같은 소스 파일에 모듈 구성 요소가 들어있지만 그 외에는 아무 연관성도 없음
        - 가장 좋지 않은 형태의 응집
- 응집은 커플링보다는 덜 정확한 메트릭이므로 아키텍트 재량에 따라 측정된 모듈의 응집도는 다름
- 응집의 주관성을 전제로, 응집도를 가늠할 수 있는 메트릭을 개발함 (카이댐버와 케메러의 객체 지향 메트릭 스위트)
    - 메서드의 응집 결여도(LCOM)는 모듈의 구조적 응집도를 나타냄
        - 공유 필드를 통해 공유되지 않는 메서드의 총 개수
        - LCOM 메트릭은 아키텍처 스타일을 전환하기 위해 코드베이스를 분석하는 아키텍트에게 메우 유용
        - 어쩔 수 없이 커플링된 클래스, 처음부터 한 클래스가 아니었던 클래스를 발견하는 데 도움이 됨
    - 소프트웨어 메트릭은 거의 대부분 한두가지 중요한 결함이 있음
        - LCOM의 모든 메트릭이 찾아내는 것은 '구조적'응집 결여도일 뿐, 논리적으로 판단 불가
### 3.2.2 커플링
- 코드베이스의 커플링은 그래프 이론에 기반한 좋은 분석도구들이 많이 있음
- 메서드의 호출과 반환은 호출 그래프를 형성하므로 수학적인 분석이 가능함
- 에드워드 요던과 래리 콘스탄딘이 지은 Structured Design에 구심커플링, 원심커필링 등 중요 개념 대거 등장
- 구심 커플링 : 코드 아티팩트(컴포넌트, 클래스 함수 등)로 유입되는 접속 수
- 원심 커플링 : 다른 코드 아티팩트로 유출되는 접속 수
- 어느 플랫폼이든 아키텍트가 코드베이스를 재구성, 마이그레이션, 분석할 때 도움을 주는 커플링 특성 분석 도구는 거의 다 있음
### 3.2.3 추상도, 불안정도, 메인 시퀀스로부터의 거리
- 컴포넌트 커플링이 아키텍트에게 유의미한, 있는 그대로의 가치가 있다면, 여기서 파생된 다른 메트릭들도 잘 살표볼 필요가 있음
- 이런 메트릭들은 로버트 마틴이 자신이 저술한 C++책에서 처음 사용했지만, 다른 객체지향 언어에도 널리 적용할 수 있음
- 추상도는 추상 아티팩트(추상 클래스, 인터페이스 등의)와 구상 아티팩트(구현체)의 비율, 구현 대비 추상화 정도를 나타냄
- 추상도를 구하는 공식
    - Σm^a / Σm^c
    - m^a : 모듈에 있는 추상 요소
    - m^c : 구상 요소
- 불안정도는 원심 커플링과 (구심 커플링 + 원심 커플링)의 비율
    - c^e / (c^e + c^a)
    - c^e : 원심 커플링
    - c^a : 구심 커플링
### 3.2.4 메인 시퀀스로부터의 거리
- 메인 시퀀스로부터의 거리는 불안정도와 추상도를 이용하여 계산
    - |A + I - 1|
    - A : 추상도
    - I : 불안정도
- 추상도, 불안정도는 비율이므로 항상 0과 1 사이의 값
- 메인 시퀀스로부터의 거리는 추상도와 불안정도 사이의 이상적인 관계를 나타냄
- 이상적인 선에 가까운 클래스는 서로 경쟁적인 두 메트릭의 건전한 조합
- 오른쪽 위로 치우친 부분은 쓸모없는 구역
    - 너무 추상화를 많이 해서 사용하기 어려운 코드
- 왼쪽 아래로 치우친 부분은 고통스런 구역
    - 추상화를 거의 안하고 구현 코드만 잔뜩 넣어서 취약하고 관리하기 힘든 코드
- 생소함, 마이그레이션, 기술 부채 평가 등의 사유로 아키텍트가 코드베이스를 분석할 때 도움이 됨
- 애드워드 요던과 래리 콘스탄틴이 쓴 Structured Design은 객체 지향 언어가 인기를 얻기 전에 출간
    - 함수 같은 구조적 프로그래밍 요소에만 집중
    - 다른 종류의 커플링에 대해 기술함 (커네이선스)
### 3.2.5 커네이선스
- 밀러 페이지-존스 What Every Programmer Should Know About Object-Oriented Design
    - 구심/원심 커플링 메트릭을 더욱 발전시킨 커네이선스 개념을 객체 지향언어의 화두로 던짐
    - 두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면 이들은 커네이선스를 갖고 있는 것이다
    - 정적 커네이선스, 동적 커네이선스로 구분
#### 정적 커네이선스
- 소스 코드 레벨의 커플링
- 구심/원심 커플링을 발전시킨 개념
- 명칭 커네이선스 (CoN)
    - 여러 컴포넌트의 엔티티명이 일치해야 함
    - 메서드명은 코드베이스가 커플링되는 가장 일반적이면서 바람직한 방법
- 타입 커네이선스 (CoT)
    - 여러 컴포넌트의 엔티티 타입이 일치해야 함
    - 대부분의 정적 타입 언어에서 변수와 매개변수를 특정 타입으로 제한하는 일반적인 기능
    - 클로저, 클로저 스펙 등 선택정 타이핑 기능을 제공하는 동적 타입 언어도 있음
- 의미 커네이선스 (CoM) 또는 관례 커네이선스 (CoC)
    - 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 함
    - 상수 대신 숫자를 하드코딩한 코드베이스에서 흔히 발견됨
- 위치 커네이선스 (CoP)
    - 여러 컴포넌트의 값의 순서가 일치해야 함
    - 정적 타이핑이 가능한 언어에서도 메서드와 함수 호출 시 전달하는 매개변수 값은 순서가 맞아야 함
- 알고리즘 커네이선스 (CoA)
    - 여러 컴포넌트는 특정 알고리즘이 일치해야 함
#### 동적 커네이선스
- 런타임 호출을 분석하는, 또 다른 유형의 커네이선스
- 실행 커네이선스 (CoE)
    - 여러 컴포넌트의 실행 순서가 중요
- 시점 커네이선스 (CoT)
    - 여러 컴포넌트의 실행 시점이 중요
    - 시점 커네이선스의 가장 일반적인 사례는, 동시에 실행 중인 두 스레드 때문에 경합 조건이 발생하여 공동 작업의 결과에 영향을 끼치는 것
- 값 커네이선스 (CoV)
    - 상호 연관된 다수의 값들을 함께 변경할 때 발생
    - 트랜잭션, 데이터베이스가 각각 분리된 시스템을 설계했는데 모든 데이터베이스에서 하나의 값을 업데이트해야 할 경우, 전체 값들을 한 번에 바꾸든지, 아무 값도 바꾸지 말든지 해야함
- 식별 커네이선스 (CoI)
    - 여러 컴포넌트가 동일한 엔티티를 참조할 때 발생
    - 독립적인 두 컴포넌트가 분산 큐 같은 자료 구조를 공유해서 업데이트 하는 경우
- 런타임 호출은 호출 그래프에 비해 효과적인 분석 도구가 많지 않아 아키텍트는 동적 커네이선스를 파악하기가 쉽지 않음
#### 커네이선스 속성
- 커네이선스는 아키텍트와 개발자에게 유용한 분석 도구, 다음 프로퍼티를 잘 활용하면 개발자에게 큰 도움이 됨
- 강도
    - 개발자가 어떤 유형의 커네이선스를 얼마나 쉽게 리팩터링할 수 있는제이 따라 커네이선스 강도를 결정
    - 아키텍트와 개발자는 더 나은 유형의 커네이선스를 리팩터링해서 코드베이스의 커플링 특성을 개선할 수 있음
- 지역성
    - 코드베이스의 모듈들이 서로 얼마나 가까이 있는가
    - 근접한 코드는 보통 더 분리된 코드보다 높은 형태의 커네이선스를 가짐
    - 모듈을 서로 떨어뜨렸을 때 커플링이 형편없는 형태의 커페이선스는 모듈을 서로 가까이 붙여 놓는 식으로 개선할 수 있음
    - 강도와 지역성을 함께 고민해야 함
    - 동일한 모듈에서 더 강한 형태의 커네이선스가 발견된다면 그와 동일한 커네이선스가 널리 흩어져 있는 것보다는 코드 스멜이 덜함
- 정도
    - 커네이선스가 미치는 영향의 규모
        - 소수의 클래스에 영향을 미치는가
        - 아니면 수많은 클래스에 영향을 미치는가
    - 값이 작을수록 코드베이스 입장에서는 바람직함
- 커네이선스를 이용해 시스템의 모듈성을 개선하는 세 가지 방법
    - 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이선스를 최소화한다
    - 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화한다
    - 캡슐화 경계 내부에서 커네이선스를 최대화한다
- 짐 웨이리치, 커네이선스 개념을 다시 대중화하며 두 가지 조언
    - 정도의 규칙
        - 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환하라
    - 지역성의 규칙
        - 소프트웨어 엘리먼트 간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 사용하라
### 3.2.6 커플링과 커네이선스 메트릭을 통합
- 아키텍트 관점에서는 커플링과 커네이선스에 대한 뷰가 서로 중첩됨
- 페이지-존스가 정적 커네이선스라고 밝힌 것들은 유출/유입 커플링 정도를 나타냄
- 구조적 프로그래밍은 들어오고 나가는 것에만 관심이 있음
- 커네이선스는 여러 가지 요소가 서로 어떻게 커플링되는지에 주목
#### 1990년대 커네이선스의 문제점
- 아키텍트가 이런 메트릭을 적용해 시스템을 분석/설계할 때에는 몇 가지 문제점이 있음
- 이 메트릭은 아키텍처 구조보다는 저수준 코드의 세부분을, 코드 품질 및 정리 상태 위주로 관찰
    - 아키텍트 입장에서는 커플링 정도보다 모듈이 어떻게 커플링 되어 있는지가 더 궁금하기 마련
- 커네이선스 자체는 요즘 아키텍트가 내려야 할 근본적인 결정에 관한 문제는 다루지 않음
## 3.3 모듈에서 컴포넌트로
- 모듈 : 연관된 코드의 묶음
- 대부분의 플랫폼은 '컴포넌트' 형태로 지원
