- 모듈성은 정의하기 까다로운 개념이다. 하지만 아키텍트에게는 모듈성은 매우 중요하다. 아키텍처를 분석해야 할 (메트릭, 피트니스 함수, 시각화 등) 많은 도구가 모듈성에 기반하기 때문이다. 또한 일종의 구성 원리이므로 대충 아무렇게나 조각들을 이어 붙여 시스템을 설계하면 무수한 난관에 봉착할 것이다.
- 모듈성은 암묵적 아키텍처 특성의 좋은 예이다. 공식적으로 아키텍트에게 모듈성을 요구하는 일은 드물지만 코드베이스를 잘 발전시켜 나가려면 모듈성이 고려되어야 한다.
# 3.1 정의
- 사전적으로 모듈은 "복잡한 구조를 만드는 데 쓰이는 각각의 표준화한 부품이나 독립적인 단위"이다. 엔지니어는 모듈성을 이용해 객체 지향 언어의 클래스나 함수형 언어의 함수가 될 만한 서로 연관된 코드를 논리적으로 묶는다.
- 아키텍트는 개발자가 코드를 어떻게 패키징하는지 반드시 알아야한다. 여러 패키지가 서로 단단히 커플링되어 있으면 재사용하기 까다로워진다.
- 종종 아키텍처를 논할 때 클래스, 함수처럼 코드를 묶어 놓은 덩어리를 모듈성이라는 일반 용어로 나타낸다. 하지만 여기서 논의하는 '모듈성'이란 논리적인 구분이지 물리적인 구분이 아니다. 모놀리식 애플리케이션은 편의상 많은 클래스를 한덩이로 묶지만 아키텍처를 재구축할 때에는 이런 구조가 모놀리스를 분해하는데 걸림돌이 된다. 그러므로 모듈성은 특정 플랫폼에서 함축되어 있거나 불가피한 물리적인 분리와는 다른 개념으로 바라봐야 된다.
# 3.2 모듈성 측정
### 3.2.1 응집
- 응집은 한 모듈의 파트가 동일한 모듈 안에 얼마나 포함되어 있는지를 나타낸다. 모듈을 구성하는 파트가 서로 얼마나 연관되어 있는가를 나타낸다.
- 응집도의 측정 범위 (좋은순)
	- 기능적 응집
		- 모듈의 각 파트는 다른 파트와 연관되어 있고 기능상 꼭 필요한 모든 것이 모듈에 들어있다
	- 순차적 응집
		- 두 모듈이, 한쪽이 데이터를 출력하면 다른 한쪽이 그것을 입력 받는 형태로 상호작용한다
	- 소통적 응집
		- 두 모듈이, 각자 정보에 따라 작동하고(거나) 어떤 출력을 내는 형태로 통신 체인을 형성한다. 예를 들면, 데이터베이스에 레코드를 추가하면 그 정보에 따라 이메일이 만들어지는 것
	- 절차적 응집
		- 두 모듈은 정해진 순서대로 실행되어야 한다
	- 일시적 응집
		- 모듈은 시점 의존성에따라 연관된다. 예를 들어, 많은 시스템들이 시동할 때 그다지 관련이 없어 보이는 것들을 한 꺼번에 초기화 하는 경우가 많은데 이런 작업들이 일시적 응집이다
	- 논리적 응집
		- 모듈 내부 데이터는 기능적이 아니라 논리적으로 연관되어 있다. 예를 들면 텍스트, 직렬화 객체, 스트림 형태로 받은 데이터를 변환하는 모듈이 있다. 서로 연관된 작업들이지만 하는 일은 전혀 다르다. Java의 StringUtils 패키지또한 대표적인 예이다. 각기 다른 작업을 수행하는 정적 메서드가 많지만 서로 연관성은 거의 없다.
	- 동시적 응집
		- 같은 소스 파일에 모듈 구성 요소가 들어있지만 그 외에는 아무 연관성도 없다
- 응집은 커플링보다 주관적인 메트릭이므로 아키텍트 재량에 따라 측정된 모듈의 응집도는 다르다. 즉 경우에 따라 다르고, 분석하는 아키텍트에 따라 달라질 수 있다.
- LCOM(메서드의 응집 결여도)
	- LCOM(Lack of Cohesion of Methods) 메트릭은 클래스 내 메서드들의 응집도를 측정하는 지표이다.
	- 개요
		- 정의: 클래스 내 메서드들이 얼마나 밀접하게 관련되어 있는지를 측정
		- 목적: 클래스의 응집도(cohesion)를 수치화하여 설계 품질 평가
		- 값의 의미: 높은 LCOM 값은 낮은 응집도를 의미하며, 클래스가 여러 책임을 가질 가능성을 시사
	- 계산 방식
		- LCOM1: 공유 필드가 없는 메서드 쌍의 수
		- LCOM2: (공유 필드가 없는 메서드 쌍) - (공유 필드가 있는 메서드 쌍)
		- 그 외에도 여러 버전이 존재함
	- 한계점
		- 클래스 크기와 복잡성에 따라 해석이 달라질 수 있음
		- 메서드와 필드의 이름만으로는 의미적 관계를 완전히 파악하기 어려움
### 3.2.2 커플링
- 커플링(Coupling)은 소프트웨어 모듈이나 클래스 간의 상호 의존성 정도를 나타내는 개념으로, 낮을수록 모듈이 독립적이고 재사용 가능하며 유지보수가 용이해진다
### 3.2.3 추상도, 불안정도, 메인시퀀스로부터의 거리
- 추상도
	- 추상 아티팩트(추상 클래스, 인터페이스 등)와 구상 아티팩트(구현체)의 비율이다. 가령, 추상화를 전혀하지 않는 애플리케이션(메인 함수에 모든 코드가 배치된)와 너무 지나치게 추상화해서 코드가 서로 어떻게 연결되어 있는지 파악하기 힘든 (AbstractSingletonProxyFactoryBean)을 생각할 수 있다.
	- 계산하는 방법: `추상 요소 / 구상 요소`로 수치화할 수 있다.
- 불안정도
	- 계산하는 방법:`원심(나가는) 커플링 / 원심(나가는) 커플링 + 구심(들어오는) 커플링`
	- 불안정도는 코드베이스의 변동성을 의미하므로 불안정도가 높은 코드베이스는 변경 시 커플링이 더 높아 깨지기 쉽다.
### 3.2.4 메인 시퀀스로부터의 거리
- 메인 시퀀스로부터의 거리는 아키텍처 구조를 평가하는 몇 가지 전체적인 메트릭 중 하나이다. 불안정도와 추상도를 이용하여 계산한다
- 계산하는 방법: `|추상도 + 불안정도 - 1|`
- 메인 시퀀스로부터의 거리는 추상도와 불안정도 사이의 이상적인 관계를 나타낸다. 이상적인 선에 가까운 클래스는 서로 경쟁적인 두 메트릭의 건전한 조합이라고 볼 수 있다.
### 3.2.5 커네이선스
- `두 컴포넌트 중 한쪽이 변경될 경우 다른 쪽도 변경해야 전체 시스템의 정합성이 맞는다면 이들은 커네이선스를 갖고 있는 것이다.`
- 정적 커네이선스
	- 명칭 커네이선스
		- `여러 컴포넌트의 엔티티명이 일치해야 된다.` 메서드명은 코드베이스가 커플링되는 가장 일반적이면서 바람직한 방법이다.
	- 타입 커네이선스
		- `여러 컴포넌트의 엔티티 타입이 일치해야 된다` 대부분의 정적 타입 언어에서 변수와 매개변수를 특정 타입으로 제한하는 일반적인 기능이다
	- 의미 커네이선스 또는 관례 커네이선스
		- `여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 된다` 상수 대신 숫자를 하드코딩한 코드베이스에서 흔히 발견된다(int TRUE = 1; FALSE = 0과 같은 선언)
	- 위치 커네이선스
		- `여러 컴포넌트는 값의 순서가 일치해야 된다` 메서드와 함수 호출 시 전달하는 배개변수 값은 순서가 맞아야 하므로
	- 알고리즘 커네이선스
		- `여러 컴포넌트는 특정 알고리즘이 일치해야 된다` 흔한 예로, 서버/클라이언트에서 둘 다 구현되어하는 유저 인증시의 보안 해시 알고리즘이 있다. 이 커네이선스는 아주 커플링이 심하다는 증거이다.
- 동적 커네이선스
	- 실행 커네이선스
		- `여러 컴포넌트의 실행 순서가 중요하다` 예를 들면, `email.setRecipient -> setSender -> send -> setSubject` 의 호출 흐름을 갖는 코드가 있다
	- 시점 커네이선스
		- `여러 컴포넌트의 실행 시점이 중요하다` 가장 일반적인 사례는 동시 실행 중인 두 스레드로 인한 경합 조건이 발생하여 공동 작업의 결과에 영향을 끼치는 것이다
	- 값 커네이선스
		- `상호 연관된 다수의 값들을 함께 변경할 때 발생한다` 개발자가 꼭지점 4개로 사각형을 정의했을 때 자료구조의 무결성을 유지하기 위해서는 다른 꼭지점에 미치는 영향을 고려하여 함부로 어느 한 꼭지점을 변경해서는 안된다. 또 다른 예로는 분산 시스템의 트랜잭션을 들 수 있다. 데이터베이스가 각각 분리된 시스템을 설계했는데 모든 데이터베이스에서 하나의 값을 업데이트해야 할 경우 원자성을 고려해야 된다
	- 식별 커네이선스
		- `여러 컴포넌트가 동일한 엔티티를 참조할 때 발생한다` 독립적인 두 컴포넌트가 분산 큐 같은 자료 구조를 공유해서 업데이트하는 경우이다.
- 커네이선스 속성
	- 강도
		- 어떤 유형의 커네이선스를 얼마나 쉽게 리팩터링할 수 있는지에 따라 커네이선스 강도가 결정된다. 커네이선스마다 강도는 다르게 측정되므로, 낮은 강도의 커네이선스를 높은 강도의 커네이선스로 리팩터링하는 것이 바람직하다
	- 지역성
		- 코드베이스의 모듈들이 서로 얼마나 가까이 있는지 나타낸다. 근접한 코드는 더 분리된 코드보다 높은 형태의 커네이선스를 가진다.
	- 정도
		- 커네이선스가 미치는 영향의 규모(얼마나 많은 클래스에 영향을 끼치는가)에 관한 것이다. 이 값이 작을 수록 코드베이스에 이롭다.
- 커네이선스를 이용해 시스템의 모듈성을 개선하는 방법
	- 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이션스를 최소화한다
	- 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화한다
	- 캡슐화 경계 내부에서 커네이선스를 최대화한다
- 두 가지 조언
	- 정도의 규칙
		- 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환하라
	- 지역성의 규칙
		- 소프트웨어 엘리먼트 간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 사용하라
